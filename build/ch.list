
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

00200000 <_vectors>:
  200000:	20000400 	.word	0x20000400
  200004:	002002d9 	.word	0x002002d9
  200008:	002002db 	.word	0x002002db
  20000c:	002002db 	.word	0x002002db
  200010:	002002db 	.word	0x002002db
  200014:	002002db 	.word	0x002002db
  200018:	002002db 	.word	0x002002db
  20001c:	002002db 	.word	0x002002db
  200020:	002002db 	.word	0x002002db
  200024:	002002db 	.word	0x002002db
  200028:	002002db 	.word	0x002002db
  20002c:	002041e1 	.word	0x002041e1
  200030:	002002db 	.word	0x002002db
  200034:	002002db 	.word	0x002002db
  200038:	002002db 	.word	0x002002db
  20003c:	002002db 	.word	0x002002db
  200040:	002002db 	.word	0x002002db
  200044:	002002db 	.word	0x002002db
  200048:	002002db 	.word	0x002002db
  20004c:	002002db 	.word	0x002002db
  200050:	002002db 	.word	0x002002db
  200054:	002002db 	.word	0x002002db
  200058:	00202051 	.word	0x00202051
  20005c:	002020c1 	.word	0x002020c1
  200060:	00202131 	.word	0x00202131
  200064:	002021a1 	.word	0x002021a1
  200068:	00202211 	.word	0x00202211
  20006c:	00202911 	.word	0x00202911
  200070:	00202981 	.word	0x00202981
  200074:	002029f1 	.word	0x002029f1
  200078:	00202a61 	.word	0x00202a61
  20007c:	00202ad1 	.word	0x00202ad1
  200080:	00202b41 	.word	0x00202b41
  200084:	00202bb1 	.word	0x00202bb1
  200088:	002002db 	.word	0x002002db
  20008c:	002002db 	.word	0x002002db
  200090:	002002db 	.word	0x002002db
  200094:	002002db 	.word	0x002002db
  200098:	002002db 	.word	0x002002db
  20009c:	00202281 	.word	0x00202281
  2000a0:	00202581 	.word	0x00202581
  2000a4:	002025d1 	.word	0x002025d1
  2000a8:	00202631 	.word	0x00202631
  2000ac:	00202681 	.word	0x00202681
  2000b0:	002026e1 	.word	0x002026e1
  2000b4:	002027d1 	.word	0x002027d1
  2000b8:	00202871 	.word	0x00202871
  2000bc:	002002db 	.word	0x002002db
  2000c0:	002002db 	.word	0x002002db
  2000c4:	002002db 	.word	0x002002db
  2000c8:	002002db 	.word	0x002002db
  2000cc:	002002db 	.word	0x002002db
  2000d0:	002002db 	.word	0x002002db
  2000d4:	002002db 	.word	0x002002db
  2000d8:	002002db 	.word	0x002002db
  2000dc:	00202361 	.word	0x00202361
  2000e0:	002022f1 	.word	0x002022f1
  2000e4:	002002db 	.word	0x002002db
  2000e8:	002002db 	.word	0x002002db
  2000ec:	002002db 	.word	0x002002db
  2000f0:	002002db 	.word	0x002002db
  2000f4:	002002db 	.word	0x002002db
  2000f8:	002002db 	.word	0x002002db
  2000fc:	00202c21 	.word	0x00202c21
  200100:	002002db 	.word	0x002002db
  200104:	002002db 	.word	0x002002db
  200108:	002002db 	.word	0x002002db
  20010c:	002002db 	.word	0x002002db
  200110:	002002db 	.word	0x002002db
  200114:	002002db 	.word	0x002002db
  200118:	002002db 	.word	0x002002db
  20011c:	002002db 	.word	0x002002db
  200120:	00202c91 	.word	0x00202c91
  200124:	00202d01 	.word	0x00202d01
  200128:	00202d71 	.word	0x00202d71
  20012c:	00202de1 	.word	0x00202de1
  200130:	00202e51 	.word	0x00202e51
  200134:	002002db 	.word	0x002002db
  200138:	002002db 	.word	0x002002db
  20013c:	002002db 	.word	0x002002db
  200140:	002002db 	.word	0x002002db
  200144:	002002db 	.word	0x002002db
  200148:	002002db 	.word	0x002002db
  20014c:	002002db 	.word	0x002002db
  200150:	00202ec1 	.word	0x00202ec1
  200154:	00202f31 	.word	0x00202f31
  200158:	00202fa1 	.word	0x00202fa1
  20015c:	002002db 	.word	0x002002db
  200160:	002002db 	.word	0x002002db
  200164:	002002db 	.word	0x002002db
  200168:	002002db 	.word	0x002002db
  20016c:	002002db 	.word	0x002002db
  200170:	002002db 	.word	0x002002db
  200174:	002002db 	.word	0x002002db
  200178:	002002db 	.word	0x002002db
  20017c:	002002db 	.word	0x002002db
  200180:	002002db 	.word	0x002002db
  200184:	002002db 	.word	0x002002db
  200188:	002002db 	.word	0x002002db
  20018c:	002002db 	.word	0x002002db
  200190:	002002db 	.word	0x002002db
  200194:	002002db 	.word	0x002002db
  200198:	002002db 	.word	0x002002db
  20019c:	002002db 	.word	0x002002db
  2001a0:	002002db 	.word	0x002002db
  2001a4:	002002db 	.word	0x002002db
  2001a8:	002002db 	.word	0x002002db
  2001ac:	002002db 	.word	0x002002db
  2001b0:	002002db 	.word	0x002002db
  2001b4:	002002db 	.word	0x002002db
  2001b8:	002002db 	.word	0x002002db
  2001bc:	002002db 	.word	0x002002db
  2001c0:	002002db 	.word	0x002002db
  2001c4:	002002db 	.word	0x002002db
  2001c8:	002002db 	.word	0x002002db
  2001cc:	002002db 	.word	0x002002db
  2001d0:	002002db 	.word	0x002002db
  2001d4:	002002db 	.word	0x002002db
  2001d8:	002002db 	.word	0x002002db
  2001dc:	002002db 	.word	0x002002db
  2001e0:	002002db 	.word	0x002002db
  2001e4:	002002db 	.word	0x002002db
  2001e8:	002002db 	.word	0x002002db
  2001ec:	002002db 	.word	0x002002db
  2001f0:	002002db 	.word	0x002002db
  2001f4:	002002db 	.word	0x002002db
  2001f8:	002002db 	.word	0x002002db
  2001fc:	002002db 	.word	0x002002db

Disassembly of section .text:

00200200 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
  200200:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
  200202:	4827      	ldr	r0, [pc, #156]	; (2002a0 <endfiniloop+0x4>)
                msr     MSP, r0
  200204:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
  200208:	4826      	ldr	r0, [pc, #152]	; (2002a4 <endfiniloop+0x8>)
                msr     PSP, r0
  20020a:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
  20020e:	4826      	ldr	r0, [pc, #152]	; (2002a8 <endfiniloop+0xc>)
                movw    r1, #SCB_VTOR & 0xFFFF
  200210:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
  200214:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
  200218:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
  20021a:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
  20021c:	f380 8814 	msr	CONTROL, r0
                isb
  200220:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
  200224:	f001 fe8c 	bl	201f40 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
  200228:	f002 fef2 	bl	203010 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
  20022c:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
  200230:	491e      	ldr	r1, [pc, #120]	; (2002ac <endfiniloop+0x10>)
                ldr     r2, =__main_stack_end__
  200232:	4a1b      	ldr	r2, [pc, #108]	; (2002a0 <endfiniloop+0x4>)

00200234 <msloop>:
msloop:
                cmp     r1, r2
  200234:	4291      	cmp	r1, r2
                itt     lo
  200236:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200238:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
  20023c:	e7fa      	bcc.n	200234 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
  20023e:	491c      	ldr	r1, [pc, #112]	; (2002b0 <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
  200240:	4a18      	ldr	r2, [pc, #96]	; (2002a4 <endfiniloop+0x8>)

00200242 <psloop>:
psloop:
                cmp     r1, r2
  200242:	4291      	cmp	r1, r2
                itt     lo
  200244:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  200246:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
  20024a:	e7fa      	bcc.n	200242 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =__textdata_base__
  20024c:	4919      	ldr	r1, [pc, #100]	; (2002b4 <endfiniloop+0x18>)
                ldr     r2, =__data_base__
  20024e:	4a1a      	ldr	r2, [pc, #104]	; (2002b8 <endfiniloop+0x1c>)
                ldr     r3, =__data_end__
  200250:	4b1a      	ldr	r3, [pc, #104]	; (2002bc <endfiniloop+0x20>)

00200252 <dloop>:
dloop:
                cmp     r2, r3
  200252:	429a      	cmp	r2, r3
                ittt    lo
  200254:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
  200256:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
  20025a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
  20025e:	e7f8      	bcc.n	200252 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
  200260:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
  200262:	4917      	ldr	r1, [pc, #92]	; (2002c0 <endfiniloop+0x24>)
                ldr     r2, =__bss_end__
  200264:	4a17      	ldr	r2, [pc, #92]	; (2002c4 <endfiniloop+0x28>)

00200266 <bloop>:
bloop:
                cmp     r1, r2
  200266:	4291      	cmp	r1, r2
                itt     lo
  200268:	bf3c      	itt	cc
                strlo   r0, [r1], #4
  20026a:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
  20026e:	e7fa      	bcc.n	200266 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
  200270:	f001 feb6 	bl	201fe0 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
  200274:	f001 fea4 	bl	201fc0 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
  200278:	4c13      	ldr	r4, [pc, #76]	; (2002c8 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end__
  20027a:	4d14      	ldr	r5, [pc, #80]	; (2002cc <endfiniloop+0x30>)

0020027c <initloop>:
initloop:
                cmp     r4, r5
  20027c:	42ac      	cmp	r4, r5
                bge     endinitloop
  20027e:	da03      	bge.n	200288 <endinitloop>
                ldr     r1, [r4], #4
  200280:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  200284:	4788      	blx	r1
                b       initloop
  200286:	e7f9      	b.n	20027c <initloop>

00200288 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
  200288:	f003 ffba 	bl	204200 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
  20028c:	4c10      	ldr	r4, [pc, #64]	; (2002d0 <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end__
  20028e:	4d11      	ldr	r5, [pc, #68]	; (2002d4 <endfiniloop+0x38>)

00200290 <finiloop>:
finiloop:
                cmp     r4, r5
  200290:	42ac      	cmp	r4, r5
                bge     endfiniloop
  200292:	da03      	bge.n	20029c <endfiniloop>
                ldr     r1, [r4], #4
  200294:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
  200298:	4788      	blx	r1
                b       finiloop
  20029a:	e7f9      	b.n	200290 <finiloop>

0020029c <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
  20029c:	f001 be98 	b.w	201fd0 <__default_exit>
                ldr     r0, =__main_stack_end__
  2002a0:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
  2002a4:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
  2002a8:	00200000 	.word	0x00200000
                ldr     r1, =__main_stack_base__
  2002ac:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
  2002b0:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
  2002b4:	08006050 	.word	0x08006050
                ldr     r2, =__data_base__
  2002b8:	20020000 	.word	0x20020000
                ldr     r3, =__data_end__
  2002bc:	200200d0 	.word	0x200200d0
                ldr     r1, =__bss_base__
  2002c0:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
  2002c4:	20002048 	.word	0x20002048
                ldr     r4, =__init_array_base__
  2002c8:	00200200 	.word	0x00200200
                ldr     r5, =__init_array_end__
  2002cc:	00200200 	.word	0x00200200
                ldr     r4, =__fini_array_base__
  2002d0:	00200200 	.word	0x00200200
                ldr     r5, =__fini_array_end__
  2002d4:	00200200 	.word	0x00200200

002002d8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
  2002d8:	e792      	b.n	200200 <_crt0_entry>

002002da <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
  2002da:	f000 f800 	bl	2002de <_unhandled_exception>

002002de <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
  2002de:	e7fe      	b.n	2002de <_unhandled_exception>

002002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
  2002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
  2002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
                mov     sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
  2002e8:	f8d0 d00c 	ldr.w	sp, [r0, #12]

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
  2002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

002002f0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
  2002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
  2002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
  2002f6:	4628      	mov	r0, r5
                blx     r4
  2002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
  2002fa:	2000      	movs	r0, #0
                bl      chThdExit
  2002fc:	f003 ff30 	bl	204160 <chThdExit>

00200300 <_zombies>:
_zombies:       b       _zombies
  200300:	e7fe      	b.n	200300 <_zombies>

00200302 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
  200302:	f003 f805 	bl	203310 <chSchDoReschedule>

00200306 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
  200306:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
  200308:	e7fe      	b.n	200308 <_port_exit_from_isr+0x2>
  20030a:	0000      	movs	r0, r0
  20030c:	0000      	movs	r0, r0
	...

00200310 <memchr>:
  200310:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  200314:	2a10      	cmp	r2, #16
  200316:	db2b      	blt.n	200370 <memchr+0x60>
  200318:	f010 0f07 	tst.w	r0, #7
  20031c:	d008      	beq.n	200330 <memchr+0x20>
  20031e:	f810 3b01 	ldrb.w	r3, [r0], #1
  200322:	3a01      	subs	r2, #1
  200324:	428b      	cmp	r3, r1
  200326:	d02d      	beq.n	200384 <memchr+0x74>
  200328:	f010 0f07 	tst.w	r0, #7
  20032c:	b342      	cbz	r2, 200380 <memchr+0x70>
  20032e:	d1f6      	bne.n	20031e <memchr+0xe>
  200330:	b4f0      	push	{r4, r5, r6, r7}
  200332:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
  200336:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
  20033a:	f022 0407 	bic.w	r4, r2, #7
  20033e:	f07f 0700 	mvns.w	r7, #0
  200342:	2300      	movs	r3, #0
  200344:	e8f0 5602 	ldrd	r5, r6, [r0], #8
  200348:	3c08      	subs	r4, #8
  20034a:	ea85 0501 	eor.w	r5, r5, r1
  20034e:	ea86 0601 	eor.w	r6, r6, r1
  200352:	fa85 f547 	uadd8	r5, r5, r7
  200356:	faa3 f587 	sel	r5, r3, r7
  20035a:	fa86 f647 	uadd8	r6, r6, r7
  20035e:	faa5 f687 	sel	r6, r5, r7
  200362:	b98e      	cbnz	r6, 200388 <memchr+0x78>
  200364:	d1ee      	bne.n	200344 <memchr+0x34>
  200366:	bcf0      	pop	{r4, r5, r6, r7}
  200368:	f001 01ff 	and.w	r1, r1, #255	; 0xff
  20036c:	f002 0207 	and.w	r2, r2, #7
  200370:	b132      	cbz	r2, 200380 <memchr+0x70>
  200372:	f810 3b01 	ldrb.w	r3, [r0], #1
  200376:	3a01      	subs	r2, #1
  200378:	ea83 0301 	eor.w	r3, r3, r1
  20037c:	b113      	cbz	r3, 200384 <memchr+0x74>
  20037e:	d1f8      	bne.n	200372 <memchr+0x62>
  200380:	2000      	movs	r0, #0
  200382:	4770      	bx	lr
  200384:	3801      	subs	r0, #1
  200386:	4770      	bx	lr
  200388:	2d00      	cmp	r5, #0
  20038a:	bf06      	itte	eq
  20038c:	4635      	moveq	r5, r6
  20038e:	3803      	subeq	r0, #3
  200390:	3807      	subne	r0, #7
  200392:	f015 0f01 	tst.w	r5, #1
  200396:	d107      	bne.n	2003a8 <memchr+0x98>
  200398:	3001      	adds	r0, #1
  20039a:	f415 7f80 	tst.w	r5, #256	; 0x100
  20039e:	bf02      	ittt	eq
  2003a0:	3001      	addeq	r0, #1
  2003a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
  2003a6:	3001      	addeq	r0, #1
  2003a8:	bcf0      	pop	{r4, r5, r6, r7}
  2003aa:	3801      	subs	r0, #1
  2003ac:	4770      	bx	lr
  2003ae:	bf00      	nop

002003b0 <_ctl>:
#else
    break;
#endif
  }
  return MSG_OK;
}
  2003b0:	2000      	movs	r0, #0
  2003b2:	4770      	bx	lr
	...

002003c0 <_port_irq_epilogue>:
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2003c0:	2320      	movs	r3, #32
  2003c2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2003c6:	4b0d      	ldr	r3, [pc, #52]	; (2003fc <_port_irq_epilogue+0x3c>)
  2003c8:	685b      	ldr	r3, [r3, #4]
  2003ca:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2003ce:	d102      	bne.n	2003d6 <_port_irq_epilogue+0x16>
  2003d0:	f383 8811 	msr	BASEPRI, r3
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
  2003d4:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2003d6:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  2003da:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  2003de:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2003e0:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2003e2:	f383 8809 	msr	PSP, r3
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2003e6:	4a06      	ldr	r2, [pc, #24]	; (200400 <_port_irq_epilogue+0x40>)
  2003e8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  2003ea:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  2003ec:	6889      	ldr	r1, [r1, #8]
  2003ee:	6892      	ldr	r2, [r2, #8]
  2003f0:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  2003f2:	bf8c      	ite	hi
  2003f4:	4a03      	ldrhi	r2, [pc, #12]	; (200404 <_port_irq_epilogue+0x44>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  2003f6:	4a04      	ldrls	r2, [pc, #16]	; (200408 <_port_irq_epilogue+0x48>)
  2003f8:	619a      	str	r2, [r3, #24]
  2003fa:	4770      	bx	lr
  2003fc:	e000ed00 	.word	0xe000ed00
  200400:	200009d0 	.word	0x200009d0
  200404:	00200303 	.word	0x00200303
  200408:	00200306 	.word	0x00200306
  20040c:	00000000 	.word	0x00000000

00200410 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  200410:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  200414:	f002 0803 	and.w	r8, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  200418:	f3c2 1541 	ubfx	r5, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  20041c:	09d6      	lsrs	r6, r2, #7
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
  20041e:	f04f 0b0f 	mov.w	fp, #15
  uint32_t bit     = 0;
  200422:	2200      	movs	r2, #0
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  200424:	4644      	mov	r4, r8
      m1 = 1 << bit;
  200426:	f04f 0a01 	mov.w	sl, #1
      m2 = 3 << (bit * 2);
  20042a:	f04f 0903 	mov.w	r9, #3
  20042e:	e013      	b.n	200458 <_pal_lld_setgroupmode+0x48>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
  200430:	f8d0 e000 	ldr.w	lr, [r0]
        if (bit < 8)
  200434:	2a07      	cmp	r2, #7
        port->MODER   = (port->MODER & ~m2) | moder;
  200436:	ea03 030e 	and.w	r3, r3, lr
  20043a:	ea43 0304 	orr.w	r3, r3, r4
  20043e:	6003      	str	r3, [r0, #0]
        if (bit < 8)
  200440:	d844      	bhi.n	2004cc <_pal_lld_setgroupmode+0xbc>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  200442:	6a03      	ldr	r3, [r0, #32]
  200444:	ea23 0c0c 	bic.w	ip, r3, ip
  200448:	ea4c 0707 	orr.w	r7, ip, r7
  20044c:	6207      	str	r7, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
  20044e:	0849      	lsrs	r1, r1, #1
  200450:	d03a      	beq.n	2004c8 <_pal_lld_setgroupmode+0xb8>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
  200452:	00ad      	lsls	r5, r5, #2
    moder <<= 2;
    bit++;
  200454:	3201      	adds	r2, #1
    moder <<= 2;
  200456:	00a4      	lsls	r4, r4, #2
    if ((mask & 1) != 0) {
  200458:	07cb      	lsls	r3, r1, #31
  20045a:	d5f8      	bpl.n	20044e <_pal_lld_setgroupmode+0x3e>
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  20045c:	6843      	ldr	r3, [r0, #4]
      m1 = 1 << bit;
  20045e:	fa0a fe02 	lsl.w	lr, sl, r2
      altrmask = altr << ((bit & 7) * 4);
  200462:	f002 0c07 	and.w	ip, r2, #7
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
  200466:	f1b8 0f02 	cmp.w	r8, #2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  20046a:	ea23 030e 	bic.w	r3, r3, lr
      altrmask = altr << ((bit & 7) * 4);
  20046e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
  200472:	6043      	str	r3, [r0, #4]
      m2 = 3 << (bit * 2);
  200474:	ea4f 0342 	mov.w	r3, r2, lsl #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  200478:	f8d0 e008 	ldr.w	lr, [r0, #8]
      altrmask = altr << ((bit & 7) * 4);
  20047c:	fa06 f70c 	lsl.w	r7, r6, ip
      m2 = 3 << (bit * 2);
  200480:	fa09 f303 	lsl.w	r3, r9, r3
      m4 = 15 << ((bit & 7) * 4);
  200484:	fa0b fc0c 	lsl.w	ip, fp, ip
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  200488:	ea2e 0e03 	bic.w	lr, lr, r3
  20048c:	f8c0 e008 	str.w	lr, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
  200490:	f8d0 e00c 	ldr.w	lr, [r0, #12]
  200494:	ea2e 0e03 	bic.w	lr, lr, r3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
  200498:	ea6f 0303 	mvn.w	r3, r3
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
  20049c:	ea4e 0e05 	orr.w	lr, lr, r5
  2004a0:	f8c0 e00c 	str.w	lr, [r0, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
  2004a4:	d1c4      	bne.n	200430 <_pal_lld_setgroupmode+0x20>
        if (bit < 8)
  2004a6:	2a07      	cmp	r2, #7
  2004a8:	d817      	bhi.n	2004da <_pal_lld_setgroupmode+0xca>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
  2004aa:	f8d0 e020 	ldr.w	lr, [r0, #32]
  2004ae:	ea2e 0c0c 	bic.w	ip, lr, ip
  2004b2:	ea4c 0707 	orr.w	r7, ip, r7
  2004b6:	6207      	str	r7, [r0, #32]
        port->MODER   = (port->MODER & ~m2) | moder;
  2004b8:	6807      	ldr	r7, [r0, #0]
    if (!mask)
  2004ba:	0849      	lsrs	r1, r1, #1
        port->MODER   = (port->MODER & ~m2) | moder;
  2004bc:	ea03 0307 	and.w	r3, r3, r7
  2004c0:	ea43 0304 	orr.w	r3, r3, r4
  2004c4:	6003      	str	r3, [r0, #0]
    if (!mask)
  2004c6:	d1c4      	bne.n	200452 <_pal_lld_setgroupmode+0x42>
  }
}
  2004c8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  2004cc:	6a43      	ldr	r3, [r0, #36]	; 0x24
  2004ce:	ea23 0c0c 	bic.w	ip, r3, ip
  2004d2:	ea4c 0707 	orr.w	r7, ip, r7
  2004d6:	6247      	str	r7, [r0, #36]	; 0x24
  2004d8:	e7b9      	b.n	20044e <_pal_lld_setgroupmode+0x3e>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
  2004da:	f8d0 e024 	ldr.w	lr, [r0, #36]	; 0x24
  2004de:	ea2e 0c0c 	bic.w	ip, lr, ip
  2004e2:	ea4c 0707 	orr.w	r7, ip, r7
  2004e6:	6247      	str	r7, [r0, #36]	; 0x24
  2004e8:	e7e6      	b.n	2004b8 <_pal_lld_setgroupmode+0xa8>
  2004ea:	bf00      	nop
  2004ec:	0000      	movs	r0, r0
	...

002004f0 <_pal_lld_enablepadevent>:
                             ioeventmode_t mode) {

  uint32_t padmask, cridx, croff, crmask, portidx;

  /* Mask of the pad.*/
  padmask = 1U << (uint32_t)pad;
  2004f0:	2301      	movs	r3, #1
  portidx = (((uint32_t)port - (uint32_t)GPIOA) >> 10U) & 0xFU;

  /* Index and mask of the CR register to be used.*/
  cridx  = (uint32_t)pad >> 2U;
#if STM32_EXTI_HAS_CR == FALSE
  croff  = ((uint32_t)pad & 3U) * 4U;
  2004f2:	f001 0c03 	and.w	ip, r1, #3
  portidx = (((uint32_t)port - (uint32_t)GPIOA) >> 10U) & 0xFU;
  2004f6:	f3c0 2083 	ubfx	r0, r0, #10, #4
  /* Programming edge registers.*/
  if (mode & PAL_EVENT_MODE_RISING_EDGE)
    EXTI->RTSR1 |= padmask;
  else
    EXTI->RTSR1 &= ~padmask;
  if (mode & PAL_EVENT_MODE_FALLING_EDGE)
  2004fa:	f012 0f02 	tst.w	r2, #2
  padmask = 1U << (uint32_t)pad;
  2004fe:	fa03 f301 	lsl.w	r3, r3, r1
  croff  = ((uint32_t)pad & 3U) * 4U;
  200502:	f021 0103 	bic.w	r1, r1, #3
  200506:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
                             ioeventmode_t mode) {
  20050a:	b410      	push	{r4}
  20050c:	4c11      	ldr	r4, [pc, #68]	; (200554 <_pal_lld_enablepadevent+0x64>)
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  20050e:	fa00 f00c 	lsl.w	r0, r0, ip
  200512:	440c      	add	r4, r1
  crmask = ~(0xFU << croff);
  200514:	f04f 010f 	mov.w	r1, #15
  200518:	fa01 fc0c 	lsl.w	ip, r1, ip
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  20051c:	68a1      	ldr	r1, [r4, #8]
  20051e:	ea21 0c0c 	bic.w	ip, r1, ip
    EXTI->RTSR1 |= padmask;
  200522:	490d      	ldr	r1, [pc, #52]	; (200558 <_pal_lld_enablepadevent+0x68>)
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  200524:	ea40 000c 	orr.w	r0, r0, ip
  200528:	60a0      	str	r0, [r4, #8]
    EXTI->RTSR1 |= padmask;
  20052a:	6888      	ldr	r0, [r1, #8]
  EXTI_D1->EMR1 &= ~padmask;
#else
  EXTI->IMR1 |= padmask;
  EXTI->EMR1 &= ~padmask;
#endif
}
  20052c:	bc10      	pop	{r4}
    EXTI->RTSR1 |= padmask;
  20052e:	ea40 0003 	orr.w	r0, r0, r3
  200532:	6088      	str	r0, [r1, #8]
    EXTI->FTSR1 &= ~padmask;
  200534:	ea6f 0003 	mvn.w	r0, r3
    EXTI->FTSR1 |= padmask;
  200538:	68ca      	ldr	r2, [r1, #12]
  20053a:	bf14      	ite	ne
  20053c:	431a      	orrne	r2, r3
    EXTI->FTSR1 &= ~padmask;
  20053e:	439a      	biceq	r2, r3
  200540:	60ca      	str	r2, [r1, #12]
  EXTI->IMR1 |= padmask;
  200542:	4a05      	ldr	r2, [pc, #20]	; (200558 <_pal_lld_enablepadevent+0x68>)
  200544:	6811      	ldr	r1, [r2, #0]
  200546:	430b      	orrs	r3, r1
  200548:	6013      	str	r3, [r2, #0]
  EXTI->EMR1 &= ~padmask;
  20054a:	6853      	ldr	r3, [r2, #4]
  20054c:	4003      	ands	r3, r0
  20054e:	6053      	str	r3, [r2, #4]
}
  200550:	4770      	bx	lr
  200552:	bf00      	nop
  200554:	40013800 	.word	0x40013800
  200558:	40013c00 	.word	0x40013c00
  20055c:	00000000 	.word	0x00000000

00200560 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
  200560:	b410      	push	{r4}
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
  200562:	7803      	ldrb	r3, [r0, #0]
  200564:	2b01      	cmp	r3, #1
  200566:	d013      	beq.n	200590 <gpt_lld_start+0x30>
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  200568:	68c2      	ldr	r2, [r0, #12]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  20056a:	e9d0 1301 	ldrd	r1, r3, [r0, #4]
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  20056e:	2000      	movs	r0, #0
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  200570:	680c      	ldr	r4, [r1, #0]
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
  200572:	6010      	str	r0, [r2, #0]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  200574:	fbb3 f3f4 	udiv	r3, r3, r4
  gptp->tim->CR2  = gptp->config->cr2;
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
  200578:	e9d1 4102 	ldrd	r4, r1, [r1, #8]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  20057c:	3b01      	subs	r3, #1
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
  20057e:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  gptp->tim->CR2  = gptp->config->cr2;
  200582:	6054      	str	r4, [r2, #4]
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
  200584:	b29b      	uxth	r3, r3
                    ~STM32_TIM_DIER_IRQ_MASK;
}
  200586:	bc10      	pop	{r4}
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
  200588:	6293      	str	r3, [r2, #40]	; 0x28
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
  20058a:	6110      	str	r0, [r2, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
  20058c:	60d1      	str	r1, [r2, #12]
}
  20058e:	4770      	bx	lr
    if (&GPTD3 == gptp) {
  200590:	4b18      	ldr	r3, [pc, #96]	; (2005f4 <gpt_lld_start+0x94>)
  200592:	4298      	cmp	r0, r3
  200594:	d018      	beq.n	2005c8 <gpt_lld_start+0x68>
    if (&GPTD4 == gptp) {
  200596:	4b18      	ldr	r3, [pc, #96]	; (2005f8 <gpt_lld_start+0x98>)
  200598:	4298      	cmp	r0, r3
  20059a:	d1e5      	bne.n	200568 <gpt_lld_start+0x8>
      rccEnableTIM4(true);
  20059c:	4b17      	ldr	r3, [pc, #92]	; (2005fc <gpt_lld_start+0x9c>)
      gptp->clock = STM32_TIMCLK1;
  20059e:	4918      	ldr	r1, [pc, #96]	; (200600 <gpt_lld_start+0xa0>)
      rccEnableTIM4(true);
  2005a0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  2005a2:	f042 0204 	orr.w	r2, r2, #4
  2005a6:	641a      	str	r2, [r3, #64]	; 0x40
  2005a8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  2005aa:	f042 0204 	orr.w	r2, r2, #4
  2005ae:	661a      	str	r2, [r3, #96]	; 0x60
  2005b0:	6e1a      	ldr	r2, [r3, #96]	; 0x60
      rccResetTIM4();
  2005b2:	6a1a      	ldr	r2, [r3, #32]
  2005b4:	f042 0204 	orr.w	r2, r2, #4
  2005b8:	621a      	str	r2, [r3, #32]
  2005ba:	6a1a      	ldr	r2, [r3, #32]
  2005bc:	f022 0204 	bic.w	r2, r2, #4
  2005c0:	621a      	str	r2, [r3, #32]
  2005c2:	6a1b      	ldr	r3, [r3, #32]
      gptp->clock = STM32_TIMCLK1;
  2005c4:	6081      	str	r1, [r0, #8]
  2005c6:	e7cf      	b.n	200568 <gpt_lld_start+0x8>
      rccEnableTIM3(true);
  2005c8:	4b0c      	ldr	r3, [pc, #48]	; (2005fc <gpt_lld_start+0x9c>)
      gptp->clock = STM32_TIMCLK1;
  2005ca:	490d      	ldr	r1, [pc, #52]	; (200600 <gpt_lld_start+0xa0>)
      rccEnableTIM3(true);
  2005cc:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  2005ce:	f042 0202 	orr.w	r2, r2, #2
  2005d2:	641a      	str	r2, [r3, #64]	; 0x40
  2005d4:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  2005d6:	f042 0202 	orr.w	r2, r2, #2
  2005da:	661a      	str	r2, [r3, #96]	; 0x60
  2005dc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
      rccResetTIM3();
  2005de:	6a1a      	ldr	r2, [r3, #32]
  2005e0:	f042 0202 	orr.w	r2, r2, #2
  2005e4:	621a      	str	r2, [r3, #32]
  2005e6:	6a1a      	ldr	r2, [r3, #32]
  2005e8:	f022 0202 	bic.w	r2, r2, #2
  2005ec:	621a      	str	r2, [r3, #32]
  2005ee:	6a1b      	ldr	r3, [r3, #32]
      gptp->clock = STM32_TIMCLK1;
  2005f0:	6081      	str	r1, [r0, #8]
    if (&GPTD4 == gptp) {
  2005f2:	e7b9      	b.n	200568 <gpt_lld_start+0x8>
  2005f4:	20000800 	.word	0x20000800
  2005f8:	20000810 	.word	0x20000810
  2005fc:	40023800 	.word	0x40023800
  200600:	066ff300 	.word	0x066ff300
	...

00200610 <notify3>:

#if STM32_SERIAL_USE_USART3 || defined(__DOXYGEN__)
static void notify3(io_queue_t *qp) {

  (void)qp;
  USART3->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
  200610:	4a02      	ldr	r2, [pc, #8]	; (20061c <notify3+0xc>)
  200612:	6813      	ldr	r3, [r2, #0]
  200614:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
  200618:	6013      	str	r3, [r2, #0]
}
  20061a:	4770      	bx	lr
  20061c:	40004800 	.word	0x40004800

00200620 <_idle_thread>:
__STATIC_FORCEINLINE void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
  200620:	e7fe      	b.n	200620 <_idle_thread>
  200622:	bf00      	nop
	...

00200630 <wakeup>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  200630:	2320      	movs	r3, #32
  200632:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
  200636:	f890 3020 	ldrb.w	r3, [r0, #32]
  20063a:	2b07      	cmp	r3, #7
  20063c:	d80d      	bhi.n	20065a <wakeup+0x2a>
  20063e:	e8df f003 	tbb	[pc, r3]
  200642:	0c27      	.short	0x0c27
  200644:	0408230c 	.word	0x0408230c
  200648:	080c      	.short	0x080c
    chSemFastSignalI(tp->u.wtsemp);
  20064a:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
  20064c:	6893      	ldr	r3, [r2, #8]
  20064e:	3301      	adds	r3, #1
  200650:	6093      	str	r3, [r2, #8]
 *
 * @notapi
 */
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {

  p->prev->next = p->next;
  200652:	e9d0 3200 	ldrd	r3, r2, [r0]
  200656:	6013      	str	r3, [r2, #0]
  p->next->prev = p->prev;
  200658:	605a      	str	r2, [r3, #4]
  tp->state = CH_STATE_READY;
  20065a:	2200      	movs	r2, #0
                                                           ch_priority_queue_t *p) {

  /* Scanning priority queue.*/
  do {
    pqp = pqp->next;
  } while (pqp->prio >= p->prio);
  20065c:	6881      	ldr	r1, [r0, #8]
  20065e:	4b0e      	ldr	r3, [pc, #56]	; (200698 <wakeup+0x68>)
  200660:	f880 2020 	strb.w	r2, [r0, #32]
static void wakeup(void *p) {
  200664:	b410      	push	{r4}
  tp->u.rdymsg = MSG_TIMEOUT;
  200666:	f04f 34ff 	mov.w	r4, #4294967295
  20066a:	6244      	str	r4, [r0, #36]	; 0x24
    pqp = pqp->next;
  20066c:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  20066e:	689a      	ldr	r2, [r3, #8]
  200670:	428a      	cmp	r2, r1
  200672:	d2fb      	bcs.n	20066c <wakeup+0x3c>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
  200674:	685a      	ldr	r2, [r3, #4]
  200676:	2100      	movs	r1, #0
  p->next       = pqp;
  200678:	6003      	str	r3, [r0, #0]
  p->prev       = pqp->prev;
  20067a:	6042      	str	r2, [r0, #4]
  p->prev->next = p;
  20067c:	6010      	str	r0, [r2, #0]
  pqp->prev     = p;
  20067e:	6058      	str	r0, [r3, #4]
  200680:	f381 8811 	msr	BASEPRI, r1
}
  200684:	bc10      	pop	{r4}
  200686:	4770      	bx	lr
    *tp->u.wttrp = NULL;
  200688:	6a43      	ldr	r3, [r0, #36]	; 0x24
  20068a:	2200      	movs	r2, #0
  20068c:	601a      	str	r2, [r3, #0]
    break;
  20068e:	e7e4      	b.n	20065a <wakeup+0x2a>
  200690:	2300      	movs	r3, #0
  200692:	f383 8811 	msr	BASEPRI, r3
  200696:	4770      	bx	lr
  200698:	200009d0 	.word	0x200009d0
  20069c:	00000000 	.word	0x00000000

002006a0 <chTMStartMeasurementX>:
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
  2006a0:	4b01      	ldr	r3, [pc, #4]	; (2006a8 <chTMStartMeasurementX+0x8>)
  2006a2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
  2006a4:	6083      	str	r3, [r0, #8]
}
  2006a6:	4770      	bx	lr
  2006a8:	e0001000 	.word	0xe0001000
  2006ac:	00000000 	.word	0x00000000

002006b0 <chTMStopMeasurementX>:
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  2006b0:	4a0e      	ldr	r2, [pc, #56]	; (2006ec <chTMStopMeasurementX+0x3c>)
  2006b2:	4b0f      	ldr	r3, [pc, #60]	; (2006f0 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
  2006b4:	6881      	ldr	r1, [r0, #8]
  2006b6:	685b      	ldr	r3, [r3, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
  2006b8:	b410      	push	{r4}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  2006ba:	6f54      	ldr	r4, [r2, #116]	; 0x74
  tmp->cumulative += (rttime_t)tmp->last;
  2006bc:	6902      	ldr	r2, [r0, #16]
  tmp->last = (now - tmp->last) - offset;
  2006be:	1b1b      	subs	r3, r3, r4
  tmp->n++;
  2006c0:	68c4      	ldr	r4, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  2006c2:	1a5b      	subs	r3, r3, r1
  tmp->cumulative += (rttime_t)tmp->last;
  2006c4:	6941      	ldr	r1, [r0, #20]
  tmp->n++;
  2006c6:	3401      	adds	r4, #1
  tmp->cumulative += (rttime_t)tmp->last;
  2006c8:	18d2      	adds	r2, r2, r3
  2006ca:	6102      	str	r2, [r0, #16]
  2006cc:	f141 0100 	adc.w	r1, r1, #0
  if (tmp->last > tmp->worst) {
  2006d0:	6842      	ldr	r2, [r0, #4]
  tmp->cumulative += (rttime_t)tmp->last;
  2006d2:	6141      	str	r1, [r0, #20]
  if (tmp->last > tmp->worst) {
  2006d4:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
  2006d6:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
  2006d8:	bf88      	it	hi
  2006da:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
  2006dc:	4293      	cmp	r3, r2
  tmp->n++;
  2006de:	e9c0 3402 	strd	r3, r4, [r0, #8]
    tmp->best = tmp->last;
  2006e2:	bf38      	it	cc
  2006e4:	6003      	strcc	r3, [r0, #0]
}
  2006e6:	bc10      	pop	{r4}
  2006e8:	4770      	bx	lr
  2006ea:	bf00      	nop
  2006ec:	200009d0 	.word	0x200009d0
  2006f0:	e0001000 	.word	0xe0001000
	...

00200700 <chCoreAllocFromTop>:
  200700:	2320      	movs	r3, #32
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
  200702:	b410      	push	{r4}
  200704:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  200708:	4b0b      	ldr	r3, [pc, #44]	; (200738 <chCoreAllocFromTop+0x38>)
  20070a:	4249      	negs	r1, r1
  20070c:	685c      	ldr	r4, [r3, #4]
  20070e:	1a20      	subs	r0, r4, r0
  200710:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
  200712:	6819      	ldr	r1, [r3, #0]
  prev = p - offset;
  200714:	1a82      	subs	r2, r0, r2
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
  200716:	428a      	cmp	r2, r1
  200718:	d307      	bcc.n	20072a <chCoreAllocFromTop+0x2a>
  20071a:	4294      	cmp	r4, r2
  20071c:	d305      	bcc.n	20072a <chCoreAllocFromTop+0x2a>
  ch_memcore.topmem = prev;
  20071e:	605a      	str	r2, [r3, #4]
  200720:	2300      	movs	r3, #0
  200722:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
  chSysUnlock();

  return p;
}
  200726:	bc10      	pop	{r4}
  200728:	4770      	bx	lr
    return NULL;
  20072a:	2000      	movs	r0, #0
  20072c:	2300      	movs	r3, #0
  20072e:	f383 8811 	msr	BASEPRI, r3
}
  200732:	bc10      	pop	{r4}
  200734:	4770      	bx	lr
  200736:	bf00      	nop
  200738:	20000b68 	.word	0x20000b68
  20073c:	00000000 	.word	0x00000000

00200740 <chCoreAllocAlignedI>:
  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
  200740:	4b06      	ldr	r3, [pc, #24]	; (20075c <chCoreAllocAlignedI+0x1c>)
  200742:	4249      	negs	r1, r1
  200744:	685a      	ldr	r2, [r3, #4]
  200746:	1a10      	subs	r0, r2, r0
  200748:	4008      	ands	r0, r1
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
  20074a:	6819      	ldr	r1, [r3, #0]
  20074c:	4288      	cmp	r0, r1
  20074e:	d303      	bcc.n	200758 <chCoreAllocAlignedI+0x18>
  200750:	4282      	cmp	r2, r0
  200752:	d301      	bcc.n	200758 <chCoreAllocAlignedI+0x18>
  ch_memcore.topmem = prev;
  200754:	6058      	str	r0, [r3, #4]
  return p;
  200756:	4770      	bx	lr
    return NULL;
  200758:	2000      	movs	r0, #0
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
}
  20075a:	4770      	bx	lr
  20075c:	20000b68 	.word	0x20000b68

00200760 <Holl>:
void Holl(void* args)
{
    // Преобразование аргумента к требуемому типу, в данному случае к uint8_t
    uint8_t arg = *((uint8_t*) args);
    // Проверка, что передача аргумента работает
      if(palReadPad(GPIOB,8u)==1)
  200760:	4b13      	ldr	r3, [pc, #76]	; (2007b0 <Holl+0x50>)
  200762:	691a      	ldr	r2, [r3, #16]
  200764:	05d2      	lsls	r2, r2, #23
  200766:	d50a      	bpl.n	20077e <Holl+0x1e>
      {
        if(palReadPad(GPIOB,9u)==1)
  200768:	691b      	ldr	r3, [r3, #16]
  20076a:	059b      	lsls	r3, r3, #22
  20076c:	d503      	bpl.n	200776 <Holl+0x16>
        {
          holl_speed++;
  20076e:	4a11      	ldr	r2, [pc, #68]	; (2007b4 <Holl+0x54>)
  200770:	8813      	ldrh	r3, [r2, #0]
  200772:	3301      	adds	r3, #1
  200774:	8013      	strh	r3, [r2, #0]
        }
        if(palReadPad(GPIOB,9u)==0)
  200776:	4b0e      	ldr	r3, [pc, #56]	; (2007b0 <Holl+0x50>)
  200778:	691b      	ldr	r3, [r3, #16]
  20077a:	0598      	lsls	r0, r3, #22
  20077c:	d513      	bpl.n	2007a6 <Holl+0x46>
        {
          holl_speed--;
        }
      }

      if(palReadPad(GPIOB,8u)==0)
  20077e:	4b0c      	ldr	r3, [pc, #48]	; (2007b0 <Holl+0x50>)
  200780:	691a      	ldr	r2, [r3, #16]
  200782:	05d1      	lsls	r1, r2, #23
  200784:	d40e      	bmi.n	2007a4 <Holl+0x44>
      {
        if(palReadPad(GPIOB,9u)==0)
  200786:	691b      	ldr	r3, [r3, #16]
  200788:	059a      	lsls	r2, r3, #22
  20078a:	d403      	bmi.n	200794 <Holl+0x34>
        {
          holl_speed++;
  20078c:	4a09      	ldr	r2, [pc, #36]	; (2007b4 <Holl+0x54>)
  20078e:	8813      	ldrh	r3, [r2, #0]
  200790:	3301      	adds	r3, #1
  200792:	8013      	strh	r3, [r2, #0]
        }
        if(palReadPad(GPIOB,9u)==1)
  200794:	4b06      	ldr	r3, [pc, #24]	; (2007b0 <Holl+0x50>)
  200796:	691b      	ldr	r3, [r3, #16]
  200798:	059b      	lsls	r3, r3, #22
  20079a:	d503      	bpl.n	2007a4 <Holl+0x44>
        {
          holl_speed--;
  20079c:	4a05      	ldr	r2, [pc, #20]	; (2007b4 <Holl+0x54>)
  20079e:	8813      	ldrh	r3, [r2, #0]
  2007a0:	3b01      	subs	r3, #1
  2007a2:	8013      	strh	r3, [r2, #0]
        }
      }

}
  2007a4:	4770      	bx	lr
          holl_speed--;
  2007a6:	4a03      	ldr	r2, [pc, #12]	; (2007b4 <Holl+0x54>)
  2007a8:	8813      	ldrh	r3, [r2, #0]
  2007aa:	3b01      	subs	r3, #1
  2007ac:	8013      	strh	r3, [r2, #0]
  2007ae:	e7e6      	b.n	20077e <Holl+0x1e>
  2007b0:	40020400 	.word	0x40020400
  2007b4:	20001150 	.word	0x20001150
	...

002007c0 <chMBPostI.isra.0>:

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  /* If the mailbox is in reset state then returns immediately.*/
  if (mbp->reset) {
  2007c0:	7d03      	ldrb	r3, [r0, #20]
  2007c2:	bb4b      	cbnz	r3, 200818 <chMBPostI.isra.0+0x58>
 */
static inline size_t chMBGetUsedCountI(const mailbox_t *mbp) {

  chDbgCheckClassI();

  return mbp->cnt;
  2007c4:	6903      	ldr	r3, [r0, #16]
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
  2007c6:	b470      	push	{r4, r5, r6}
  return (size_t)(mbp->top - mbp->buffer);
  2007c8:	e9d0 6200 	ldrd	r6, r2, [r0]
  2007cc:	1b94      	subs	r4, r2, r6
    return MSG_RESET;
  }

  /* Is there a free message slot in queue? if so then post.*/
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  2007ce:	ebb3 0fa4 	cmp.w	r3, r4, asr #2
  2007d2:	d01f      	beq.n	200814 <chMBPostI.isra.0+0x54>
    *mbp->wrptr++ = msg;
  2007d4:	6885      	ldr	r5, [r0, #8]
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
    }
    mbp->cnt++;
  2007d6:	3301      	adds	r3, #1
    *mbp->wrptr++ = msg;
  2007d8:	1d2c      	adds	r4, r5, #4
    if (mbp->wrptr >= mbp->top) {
  2007da:	42a2      	cmp	r2, r4
    *mbp->wrptr++ = msg;
  2007dc:	6084      	str	r4, [r0, #8]

    /* If there is a reader waiting then makes it ready.*/
    chThdDequeueNextI(&mbp->qr, MSG_OK);
  2007de:	f100 0220 	add.w	r2, r0, #32
    *mbp->wrptr++ = msg;
  2007e2:	6029      	str	r1, [r5, #0]
  return (bool)(qp->next != qp);
  2007e4:	6a01      	ldr	r1, [r0, #32]
      mbp->wrptr = mbp->buffer;
  2007e6:	bf98      	it	ls
  2007e8:	6086      	strls	r6, [r0, #8]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (ch_queue_notempty(&tqp->queue)) {
  2007ea:	428a      	cmp	r2, r1
    mbp->cnt++;
  2007ec:	6103      	str	r3, [r0, #16]
  2007ee:	d011      	beq.n	200814 <chMBPostI.isra.0+0x54>
  qp->next       = p->next;
  2007f0:	680b      	ldr	r3, [r1, #0]

  tp = (thread_t *)ch_queue_fifo_remove(&tqp->queue);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
  2007f2:	2400      	movs	r4, #0
  2007f4:	6203      	str	r3, [r0, #32]
  qp->next->prev = qp;
  2007f6:	605a      	str	r2, [r3, #4]
  } while (pqp->prio >= p->prio);
  2007f8:	6888      	ldr	r0, [r1, #8]
  2007fa:	4b08      	ldr	r3, [pc, #32]	; (20081c <chMBPostI.isra.0+0x5c>)
  2007fc:	624c      	str	r4, [r1, #36]	; 0x24
  tp->state = CH_STATE_READY;
  2007fe:	f881 4020 	strb.w	r4, [r1, #32]
    pqp = pqp->next;
  200802:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  200804:	689a      	ldr	r2, [r3, #8]
  200806:	4282      	cmp	r2, r0
  200808:	d2fb      	bcs.n	200802 <chMBPostI.isra.0+0x42>
  p->prev       = pqp->prev;
  20080a:	685a      	ldr	r2, [r3, #4]
  20080c:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  200810:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  200812:	6059      	str	r1, [r3, #4]
    return MSG_OK;
  }

  /* No space, immediate timeout.*/
  return MSG_TIMEOUT;
}
  200814:	bc70      	pop	{r4, r5, r6}
  200816:	4770      	bx	lr
  200818:	4770      	bx	lr
  20081a:	bf00      	nop
  20081c:	200009d0 	.word	0x200009d0

00200820 <cbgptfun3>:
// callback функция таймера 3
void cbgptfun3(GPTDriver *gptp)
{
    (void)gptp;
    int16_t speed_sensor=0;
    palToggleLine(LINE_LED1);
  200820:	4913      	ldr	r1, [pc, #76]	; (200870 <cbgptfun3+0x50>)
  return holl_speed;
}

void Clear_Holl_Sensor(void)
{
  holl_speed=0;
  200822:	2000      	movs	r0, #0
  return holl_speed;
  200824:	4a13      	ldr	r2, [pc, #76]	; (200874 <cbgptfun3+0x54>)
{
  200826:	b538      	push	{r3, r4, r5, lr}
    palToggleLine(LINE_LED1);
  200828:	694b      	ldr	r3, [r1, #20]
    speed_sensor=Get_Holl_Sensor()*5;
    Clear_Holl_Sensor();
    if(flag_start)
  20082a:	4c13      	ldr	r4, [pc, #76]	; (200878 <cbgptfun3+0x58>)
    palToggleLine(LINE_LED1);
  20082c:	f083 0301 	eor.w	r3, r3, #1
  200830:	614b      	str	r3, [r1, #20]
    speed_sensor=Get_Holl_Sensor()*5;
  200832:	8811      	ldrh	r1, [r2, #0]
    if(flag_start)
  200834:	7823      	ldrb	r3, [r4, #0]
    speed_sensor=Get_Holl_Sensor()*5;
  200836:	eb01 0181 	add.w	r1, r1, r1, lsl #2
  holl_speed=0;
  20083a:	8010      	strh	r0, [r2, #0]
  20083c:	b20c      	sxth	r4, r1
    if(flag_start)
  20083e:	b993      	cbnz	r3, 200866 <cbgptfun3+0x46>
      chMBPostI(&pid_mb, speed_sensor);
    angle++;
  200840:	4d0e      	ldr	r5, [pc, #56]	; (20087c <cbgptfun3+0x5c>)
  200842:	782b      	ldrb	r3, [r5, #0]
  200844:	3301      	adds	r3, #1
  200846:	b2db      	uxtb	r3, r3
    if(angle>1)
  200848:	2b01      	cmp	r3, #1
    angle++;
  20084a:	702b      	strb	r3, [r5, #0]
    if(angle>1)
  20084c:	d800      	bhi.n	200850 <cbgptfun3+0x30>
    {
      chMBPostI(&uart_mb, speed_sensor);
      chMBPostI(&holl_mb, speed_sensor);
      angle=0;
    }
}
  20084e:	bd38      	pop	{r3, r4, r5, pc}
      chMBPostI(&uart_mb, speed_sensor);
  200850:	480b      	ldr	r0, [pc, #44]	; (200880 <cbgptfun3+0x60>)
  200852:	4621      	mov	r1, r4
  200854:	f7ff ffb4 	bl	2007c0 <chMBPostI.isra.0>
      chMBPostI(&holl_mb, speed_sensor);
  200858:	4621      	mov	r1, r4
  20085a:	480a      	ldr	r0, [pc, #40]	; (200884 <cbgptfun3+0x64>)
  20085c:	f7ff ffb0 	bl	2007c0 <chMBPostI.isra.0>
      angle=0;
  200860:	2300      	movs	r3, #0
  200862:	702b      	strb	r3, [r5, #0]
}
  200864:	bd38      	pop	{r3, r4, r5, pc}
      chMBPostI(&pid_mb, speed_sensor);
  200866:	4621      	mov	r1, r4
  200868:	4807      	ldr	r0, [pc, #28]	; (200888 <cbgptfun3+0x68>)
  20086a:	f7ff ffa9 	bl	2007c0 <chMBPostI.isra.0>
  20086e:	e7e7      	b.n	200840 <cbgptfun3+0x20>
  200870:	40020400 	.word	0x40020400
  200874:	20001150 	.word	0x20001150
  200878:	20000f95 	.word	0x20000f95
  20087c:	20000968 	.word	0x20000968
  200880:	20001e78 	.word	0x20001e78
  200884:	20000f98 	.word	0x20000f98
  200888:	200019d0 	.word	0x200019d0
  20088c:	00000000 	.word	0x00000000

00200890 <cbgptfun4>:
// callback функция таймера 4
void cbgptfun4(GPTDriver *gptp)
{
    (void)gptp;
    uint8_t arg = 5;
    if(right_flag_ext)
  200890:	4a67      	ldr	r2, [pc, #412]	; (200a30 <cbgptfun4+0x1a0>)
    uint8_t arg = 5;
  200892:	2105      	movs	r1, #5
{
  200894:	b430      	push	{r4, r5}
  200896:	b082      	sub	sp, #8
    if(right_flag_ext)
  200898:	7813      	ldrb	r3, [r2, #0]
    uint8_t arg = 5;
  20089a:	f88d 1007 	strb.w	r1, [sp, #7]
    if(right_flag_ext)
  20089e:	b97b      	cbnz	r3, 2008c0 <cbgptfun4+0x30>
      palEnablePadEventI(RIGHT_GPIO_Port, RIGHT_Pin, PAL_EVENT_MODE_RISING_EDGE);
      palSetPadCallbackI(RIGHT_GPIO_Port, RIGHT_Pin, right_button, &arg);
      gptStopTimerI(timer4);
      right_flag_ext=0;
    }
    if(left_flag_ext)
  2008a0:	4a64      	ldr	r2, [pc, #400]	; (200a34 <cbgptfun4+0x1a4>)
  2008a2:	7813      	ldrb	r3, [r2, #0]
  2008a4:	2b00      	cmp	r3, #0
  2008a6:	d139      	bne.n	20091c <cbgptfun4+0x8c>
      palEnablePadEventI(LEFT_GPIO_Port, LEFT_Pin, PAL_EVENT_MODE_RISING_EDGE);
      palSetPadCallbackI(LEFT_GPIO_Port, LEFT_Pin, left_button, &arg);
      gptStopTimerI(timer4);
      left_flag_ext=0;
    }
    if(up_flag_ext)
  2008a8:	4a63      	ldr	r2, [pc, #396]	; (200a38 <cbgptfun4+0x1a8>)
  2008aa:	7813      	ldrb	r3, [r2, #0]
  2008ac:	2b00      	cmp	r3, #0
  2008ae:	d163      	bne.n	200978 <cbgptfun4+0xe8>
      palEnablePadEventI(UP_GPIO_Port, UP_Pin, PAL_EVENT_MODE_RISING_EDGE);
      palSetPadCallbackI(UP_GPIO_Port, UP_Pin, up_button, &arg);
      gptStopTimerI(timer4);
      up_flag_ext=0;
    }
    if(down_flag_ext)
  2008b0:	4a62      	ldr	r2, [pc, #392]	; (200a3c <cbgptfun4+0x1ac>)
  2008b2:	7813      	ldrb	r3, [r2, #0]
  2008b4:	2b00      	cmp	r3, #0
  2008b6:	f040 808e 	bne.w	2009d6 <cbgptfun4+0x146>
      palEnablePadEventI(DOWN_GPIO_Port, DOWN_Pin, PAL_EVENT_MODE_RISING_EDGE);
      palSetPadCallbackI(DOWN_GPIO_Port, DOWN_Pin, down_button, &arg);
      gptStopTimerI(timer4);
      down_flag_ext=0;
    }
}
  2008ba:	b002      	add	sp, #8
  2008bc:	bc30      	pop	{r4, r5}
  2008be:	4770      	bx	lr
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  2008c0:	485f      	ldr	r0, [pc, #380]	; (200a40 <cbgptfun4+0x1b0>)
    EXTI->RTSR1 |= padmask;
  2008c2:	4b60      	ldr	r3, [pc, #384]	; (200a44 <cbgptfun4+0x1b4>)
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  2008c4:	68c1      	ldr	r1, [r0, #12]
 */
void palSetPadCallbackI(ioportid_t port, iopadid_t pad,
                        palcallback_t cb, void *arg) {

  palevent_t *pep = pal_lld_get_pad_event(port, pad);
  pep->cb = cb;
  2008c6:	4c60      	ldr	r4, [pc, #384]	; (200a48 <cbgptfun4+0x1b8>)
  2008c8:	f021 01f0 	bic.w	r1, r1, #240	; 0xf0
  2008cc:	4d5f      	ldr	r5, [pc, #380]	; (200a4c <cbgptfun4+0x1bc>)
  2008ce:	f041 0150 	orr.w	r1, r1, #80	; 0x50
  2008d2:	62a5      	str	r5, [r4, #40]	; 0x28
  pep->arg = arg;
  2008d4:	f10d 0507 	add.w	r5, sp, #7
  2008d8:	60c1      	str	r1, [r0, #12]
    EXTI->RTSR1 |= padmask;
  2008da:	6899      	ldr	r1, [r3, #8]
  2008dc:	62e5      	str	r5, [r4, #44]	; 0x2c
  osalDbgCheck(gptp != NULL);
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
  2008de:	2402      	movs	r4, #2
  2008e0:	f041 0120 	orr.w	r1, r1, #32
  2008e4:	485a      	ldr	r0, [pc, #360]	; (200a50 <cbgptfun4+0x1c0>)
  2008e6:	6099      	str	r1, [r3, #8]
    EXTI->FTSR1 &= ~padmask;
  2008e8:	68d9      	ldr	r1, [r3, #12]
  2008ea:	f021 0120 	bic.w	r1, r1, #32
  2008ee:	60d9      	str	r1, [r3, #12]
  EXTI->IMR1 |= padmask;
  2008f0:	6819      	ldr	r1, [r3, #0]
  2008f2:	f041 0120 	orr.w	r1, r1, #32
  2008f6:	6019      	str	r1, [r3, #0]
  EXTI->EMR1 &= ~padmask;
  2008f8:	6859      	ldr	r1, [r3, #4]
  2008fa:	f021 0120 	bic.w	r1, r1, #32
  2008fe:	6059      	str	r1, [r3, #4]
  200900:	68c3      	ldr	r3, [r0, #12]
  200902:	7004      	strb	r4, [r0, #0]
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {

  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  200904:	2000      	movs	r0, #0
  200906:	6018      	str	r0, [r3, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  200908:	6118      	str	r0, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  20090a:	68d9      	ldr	r1, [r3, #12]
      right_flag_ext=0;
  20090c:	7010      	strb	r0, [r2, #0]
  20090e:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
    if(left_flag_ext)
  200912:	4a48      	ldr	r2, [pc, #288]	; (200a34 <cbgptfun4+0x1a4>)
  200914:	60d9      	str	r1, [r3, #12]
  200916:	7813      	ldrb	r3, [r2, #0]
  200918:	2b00      	cmp	r3, #0
  20091a:	d0c5      	beq.n	2008a8 <cbgptfun4+0x18>
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  20091c:	4d48      	ldr	r5, [pc, #288]	; (200a40 <cbgptfun4+0x1b0>)
    EXTI->RTSR1 |= padmask;
  20091e:	4b49      	ldr	r3, [pc, #292]	; (200a44 <cbgptfun4+0x1b4>)
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  200920:	68a9      	ldr	r1, [r5, #8]
  pep->cb = cb;
  200922:	4849      	ldr	r0, [pc, #292]	; (200a48 <cbgptfun4+0x1b8>)
  200924:	f021 010f 	bic.w	r1, r1, #15
  200928:	4c4a      	ldr	r4, [pc, #296]	; (200a54 <cbgptfun4+0x1c4>)
  20092a:	f041 0102 	orr.w	r1, r1, #2
  20092e:	60a9      	str	r1, [r5, #8]
  200930:	2502      	movs	r5, #2
    EXTI->RTSR1 |= padmask;
  200932:	6899      	ldr	r1, [r3, #8]
  200934:	f041 0101 	orr.w	r1, r1, #1
  200938:	6099      	str	r1, [r3, #8]
    EXTI->FTSR1 &= ~padmask;
  20093a:	68d9      	ldr	r1, [r3, #12]
  20093c:	f021 0101 	bic.w	r1, r1, #1
  200940:	60d9      	str	r1, [r3, #12]
  EXTI->IMR1 |= padmask;
  200942:	6819      	ldr	r1, [r3, #0]
  200944:	f041 0101 	orr.w	r1, r1, #1
  200948:	6019      	str	r1, [r3, #0]
  EXTI->EMR1 &= ~padmask;
  20094a:	6859      	ldr	r1, [r3, #4]
  20094c:	f021 0101 	bic.w	r1, r1, #1
  200950:	6059      	str	r1, [r3, #4]
  pep->arg = arg;
  200952:	f10d 0107 	add.w	r1, sp, #7
  200956:	4b3e      	ldr	r3, [pc, #248]	; (200a50 <cbgptfun4+0x1c0>)
  200958:	6041      	str	r1, [r0, #4]
  20095a:	701d      	strb	r5, [r3, #0]
  pep->cb = cb;
  20095c:	6004      	str	r4, [r0, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  20095e:	2000      	movs	r0, #0
  200960:	68db      	ldr	r3, [r3, #12]
      left_flag_ext=0;
  200962:	7010      	strb	r0, [r2, #0]
  200964:	6018      	str	r0, [r3, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  200966:	6118      	str	r0, [r3, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  200968:	68d9      	ldr	r1, [r3, #12]
    if(up_flag_ext)
  20096a:	4a33      	ldr	r2, [pc, #204]	; (200a38 <cbgptfun4+0x1a8>)
  20096c:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  200970:	60d9      	str	r1, [r3, #12]
  200972:	7813      	ldrb	r3, [r2, #0]
  200974:	2b00      	cmp	r3, #0
  200976:	d09b      	beq.n	2008b0 <cbgptfun4+0x20>
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  200978:	4831      	ldr	r0, [pc, #196]	; (200a40 <cbgptfun4+0x1b0>)
    EXTI->RTSR1 |= padmask;
  20097a:	4b32      	ldr	r3, [pc, #200]	; (200a44 <cbgptfun4+0x1b4>)
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  20097c:	6901      	ldr	r1, [r0, #16]
  20097e:	4c32      	ldr	r4, [pc, #200]	; (200a48 <cbgptfun4+0x1b8>)
  200980:	f421 6170 	bic.w	r1, r1, #3840	; 0xf00
  200984:	4d34      	ldr	r5, [pc, #208]	; (200a58 <cbgptfun4+0x1c8>)
  200986:	f441 61a0 	orr.w	r1, r1, #1280	; 0x500
  20098a:	6525      	str	r5, [r4, #80]	; 0x50
  pep->arg = arg;
  20098c:	f10d 0507 	add.w	r5, sp, #7
  200990:	6101      	str	r1, [r0, #16]
    EXTI->RTSR1 |= padmask;
  200992:	6899      	ldr	r1, [r3, #8]
  200994:	6565      	str	r5, [r4, #84]	; 0x54
  200996:	2402      	movs	r4, #2
  200998:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
  20099c:	482c      	ldr	r0, [pc, #176]	; (200a50 <cbgptfun4+0x1c0>)
  20099e:	6099      	str	r1, [r3, #8]
    EXTI->FTSR1 &= ~padmask;
  2009a0:	68d9      	ldr	r1, [r3, #12]
  2009a2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
  2009a6:	60d9      	str	r1, [r3, #12]
  EXTI->IMR1 |= padmask;
  2009a8:	6819      	ldr	r1, [r3, #0]
  2009aa:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
  2009ae:	6019      	str	r1, [r3, #0]
  EXTI->EMR1 &= ~padmask;
  2009b0:	6859      	ldr	r1, [r3, #4]
  2009b2:	f421 6180 	bic.w	r1, r1, #1024	; 0x400
  2009b6:	6059      	str	r1, [r3, #4]
  2009b8:	68c3      	ldr	r3, [r0, #12]
  2009ba:	7004      	strb	r4, [r0, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  2009bc:	2000      	movs	r0, #0
  2009be:	6018      	str	r0, [r3, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  2009c0:	6118      	str	r0, [r3, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  2009c2:	68d9      	ldr	r1, [r3, #12]
      up_flag_ext=0;
  2009c4:	7010      	strb	r0, [r2, #0]
  2009c6:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
    if(down_flag_ext)
  2009ca:	4a1c      	ldr	r2, [pc, #112]	; (200a3c <cbgptfun4+0x1ac>)
  2009cc:	60d9      	str	r1, [r3, #12]
  2009ce:	7813      	ldrb	r3, [r2, #0]
  2009d0:	2b00      	cmp	r3, #0
  2009d2:	f43f af72 	beq.w	2008ba <cbgptfun4+0x2a>
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  2009d6:	481a      	ldr	r0, [pc, #104]	; (200a40 <cbgptfun4+0x1b0>)
    EXTI->RTSR1 |= padmask;
  2009d8:	4b1a      	ldr	r3, [pc, #104]	; (200a44 <cbgptfun4+0x1b4>)
  SYSCFG->EXTICR[cridx] = (SYSCFG->EXTICR[cridx] & crmask) | (portidx << croff);
  2009da:	6881      	ldr	r1, [r0, #8]
  pep->cb = cb;
  2009dc:	4c1a      	ldr	r4, [pc, #104]	; (200a48 <cbgptfun4+0x1b8>)
  2009de:	f421 4170 	bic.w	r1, r1, #61440	; 0xf000
  2009e2:	4d1e      	ldr	r5, [pc, #120]	; (200a5c <cbgptfun4+0x1cc>)
  2009e4:	f441 41a0 	orr.w	r1, r1, #20480	; 0x5000
  2009e8:	61a5      	str	r5, [r4, #24]
  pep->arg = arg;
  2009ea:	f10d 0507 	add.w	r5, sp, #7
  2009ee:	6081      	str	r1, [r0, #8]
    EXTI->RTSR1 |= padmask;
  2009f0:	6899      	ldr	r1, [r3, #8]
  2009f2:	61e5      	str	r5, [r4, #28]
  2009f4:	2402      	movs	r4, #2
  2009f6:	f041 0108 	orr.w	r1, r1, #8
  2009fa:	4815      	ldr	r0, [pc, #84]	; (200a50 <cbgptfun4+0x1c0>)
  2009fc:	6099      	str	r1, [r3, #8]
    EXTI->FTSR1 &= ~padmask;
  2009fe:	68d9      	ldr	r1, [r3, #12]
  200a00:	f021 0108 	bic.w	r1, r1, #8
  200a04:	60d9      	str	r1, [r3, #12]
  EXTI->IMR1 |= padmask;
  200a06:	6819      	ldr	r1, [r3, #0]
  200a08:	f041 0108 	orr.w	r1, r1, #8
  200a0c:	6019      	str	r1, [r3, #0]
  EXTI->EMR1 &= ~padmask;
  200a0e:	6859      	ldr	r1, [r3, #4]
  200a10:	f021 0108 	bic.w	r1, r1, #8
  200a14:	6059      	str	r1, [r3, #4]
  200a16:	68c3      	ldr	r3, [r0, #12]
  200a18:	7004      	strb	r4, [r0, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  200a1a:	2000      	movs	r0, #0
  200a1c:	6018      	str	r0, [r3, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  200a1e:	6118      	str	r0, [r3, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  200a20:	68d9      	ldr	r1, [r3, #12]
      down_flag_ext=0;
  200a22:	7010      	strb	r0, [r2, #0]
  200a24:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  200a28:	60d9      	str	r1, [r3, #12]
}
  200a2a:	b002      	add	sp, #8
  200a2c:	bc30      	pop	{r4, r5}
  200a2e:	4770      	bx	lr
  200a30:	20001b88 	.word	0x20001b88
  200a34:	20001152 	.word	0x20001152
  200a38:	20002030 	.word	0x20002030
  200a3c:	20000f94 	.word	0x20000f94
  200a40:	40013800 	.word	0x40013800
  200a44:	40013c00 	.word	0x40013c00
  200a48:	200008e8 	.word	0x200008e8
  200a4c:	00200ca1 	.word	0x00200ca1
  200a50:	20000810 	.word	0x20000810
  200a54:	00200c01 	.word	0x00200c01
  200a58:	00200ac1 	.word	0x00200ac1
  200a5c:	00200b61 	.word	0x00200b61

00200a60 <_pal_lld_disablepadevent.constprop.0>:
 * @notapi
 */
void _pal_lld_disablepadevent(ioportid_t port, iopadid_t pad) {
  uint32_t padmask, rtsr1, ftsr1;

  rtsr1 = EXTI->RTSR1;
  200a60:	4b13      	ldr	r3, [pc, #76]	; (200ab0 <_pal_lld_disablepadevent.constprop.0+0x50>)
  ftsr1 = EXTI->FTSR1;

  /* Mask of the pad.*/
  padmask = 1U << (uint32_t)pad;
  200a62:	2201      	movs	r2, #1
void _pal_lld_disablepadevent(ioportid_t port, iopadid_t pad) {
  200a64:	b470      	push	{r4, r5, r6}
  rtsr1 = EXTI->RTSR1;
  200a66:	689c      	ldr	r4, [r3, #8]
  padmask = 1U << (uint32_t)pad;
  200a68:	4082      	lsls	r2, r0
  ftsr1 = EXTI->FTSR1;
  200a6a:	68d9      	ldr	r1, [r3, #12]

  /* If either RTRS1 or FTSR1 is enabled then the channel is in use.*/
  if (((rtsr1 | ftsr1) & padmask) != 0U) {
  200a6c:	ea44 0501 	orr.w	r5, r4, r1
  200a70:	4215      	tst	r5, r2
  200a72:	d01a      	beq.n	200aaa <_pal_lld_disablepadevent.constprop.0+0x4a>
    /* Port index is obtained assuming that GPIO ports are placed at regular
       0x400 intervals in memory space. So far this is true for all devices.*/
    portidx = (((uint32_t)port - (uint32_t)GPIOA) >> 10U) & 0xFU;

    /* Index and mask of the CR register to be used.*/
    cridx  = (uint32_t)pad >> 2U;
  200a74:	0885      	lsrs	r5, r0, #2
#if STM32_EXTI_HAS_CR == FALSE
    croff  = ((uint32_t)pad & 3U) * 4U;
    crport = (SYSCFG->EXTICR[cridx] >> croff) & 0xFU;
  200a76:	4e0f      	ldr	r6, [pc, #60]	; (200ab4 <_pal_lld_disablepadevent.constprop.0+0x54>)
#else
    /* Disabling channel.*/
    EXTI->IMR1  &= ~padmask;
    EXTI->EMR1  &= ~padmask;
    EXTI->RTSR1  = rtsr1 & ~padmask;
    EXTI->FTSR1  = ftsr1 & ~padmask;
  200a78:	ea21 0102 	bic.w	r1, r1, r2
    EXTI->RTSR1  = rtsr1 & ~padmask;
  200a7c:	ea24 0402 	bic.w	r4, r4, r2
    crport = (SYSCFG->EXTICR[cridx] >> croff) & 0xFU;
  200a80:	3502      	adds	r5, #2
  200a82:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
    EXTI->IMR1  &= ~padmask;
  200a86:	681d      	ldr	r5, [r3, #0]
#endif
#endif

#if PAL_USE_CALLBACKS || PAL_USE_WAIT
  /* Callback cleared and/or thread reset.*/
  _pal_clear_event(pad);
  200a88:	4e0b      	ldr	r6, [pc, #44]	; (200ab8 <_pal_lld_disablepadevent.constprop.0+0x58>)
    EXTI->IMR1  &= ~padmask;
  200a8a:	ea25 0502 	bic.w	r5, r5, r2
  200a8e:	601d      	str	r5, [r3, #0]
    EXTI->EMR1  &= ~padmask;
  200a90:	685d      	ldr	r5, [r3, #4]
  200a92:	ea25 0502 	bic.w	r5, r5, r2
  200a96:	605d      	str	r5, [r3, #4]
    EXTI->RTSR1  = rtsr1 & ~padmask;
  200a98:	609c      	str	r4, [r3, #8]
    EXTI->FTSR1  = ftsr1 & ~padmask;
  200a9a:	60d9      	str	r1, [r3, #12]
  _pal_clear_event(pad);
  200a9c:	2100      	movs	r1, #0
    EXTI->PR1    = padmask;
  200a9e:	615a      	str	r2, [r3, #20]
  _pal_clear_event(pad);
  200aa0:	eb06 03c0 	add.w	r3, r6, r0, lsl #3
  200aa4:	f846 1030 	str.w	r1, [r6, r0, lsl #3]
  200aa8:	6059      	str	r1, [r3, #4]
#endif
  }
}
  200aaa:	bc70      	pop	{r4, r5, r6}
  200aac:	4770      	bx	lr
  200aae:	bf00      	nop
  200ab0:	40013c00 	.word	0x40013c00
  200ab4:	40013800 	.word	0x40013800
  200ab8:	200008e8 	.word	0x200008e8
  200abc:	00000000 	.word	0x00000000

00200ac0 <up_button>:
    palDisablePadEventI(UP_GPIO_Port, UP_Pin);
  200ac0:	200a      	movs	r0, #10
{
  200ac2:	b570      	push	{r4, r5, r6, lr}
    palDisablePadEventI(UP_GPIO_Port, UP_Pin);
  200ac4:	f7ff ffcc 	bl	200a60 <_pal_lld_disablepadevent.constprop.0>
  if (mbp->reset) {
  200ac8:	4b20      	ldr	r3, [pc, #128]	; (200b4c <up_button+0x8c>)
  200aca:	7d1a      	ldrb	r2, [r3, #20]
  200acc:	bb32      	cbnz	r2, 200b1c <up_button+0x5c>
  return mbp->cnt;
  200ace:	691a      	ldr	r2, [r3, #16]
  return (size_t)(mbp->top - mbp->buffer);
  200ad0:	e9d3 5100 	ldrd	r5, r1, [r3]
  200ad4:	1b48      	subs	r0, r1, r5
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  200ad6:	ebb2 0fa0 	cmp.w	r2, r0, asr #2
  200ada:	d01f      	beq.n	200b1c <up_button+0x5c>
    *mbp->wrptr++ = msg;
  200adc:	689c      	ldr	r4, [r3, #8]
  200ade:	2601      	movs	r6, #1
    mbp->cnt++;
  200ae0:	3201      	adds	r2, #1
    *mbp->wrptr++ = msg;
  200ae2:	1d20      	adds	r0, r4, #4
    if (mbp->wrptr >= mbp->top) {
  200ae4:	4281      	cmp	r1, r0
    *mbp->wrptr++ = msg;
  200ae6:	6098      	str	r0, [r3, #8]
  return (bool)(qp->next != qp);
  200ae8:	6a19      	ldr	r1, [r3, #32]
  200aea:	4819      	ldr	r0, [pc, #100]	; (200b50 <up_button+0x90>)
  200aec:	6026      	str	r6, [r4, #0]
      mbp->wrptr = mbp->buffer;
  200aee:	bf98      	it	ls
  200af0:	609d      	strls	r5, [r3, #8]
  200af2:	4281      	cmp	r1, r0
    mbp->cnt++;
  200af4:	611a      	str	r2, [r3, #16]
  200af6:	d011      	beq.n	200b1c <up_button+0x5c>
  qp->next       = p->next;
  200af8:	680c      	ldr	r4, [r1, #0]
  200afa:	2200      	movs	r2, #0
  200afc:	621c      	str	r4, [r3, #32]
  qp->next->prev = qp;
  200afe:	6060      	str	r0, [r4, #4]
  } while (pqp->prio >= p->prio);
  200b00:	4b14      	ldr	r3, [pc, #80]	; (200b54 <up_button+0x94>)
  200b02:	6888      	ldr	r0, [r1, #8]
  200b04:	624a      	str	r2, [r1, #36]	; 0x24
  200b06:	f881 2020 	strb.w	r2, [r1, #32]
    pqp = pqp->next;
  200b0a:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  200b0c:	689a      	ldr	r2, [r3, #8]
  200b0e:	4282      	cmp	r2, r0
  200b10:	d2fb      	bcs.n	200b0a <up_button+0x4a>
  p->prev       = pqp->prev;
  200b12:	685a      	ldr	r2, [r3, #4]
  200b14:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  200b18:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  200b1a:	6059      	str	r1, [r3, #4]
  gptp->state = GPT_CONTINUOUS;
  200b1c:	4b0e      	ldr	r3, [pc, #56]	; (200b58 <up_button+0x98>)
    up_flag_ext=1;
  200b1e:	2101      	movs	r1, #1
  200b20:	4c0e      	ldr	r4, [pc, #56]	; (200b5c <up_button+0x9c>)
  200b22:	2503      	movs	r5, #3
  200b24:	6858      	ldr	r0, [r3, #4]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200b26:	2200      	movs	r2, #0
  200b28:	701d      	strb	r5, [r3, #0]
  if (NULL != gptp->config->callback)
  200b2a:	6840      	ldr	r0, [r0, #4]
  200b2c:	68db      	ldr	r3, [r3, #12]
  200b2e:	7021      	strb	r1, [r4, #0]
  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
  200b30:	f246 14a7 	movw	r4, #24999	; 0x61a7
  200b34:	62dc      	str	r4, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  200b36:	6159      	str	r1, [r3, #20]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200b38:	625a      	str	r2, [r3, #36]	; 0x24
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  200b3a:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
  200b3c:	b110      	cbz	r0, 200b44 <up_button+0x84>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
  200b3e:	68da      	ldr	r2, [r3, #12]
  200b40:	430a      	orrs	r2, r1
  200b42:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  200b44:	2285      	movs	r2, #133	; 0x85
  200b46:	601a      	str	r2, [r3, #0]
}
  200b48:	bd70      	pop	{r4, r5, r6, pc}
  200b4a:	bf00      	nop
  200b4c:	20001640 	.word	0x20001640
  200b50:	20001660 	.word	0x20001660
  200b54:	200009d0 	.word	0x200009d0
  200b58:	20000810 	.word	0x20000810
  200b5c:	20002030 	.word	0x20002030

00200b60 <down_button>:
    palDisablePadEventI(DOWN_GPIO_Port, DOWN_Pin);
  200b60:	2003      	movs	r0, #3
{
  200b62:	b570      	push	{r4, r5, r6, lr}
    palDisablePadEventI(DOWN_GPIO_Port, DOWN_Pin);
  200b64:	f7ff ff7c 	bl	200a60 <_pal_lld_disablepadevent.constprop.0>
  if (mbp->reset) {
  200b68:	4b20      	ldr	r3, [pc, #128]	; (200bec <down_button+0x8c>)
  200b6a:	7d1a      	ldrb	r2, [r3, #20]
  200b6c:	bb32      	cbnz	r2, 200bbc <down_button+0x5c>
  return mbp->cnt;
  200b6e:	691a      	ldr	r2, [r3, #16]
  return (size_t)(mbp->top - mbp->buffer);
  200b70:	e9d3 5100 	ldrd	r5, r1, [r3]
  200b74:	1b48      	subs	r0, r1, r5
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  200b76:	ebb2 0fa0 	cmp.w	r2, r0, asr #2
  200b7a:	d01f      	beq.n	200bbc <down_button+0x5c>
    *mbp->wrptr++ = msg;
  200b7c:	689c      	ldr	r4, [r3, #8]
  200b7e:	2602      	movs	r6, #2
    mbp->cnt++;
  200b80:	3201      	adds	r2, #1
    *mbp->wrptr++ = msg;
  200b82:	1d20      	adds	r0, r4, #4
    if (mbp->wrptr >= mbp->top) {
  200b84:	4281      	cmp	r1, r0
    *mbp->wrptr++ = msg;
  200b86:	6098      	str	r0, [r3, #8]
  return (bool)(qp->next != qp);
  200b88:	6a19      	ldr	r1, [r3, #32]
  200b8a:	4819      	ldr	r0, [pc, #100]	; (200bf0 <down_button+0x90>)
  200b8c:	6026      	str	r6, [r4, #0]
      mbp->wrptr = mbp->buffer;
  200b8e:	bf98      	it	ls
  200b90:	609d      	strls	r5, [r3, #8]
  200b92:	4281      	cmp	r1, r0
    mbp->cnt++;
  200b94:	611a      	str	r2, [r3, #16]
  200b96:	d011      	beq.n	200bbc <down_button+0x5c>
  qp->next       = p->next;
  200b98:	680c      	ldr	r4, [r1, #0]
  200b9a:	2200      	movs	r2, #0
  200b9c:	621c      	str	r4, [r3, #32]
  qp->next->prev = qp;
  200b9e:	6060      	str	r0, [r4, #4]
  } while (pqp->prio >= p->prio);
  200ba0:	4b14      	ldr	r3, [pc, #80]	; (200bf4 <down_button+0x94>)
  200ba2:	6888      	ldr	r0, [r1, #8]
  200ba4:	624a      	str	r2, [r1, #36]	; 0x24
  200ba6:	f881 2020 	strb.w	r2, [r1, #32]
    pqp = pqp->next;
  200baa:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  200bac:	689a      	ldr	r2, [r3, #8]
  200bae:	4282      	cmp	r2, r0
  200bb0:	d2fb      	bcs.n	200baa <down_button+0x4a>
  p->prev       = pqp->prev;
  200bb2:	685a      	ldr	r2, [r3, #4]
  200bb4:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  200bb8:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  200bba:	6059      	str	r1, [r3, #4]
  200bbc:	4b0e      	ldr	r3, [pc, #56]	; (200bf8 <down_button+0x98>)
    down_flag_ext=1;
  200bbe:	2101      	movs	r1, #1
  200bc0:	4c0e      	ldr	r4, [pc, #56]	; (200bfc <down_button+0x9c>)
  200bc2:	2503      	movs	r5, #3
  200bc4:	6858      	ldr	r0, [r3, #4]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200bc6:	2200      	movs	r2, #0
  200bc8:	701d      	strb	r5, [r3, #0]
  if (NULL != gptp->config->callback)
  200bca:	6840      	ldr	r0, [r0, #4]
  200bcc:	68db      	ldr	r3, [r3, #12]
  200bce:	7021      	strb	r1, [r4, #0]
  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
  200bd0:	f246 14a7 	movw	r4, #24999	; 0x61a7
  200bd4:	62dc      	str	r4, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  200bd6:	6159      	str	r1, [r3, #20]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200bd8:	625a      	str	r2, [r3, #36]	; 0x24
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  200bda:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
  200bdc:	b110      	cbz	r0, 200be4 <down_button+0x84>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
  200bde:	68da      	ldr	r2, [r3, #12]
  200be0:	430a      	orrs	r2, r1
  200be2:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  200be4:	2285      	movs	r2, #133	; 0x85
  200be6:	601a      	str	r2, [r3, #0]
}
  200be8:	bd70      	pop	{r4, r5, r6, pc}
  200bea:	bf00      	nop
  200bec:	20001640 	.word	0x20001640
  200bf0:	20001660 	.word	0x20001660
  200bf4:	200009d0 	.word	0x200009d0
  200bf8:	20000810 	.word	0x20000810
  200bfc:	20000f94 	.word	0x20000f94

00200c00 <left_button>:
    palDisablePadEventI(LEFT_GPIO_Port, LEFT_Pin);
  200c00:	2000      	movs	r0, #0
{
  200c02:	b570      	push	{r4, r5, r6, lr}
    palDisablePadEventI(LEFT_GPIO_Port, LEFT_Pin);
  200c04:	f7ff ff2c 	bl	200a60 <_pal_lld_disablepadevent.constprop.0>
  if (mbp->reset) {
  200c08:	4b20      	ldr	r3, [pc, #128]	; (200c8c <left_button+0x8c>)
  200c0a:	7d1a      	ldrb	r2, [r3, #20]
  200c0c:	bb32      	cbnz	r2, 200c5c <left_button+0x5c>
  return mbp->cnt;
  200c0e:	691a      	ldr	r2, [r3, #16]
  return (size_t)(mbp->top - mbp->buffer);
  200c10:	e9d3 5100 	ldrd	r5, r1, [r3]
  200c14:	1b48      	subs	r0, r1, r5
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  200c16:	ebb2 0fa0 	cmp.w	r2, r0, asr #2
  200c1a:	d01f      	beq.n	200c5c <left_button+0x5c>
    *mbp->wrptr++ = msg;
  200c1c:	689c      	ldr	r4, [r3, #8]
  200c1e:	2604      	movs	r6, #4
    mbp->cnt++;
  200c20:	3201      	adds	r2, #1
    *mbp->wrptr++ = msg;
  200c22:	19a0      	adds	r0, r4, r6
    if (mbp->wrptr >= mbp->top) {
  200c24:	4281      	cmp	r1, r0
    *mbp->wrptr++ = msg;
  200c26:	6098      	str	r0, [r3, #8]
  return (bool)(qp->next != qp);
  200c28:	6a19      	ldr	r1, [r3, #32]
  200c2a:	4819      	ldr	r0, [pc, #100]	; (200c90 <left_button+0x90>)
  200c2c:	6026      	str	r6, [r4, #0]
      mbp->wrptr = mbp->buffer;
  200c2e:	bf98      	it	ls
  200c30:	609d      	strls	r5, [r3, #8]
  200c32:	4281      	cmp	r1, r0
    mbp->cnt++;
  200c34:	611a      	str	r2, [r3, #16]
  200c36:	d011      	beq.n	200c5c <left_button+0x5c>
  qp->next       = p->next;
  200c38:	680c      	ldr	r4, [r1, #0]
  200c3a:	2200      	movs	r2, #0
  200c3c:	621c      	str	r4, [r3, #32]
  qp->next->prev = qp;
  200c3e:	6060      	str	r0, [r4, #4]
  } while (pqp->prio >= p->prio);
  200c40:	4b14      	ldr	r3, [pc, #80]	; (200c94 <left_button+0x94>)
  200c42:	6888      	ldr	r0, [r1, #8]
  200c44:	624a      	str	r2, [r1, #36]	; 0x24
  200c46:	f881 2020 	strb.w	r2, [r1, #32]
    pqp = pqp->next;
  200c4a:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  200c4c:	689a      	ldr	r2, [r3, #8]
  200c4e:	4282      	cmp	r2, r0
  200c50:	d2fb      	bcs.n	200c4a <left_button+0x4a>
  p->prev       = pqp->prev;
  200c52:	685a      	ldr	r2, [r3, #4]
  200c54:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  200c58:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  200c5a:	6059      	str	r1, [r3, #4]
  200c5c:	4b0e      	ldr	r3, [pc, #56]	; (200c98 <left_button+0x98>)
    left_flag_ext=1;
  200c5e:	2101      	movs	r1, #1
  200c60:	4c0e      	ldr	r4, [pc, #56]	; (200c9c <left_button+0x9c>)
  200c62:	2503      	movs	r5, #3
  200c64:	6858      	ldr	r0, [r3, #4]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200c66:	2200      	movs	r2, #0
  200c68:	701d      	strb	r5, [r3, #0]
  if (NULL != gptp->config->callback)
  200c6a:	6840      	ldr	r0, [r0, #4]
  200c6c:	68db      	ldr	r3, [r3, #12]
  200c6e:	7021      	strb	r1, [r4, #0]
  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
  200c70:	f246 14a7 	movw	r4, #24999	; 0x61a7
  200c74:	62dc      	str	r4, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  200c76:	6159      	str	r1, [r3, #20]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200c78:	625a      	str	r2, [r3, #36]	; 0x24
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  200c7a:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
  200c7c:	b110      	cbz	r0, 200c84 <left_button+0x84>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
  200c7e:	68da      	ldr	r2, [r3, #12]
  200c80:	430a      	orrs	r2, r1
  200c82:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  200c84:	2285      	movs	r2, #133	; 0x85
  200c86:	601a      	str	r2, [r3, #0]
}
  200c88:	bd70      	pop	{r4, r5, r6, pc}
  200c8a:	bf00      	nop
  200c8c:	20001640 	.word	0x20001640
  200c90:	20001660 	.word	0x20001660
  200c94:	200009d0 	.word	0x200009d0
  200c98:	20000810 	.word	0x20000810
  200c9c:	20001152 	.word	0x20001152

00200ca0 <right_button>:
    palDisablePadEventI(RIGHT_GPIO_Port, RIGHT_Pin);
  200ca0:	2005      	movs	r0, #5
{
  200ca2:	b570      	push	{r4, r5, r6, lr}
    palDisablePadEventI(RIGHT_GPIO_Port, RIGHT_Pin);
  200ca4:	f7ff fedc 	bl	200a60 <_pal_lld_disablepadevent.constprop.0>
  if (mbp->reset) {
  200ca8:	4b20      	ldr	r3, [pc, #128]	; (200d2c <right_button+0x8c>)
  200caa:	7d1a      	ldrb	r2, [r3, #20]
  200cac:	bb32      	cbnz	r2, 200cfc <right_button+0x5c>
  return mbp->cnt;
  200cae:	691a      	ldr	r2, [r3, #16]
  return (size_t)(mbp->top - mbp->buffer);
  200cb0:	e9d3 5100 	ldrd	r5, r1, [r3]
  200cb4:	1b48      	subs	r0, r1, r5
  if (chMBGetFreeCountI(mbp) > (size_t)0) {
  200cb6:	ebb2 0fa0 	cmp.w	r2, r0, asr #2
  200cba:	d01f      	beq.n	200cfc <right_button+0x5c>
    *mbp->wrptr++ = msg;
  200cbc:	689c      	ldr	r4, [r3, #8]
  200cbe:	2603      	movs	r6, #3
    mbp->cnt++;
  200cc0:	3201      	adds	r2, #1
    *mbp->wrptr++ = msg;
  200cc2:	1d20      	adds	r0, r4, #4
    if (mbp->wrptr >= mbp->top) {
  200cc4:	4281      	cmp	r1, r0
    *mbp->wrptr++ = msg;
  200cc6:	6098      	str	r0, [r3, #8]
  return (bool)(qp->next != qp);
  200cc8:	6a19      	ldr	r1, [r3, #32]
  200cca:	4819      	ldr	r0, [pc, #100]	; (200d30 <right_button+0x90>)
  200ccc:	6026      	str	r6, [r4, #0]
      mbp->wrptr = mbp->buffer;
  200cce:	bf98      	it	ls
  200cd0:	609d      	strls	r5, [r3, #8]
  200cd2:	4281      	cmp	r1, r0
    mbp->cnt++;
  200cd4:	611a      	str	r2, [r3, #16]
  200cd6:	d011      	beq.n	200cfc <right_button+0x5c>
  qp->next       = p->next;
  200cd8:	680c      	ldr	r4, [r1, #0]
  200cda:	2200      	movs	r2, #0
  200cdc:	621c      	str	r4, [r3, #32]
  qp->next->prev = qp;
  200cde:	6060      	str	r0, [r4, #4]
  } while (pqp->prio >= p->prio);
  200ce0:	4b14      	ldr	r3, [pc, #80]	; (200d34 <right_button+0x94>)
  200ce2:	6888      	ldr	r0, [r1, #8]
  200ce4:	624a      	str	r2, [r1, #36]	; 0x24
  200ce6:	f881 2020 	strb.w	r2, [r1, #32]
    pqp = pqp->next;
  200cea:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  200cec:	689a      	ldr	r2, [r3, #8]
  200cee:	4282      	cmp	r2, r0
  200cf0:	d2fb      	bcs.n	200cea <right_button+0x4a>
  p->prev       = pqp->prev;
  200cf2:	685a      	ldr	r2, [r3, #4]
  200cf4:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  200cf8:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  200cfa:	6059      	str	r1, [r3, #4]
  200cfc:	4b0e      	ldr	r3, [pc, #56]	; (200d38 <right_button+0x98>)
    right_flag_ext=1;
  200cfe:	2101      	movs	r1, #1
  200d00:	4c0e      	ldr	r4, [pc, #56]	; (200d3c <right_button+0x9c>)
  200d02:	2503      	movs	r5, #3
  200d04:	6858      	ldr	r0, [r3, #4]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200d06:	2200      	movs	r2, #0
  200d08:	701d      	strb	r5, [r3, #0]
  if (NULL != gptp->config->callback)
  200d0a:	6840      	ldr	r0, [r0, #4]
  200d0c:	68db      	ldr	r3, [r3, #12]
  200d0e:	7021      	strb	r1, [r4, #0]
  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
  200d10:	f246 14a7 	movw	r4, #24999	; 0x61a7
  200d14:	62dc      	str	r4, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  200d16:	6159      	str	r1, [r3, #20]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  200d18:	625a      	str	r2, [r3, #36]	; 0x24
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  200d1a:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
  200d1c:	b110      	cbz	r0, 200d24 <right_button+0x84>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
  200d1e:	68da      	ldr	r2, [r3, #12]
  200d20:	430a      	orrs	r2, r1
  200d22:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  200d24:	2285      	movs	r2, #133	; 0x85
  200d26:	601a      	str	r2, [r3, #0]
}
  200d28:	bd70      	pop	{r4, r5, r6, pc}
  200d2a:	bf00      	nop
  200d2c:	20001640 	.word	0x20001640
  200d30:	20001660 	.word	0x20001660
  200d34:	200009d0 	.word	0x200009d0
  200d38:	20000810 	.word	0x20000810
  200d3c:	20001b88 	.word	0x20001b88

00200d40 <pwm_lld_serve_interrupt.constprop.0>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  200d40:	b570      	push	{r4, r5, r6, lr}
  uint32_t sr;

  sr  = pwmp->tim->SR;
  200d42:	4d17      	ldr	r5, [pc, #92]	; (200da0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
  200d44:	69ab      	ldr	r3, [r5, #24]
  200d46:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  200d48:	68da      	ldr	r2, [r3, #12]
  200d4a:	4014      	ands	r4, r2
  200d4c:	b2e2      	uxtb	r2, r4
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
  200d4e:	07a6      	lsls	r6, r4, #30
  pwmp->tim->SR = ~sr;
  200d50:	ea6f 0202 	mvn.w	r2, r2
  200d54:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
  200d56:	d504      	bpl.n	200d62 <pwm_lld_serve_interrupt.constprop.0+0x22>
      (pwmp->config->channels[0].callback != NULL))
  200d58:	686b      	ldr	r3, [r5, #4]
  200d5a:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
  200d5c:	b10b      	cbz	r3, 200d62 <pwm_lld_serve_interrupt.constprop.0+0x22>
    pwmp->config->channels[0].callback(pwmp);
  200d5e:	4628      	mov	r0, r5
  200d60:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
  200d62:	0760      	lsls	r0, r4, #29
  200d64:	d504      	bpl.n	200d70 <pwm_lld_serve_interrupt.constprop.0+0x30>
      (pwmp->config->channels[1].callback != NULL))
  200d66:	686b      	ldr	r3, [r5, #4]
  200d68:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
  200d6a:	b10b      	cbz	r3, 200d70 <pwm_lld_serve_interrupt.constprop.0+0x30>
    pwmp->config->channels[1].callback(pwmp);
  200d6c:	480c      	ldr	r0, [pc, #48]	; (200da0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
  200d6e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
  200d70:	0721      	lsls	r1, r4, #28
  200d72:	d504      	bpl.n	200d7e <pwm_lld_serve_interrupt.constprop.0+0x3e>
      (pwmp->config->channels[2].callback != NULL))
  200d74:	686b      	ldr	r3, [r5, #4]
  200d76:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
  200d78:	b10b      	cbz	r3, 200d7e <pwm_lld_serve_interrupt.constprop.0+0x3e>
    pwmp->config->channels[2].callback(pwmp);
  200d7a:	4809      	ldr	r0, [pc, #36]	; (200da0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
  200d7c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
  200d7e:	06e2      	lsls	r2, r4, #27
  200d80:	d504      	bpl.n	200d8c <pwm_lld_serve_interrupt.constprop.0+0x4c>
      (pwmp->config->channels[3].callback != NULL))
  200d82:	686b      	ldr	r3, [r5, #4]
  200d84:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
  200d86:	b10b      	cbz	r3, 200d8c <pwm_lld_serve_interrupt.constprop.0+0x4c>
    pwmp->config->channels[3].callback(pwmp);
  200d88:	4805      	ldr	r0, [pc, #20]	; (200da0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
  200d8a:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
  200d8c:	07e3      	lsls	r3, r4, #31
  200d8e:	d506      	bpl.n	200d9e <pwm_lld_serve_interrupt.constprop.0+0x5e>
  200d90:	686b      	ldr	r3, [r5, #4]
  200d92:	689b      	ldr	r3, [r3, #8]
  200d94:	b11b      	cbz	r3, 200d9e <pwm_lld_serve_interrupt.constprop.0+0x5e>
    pwmp->config->callback(pwmp);
  200d96:	4802      	ldr	r0, [pc, #8]	; (200da0 <pwm_lld_serve_interrupt.constprop.0+0x60>)
}
  200d98:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    pwmp->config->callback(pwmp);
  200d9c:	4718      	bx	r3
}
  200d9e:	bd70      	pop	{r4, r5, r6, pc}
  200da0:	20000828 	.word	0x20000828
	...

00200db0 <chEvtBroadcastFlagsI.constprop.0>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
  200db0:	b4f0      	push	{r4, r5, r6, r7}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  200db2:	4d1b      	ldr	r5, [pc, #108]	; (200e20 <chEvtBroadcastFlagsI.constprop.0+0x70>)
  200db4:	f855 3f04 	ldr.w	r3, [r5, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
  200db8:	42ab      	cmp	r3, r5
  200dba:	d02a      	beq.n	200e12 <chEvtBroadcastFlagsI.constprop.0+0x62>
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
  200dbc:	2600      	movs	r6, #0
  200dbe:	e004      	b.n	200dca <chEvtBroadcastFlagsI.constprop.0+0x1a>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  200dc0:	2c0b      	cmp	r4, #11
  200dc2:	d028      	beq.n	200e16 <chEvtBroadcastFlagsI.constprop.0+0x66>
    elp = elp->next;
  200dc4:	681b      	ldr	r3, [r3, #0]
  while (elp != (event_listener_t *)esp) {
  200dc6:	42ab      	cmp	r3, r5
  200dc8:	d023      	beq.n	200e12 <chEvtBroadcastFlagsI.constprop.0+0x62>
    elp->flags |= flags;
  200dca:	68da      	ldr	r2, [r3, #12]
  200dcc:	4302      	orrs	r2, r0
  200dce:	60da      	str	r2, [r3, #12]
    if ((flags == (eventflags_t)0) ||
  200dd0:	b110      	cbz	r0, 200dd8 <chEvtBroadcastFlagsI.constprop.0+0x28>
        ((flags & elp->wflags) != (eventflags_t)0)) {
  200dd2:	691a      	ldr	r2, [r3, #16]
    if ((flags == (eventflags_t)0) ||
  200dd4:	4210      	tst	r0, r2
  200dd6:	d0f5      	beq.n	200dc4 <chEvtBroadcastFlagsI.constprop.0+0x14>
  tp->epending |= events;
  200dd8:	e9d3 1201 	ldrd	r1, r2, [r3, #4]
  200ddc:	6b4f      	ldr	r7, [r1, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  200dde:	f891 4020 	ldrb.w	r4, [r1, #32]
  tp->epending |= events;
  200de2:	433a      	orrs	r2, r7
  if (((tp->state == CH_STATE_WTOREVT) &&
  200de4:	2c0a      	cmp	r4, #10
  tp->epending |= events;
  200de6:	634a      	str	r2, [r1, #52]	; 0x34
  if (((tp->state == CH_STATE_WTOREVT) &&
  200de8:	d1ea      	bne.n	200dc0 <chEvtBroadcastFlagsI.constprop.0+0x10>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
  200dea:	6a4c      	ldr	r4, [r1, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
  200dec:	4222      	tst	r2, r4
  200dee:	d0e9      	beq.n	200dc4 <chEvtBroadcastFlagsI.constprop.0+0x14>
  } while (pqp->prio >= p->prio);
  200df0:	688c      	ldr	r4, [r1, #8]
  200df2:	4a0c      	ldr	r2, [pc, #48]	; (200e24 <chEvtBroadcastFlagsI.constprop.0+0x74>)
    tp->u.rdymsg = MSG_OK;
  200df4:	624e      	str	r6, [r1, #36]	; 0x24
  200df6:	f881 6020 	strb.w	r6, [r1, #32]
    pqp = pqp->next;
  200dfa:	6812      	ldr	r2, [r2, #0]
  } while (pqp->prio >= p->prio);
  200dfc:	6897      	ldr	r7, [r2, #8]
  200dfe:	42a7      	cmp	r7, r4
  200e00:	d2fb      	bcs.n	200dfa <chEvtBroadcastFlagsI.constprop.0+0x4a>
    elp = elp->next;
  200e02:	681b      	ldr	r3, [r3, #0]
  p->prev       = pqp->prev;
  200e04:	6854      	ldr	r4, [r2, #4]
  while (elp != (event_listener_t *)esp) {
  200e06:	42ab      	cmp	r3, r5
  200e08:	e9c1 2400 	strd	r2, r4, [r1]
  p->prev->next = p;
  200e0c:	6021      	str	r1, [r4, #0]
  pqp->prev     = p;
  200e0e:	6051      	str	r1, [r2, #4]
  200e10:	d1db      	bne.n	200dca <chEvtBroadcastFlagsI.constprop.0+0x1a>
}
  200e12:	bcf0      	pop	{r4, r5, r6, r7}
  200e14:	4770      	bx	lr
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
  200e16:	6a4c      	ldr	r4, [r1, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
  200e18:	ea34 0202 	bics.w	r2, r4, r2
  200e1c:	d1d2      	bne.n	200dc4 <chEvtBroadcastFlagsI.constprop.0+0x14>
  200e1e:	e7e7      	b.n	200df0 <chEvtBroadcastFlagsI.constprop.0+0x40>
  200e20:	20000858 	.word	0x20000858
  200e24:	200009d0 	.word	0x200009d0
	...

00200e30 <chSchGoSleepTimeoutS>:
  if (TIME_INFINITE != timeout) {
  200e30:	1c4b      	adds	r3, r1, #1
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
  200e32:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    chVTDoSetI(&vt, timeout, wakeup, currp);
  200e36:	4d60      	ldr	r5, [pc, #384]	; (200fb8 <chSchGoSleepTimeoutS+0x188>)
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
  200e38:	b087      	sub	sp, #28
  if (TIME_INFINITE != timeout) {
  200e3a:	d054      	beq.n	200ee6 <chSchGoSleepTimeoutS+0xb6>
    chVTDoSetI(&vt, timeout, wakeup, currp);
  200e3c:	2902      	cmp	r1, #2

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
  200e3e:	4b5f      	ldr	r3, [pc, #380]	; (200fbc <chSchGoSleepTimeoutS+0x18c>)
  return (bool)(dlhp == dlhp->next);
  200e40:	462f      	mov	r7, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
  200e42:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
  200e46:	bf38      	it	cc
  200e48:	2102      	movcc	r1, #2
  200e4a:	f8d6 8024 	ldr.w	r8, [r6, #36]	; 0x24
  200e4e:	460c      	mov	r4, r1
  200e50:	69a9      	ldr	r1, [r5, #24]
  vtp->par = par;
  200e52:	e9cd 3104 	strd	r3, r1, [sp, #16]
  return (bool)(dlhp == dlhp->next);
  200e56:	f857 3f1c 	ldr.w	r3, [r7, #28]!
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (is_vtlist_empty(&vtlp->dlist)) {
  200e5a:	42bb      	cmp	r3, r7
  200e5c:	f000 8092 	beq.w	200f84 <chSchGoSleepTimeoutS+0x154>
      return;
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    deltanow = chTimeDiffX(vtlp->lasttime, now);
  200e60:	f8d5 e028 	ldr.w	lr, [r5, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
  200e64:	eba8 0c0e 	sub.w	ip, r8, lr
  200e68:	eb14 040c 	adds.w	r4, r4, ip
    delta    = deltanow + delay;
  200e6c:	4622      	mov	r2, r4

    /* Scenario where a very large delay exceeded the numeric range, it
       requires a special handling, the compression procedure.*/
    if (delta < deltanow) {
  200e6e:	d24d      	bcs.n	200f0c <chSchGoSleepTimeoutS+0xdc>
      vt_list_compress(vtlp, deltanow);
      delta -= deltanow;
    }
    else if (delta < vtlp->dlist.next->delta) {
  200e70:	689c      	ldr	r4, [r3, #8]
  200e72:	42a2      	cmp	r2, r4
  200e74:	f0c0 8082 	bcc.w	200f7c <chSchGoSleepTimeoutS+0x14c>
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  dlp = vtlp->dlist.next;
  while (dlp->delta < delta) {
  200e78:	42a2      	cmp	r2, r4
  200e7a:	d904      	bls.n	200e86 <chSchGoSleepTimeoutS+0x56>
    /* Debug assert if the timer is already in the list.*/
    chDbgAssert(dlp != &vtp->dlist, "timer already armed");

    delta -= dlp->delta;
    dlp = dlp->next;
  200e7c:	681b      	ldr	r3, [r3, #0]
    delta -= dlp->delta;
  200e7e:	1b12      	subs	r2, r2, r4
  while (dlp->delta < delta) {
  200e80:	689c      	ldr	r4, [r3, #8]
  200e82:	4294      	cmp	r4, r2
  200e84:	d3fa      	bcc.n	200e7c <chSchGoSleepTimeoutS+0x4c>
  }

  /* The timer is inserted in the delta list.*/
  vtp->dlist.next       = dlp;
  vtp->dlist.prev       = vtp->dlist.next->prev;
  200e86:	685c      	ldr	r4, [r3, #4]
  vtp->dlist.prev->next = &vtp->dlist;
  200e88:	f10d 0804 	add.w	r8, sp, #4
  vtp->dlist.next       = dlp;
  200e8c:	9301      	str	r3, [sp, #4]
  vtp->dlist.prev       = vtp->dlist.next->prev;
  200e8e:	9402      	str	r4, [sp, #8]
  vtp->dlist.prev->next = &vtp->dlist;
  200e90:	f8c4 8000 	str.w	r8, [r4]
  dlp->prev             = &vtp->dlist;
  200e94:	f8c3 8004 	str.w	r8, [r3, #4]
  vtp->dlist.delta      = delta;
  200e98:	9203      	str	r2, [sp, #12]

  /* Calculate new delta for the following entry.*/
  dlp->delta -= delta;
  200e9a:	689c      	ldr	r4, [r3, #8]
  200e9c:	1aa2      	subs	r2, r4, r2
  200e9e:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/
  vtlp->dlist.delta = (sysinterval_t)-1;
  200ea0:	f04f 33ff 	mov.w	r3, #4294967295
  200ea4:	626b      	str	r3, [r5, #36]	; 0x24
  otp->state = newstate;
  200ea6:	f881 0020 	strb.w	r0, [r1, #32]
  currp->state = CH_STATE_CURRENT;
  200eaa:	2201      	movs	r2, #1
  ch_priority_queue_t *p = pqp->next;
  200eac:	6828      	ldr	r0, [r5, #0]
  pqp->next       = p->next;
  200eae:	6803      	ldr	r3, [r0, #0]
  pqp->next->prev = pqp;
  200eb0:	605d      	str	r5, [r3, #4]
  200eb2:	f880 2020 	strb.w	r2, [r0, #32]
  pqp->next       = p->next;
  200eb6:	602b      	str	r3, [r5, #0]
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  200eb8:	61a8      	str	r0, [r5, #24]
  chSysSwitch(currp, otp);
  200eba:	f7ff fa11 	bl	2002e0 <_port_switch>
    if (chVTIsArmedI(&vt)) {
  200ebe:	9b04      	ldr	r3, [sp, #16]
  200ec0:	b163      	cbz	r3, 200edc <chSchGoSleepTimeoutS+0xac>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!is_first_timer(&vtlp->dlist, &vtp->dlist)) {
  200ec2:	69eb      	ldr	r3, [r5, #28]
  200ec4:	4543      	cmp	r3, r8
  200ec6:	d03d      	beq.n	200f44 <chSchGoSleepTimeoutS+0x114>
    /* Removing the element from the delta list.*/
    vtp->dlist.prev->next = vtp->dlist.next;
  200ec8:	e9dd 3201 	ldrd	r3, r2, [sp, #4]
    vtp->dlist.next->prev = vtp->dlist.prev;
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (is_timer(&vtlp->dlist, vtp->dlist.next))
  200ecc:	42bb      	cmp	r3, r7
    vtp->dlist.prev->next = vtp->dlist.next;
  200ece:	6013      	str	r3, [r2, #0]
    vtp->dlist.next->prev = vtp->dlist.prev;
  200ed0:	605a      	str	r2, [r3, #4]
    if (is_timer(&vtlp->dlist, vtp->dlist.next))
  200ed2:	d003      	beq.n	200edc <chSchGoSleepTimeoutS+0xac>
      vtp->dlist.next->delta += vtp->dlist.delta;
  200ed4:	689a      	ldr	r2, [r3, #8]
  200ed6:	9903      	ldr	r1, [sp, #12]
  200ed8:	440a      	add	r2, r1
  200eda:	609a      	str	r2, [r3, #8]
  return currp->u.rdymsg;
  200edc:	69ab      	ldr	r3, [r5, #24]
  200ede:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
  200ee0:	b007      	add	sp, #28
  200ee2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  ch_priority_queue_t *p = pqp->next;
  200ee6:	682b      	ldr	r3, [r5, #0]
  currp->state = CH_STATE_CURRENT;
  200ee8:	2401      	movs	r4, #1
  thread_t *otp = currp;
  200eea:	69a9      	ldr	r1, [r5, #24]
  otp->state = newstate;
  200eec:	f881 0020 	strb.w	r0, [r1, #32]
  chSysSwitch(currp, otp);
  200ef0:	4618      	mov	r0, r3
  pqp->next       = p->next;
  200ef2:	681a      	ldr	r2, [r3, #0]
  pqp->next->prev = pqp;
  200ef4:	6055      	str	r5, [r2, #4]
  currp->state = CH_STATE_CURRENT;
  200ef6:	f883 4020 	strb.w	r4, [r3, #32]
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  200efa:	61ab      	str	r3, [r5, #24]
  pqp->next       = p->next;
  200efc:	602a      	str	r2, [r5, #0]
  chSysSwitch(currp, otp);
  200efe:	f7ff f9ef 	bl	2002e0 <_port_switch>
  return currp->u.rdymsg;
  200f02:	69ab      	ldr	r3, [r5, #24]
  200f04:	6a58      	ldr	r0, [r3, #36]	; 0x24
}
  200f06:	b007      	add	sp, #28
  200f08:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
  while (dlp->delta < deltanow) {
  200f0c:	689e      	ldr	r6, [r3, #8]
  200f0e:	45b4      	cmp	ip, r6
  200f10:	d94d      	bls.n	200fae <chSchGoSleepTimeoutS+0x17e>
  200f12:	461a      	mov	r2, r3
    dlp->delta = (sysinterval_t)0;
  200f14:	f04f 0900 	mov.w	r9, #0
  200f18:	f8c2 9008 	str.w	r9, [r2, #8]
    deltanow  -= dlp->delta;
  200f1c:	ebac 0c06 	sub.w	ip, ip, r6
    dlp        = dlp->next;
  200f20:	6812      	ldr	r2, [r2, #0]
  while (dlp->delta < deltanow) {
  200f22:	6896      	ldr	r6, [r2, #8]
  200f24:	4566      	cmp	r6, ip
  200f26:	d3f7      	bcc.n	200f18 <chSchGoSleepTimeoutS+0xe8>
  vtlp->lasttime = vtlp->lasttime + deltanow;
  200f28:	eb0e 090c 	add.w	r9, lr, ip
  if (is_timer(&vtlp->dlist, dlp)) {
  200f2c:	42ba      	cmp	r2, r7
  vtlp->lasttime = vtlp->lasttime + deltanow;
  200f2e:	f8c5 9028 	str.w	r9, [r5, #40]	; 0x28
  if (is_timer(&vtlp->dlist, dlp)) {
  200f32:	d002      	beq.n	200f3a <chSchGoSleepTimeoutS+0x10a>
    dlp->delta -= deltanow;
  200f34:	eba6 060c 	sub.w	r6, r6, ip
  200f38:	6096      	str	r6, [r2, #8]
      delta -= deltanow;
  200f3a:	ebae 0208 	sub.w	r2, lr, r8
  200f3e:	4422      	add	r2, r4
  while (dlp->delta < delta) {
  200f40:	689c      	ldr	r4, [r3, #8]
  200f42:	e799      	b.n	200e78 <chSchGoSleepTimeoutS+0x48>

    return;
  }

  /* Removing the first timer from the list.*/
  vtlp->dlist.next = vtp->dlist.next;
  200f44:	9b01      	ldr	r3, [sp, #4]
  vtlp->dlist.next->prev = &vtlp->dlist;
  vtp->func = NULL;
  200f46:	2200      	movs	r2, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (is_vtlist_empty(&vtlp->dlist)) {
  200f48:	42bb      	cmp	r3, r7
  vtlp->dlist.next = vtp->dlist.next;
  200f4a:	61eb      	str	r3, [r5, #28]
  vtlp->dlist.next->prev = &vtlp->dlist;
  200f4c:	605f      	str	r7, [r3, #4]
  vtp->func = NULL;
  200f4e:	9204      	str	r2, [sp, #16]
  if (is_vtlist_empty(&vtlp->dlist)) {
  200f50:	d029      	beq.n	200fa6 <chSchGoSleepTimeoutS+0x176>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
  200f52:	689a      	ldr	r2, [r3, #8]
  200f54:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
  200f58:	9c03      	ldr	r4, [sp, #12]
/*  if (vtlp->dlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(vtlp->lasttime, chVTGetSystemTimeX());
  200f5a:	6aa9      	ldr	r1, [r5, #40]	; 0x28
  vtlp->dlist.next->delta += vtp->dlist.delta;
  200f5c:	4422      	add	r2, r4
  200f5e:	609a      	str	r2, [r3, #8]
  200f60:	6a43      	ldr	r3, [r0, #36]	; 0x24
  200f62:	1a58      	subs	r0, r3, r1

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
  200f64:	4282      	cmp	r2, r0
  200f66:	d9b9      	bls.n	200edc <chSchGoSleepTimeoutS+0xac>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
  200f68:	1acb      	subs	r3, r1, r3
  200f6a:	4413      	add	r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
  200f6c:	2b01      	cmp	r3, #1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
  200f6e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
  200f72:	bf98      	it	ls
  200f74:	1c82      	addls	r2, r0, #2
  return systime + (systime_t)interval;
  200f76:	440a      	add	r2, r1
  200f78:	635a      	str	r2, [r3, #52]	; 0x34
void stSetAlarm(systime_t abstime) {

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
}
  200f7a:	e7af      	b.n	200edc <chSchGoSleepTimeoutS+0xac>
  200f7c:	4496      	add	lr, r2
  200f7e:	f8c6 e034 	str.w	lr, [r6, #52]	; 0x34
  200f82:	e779      	b.n	200e78 <chSchGoSleepTimeoutS+0x48>
      vtlp->lasttime = now;
  200f84:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
  200f88:	eb04 0308 	add.w	r3, r4, r8
      vtlp->dlist.next = &vtp->dlist;
  200f8c:	f10d 0804 	add.w	r8, sp, #4
      vtp->dlist.delta = delay;
  200f90:	9403      	str	r4, [sp, #12]
      vtp->dlist.prev = &vtlp->dlist;
  200f92:	e9cd 7701 	strd	r7, r7, [sp, #4]
      vtlp->dlist.prev = &vtp->dlist;
  200f96:	e9c5 8807 	strd	r8, r8, [r5, #28]
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
  200f9a:	6373      	str	r3, [r6, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
  200f9c:	2300      	movs	r3, #0
  200f9e:	6133      	str	r3, [r6, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
  200fa0:	2302      	movs	r3, #2
  200fa2:	60f3      	str	r3, [r6, #12]
}
  200fa4:	e77f      	b.n	200ea6 <chSchGoSleepTimeoutS+0x76>
  STM32_ST_TIM->DIER = 0U;
  200fa6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  200faa:	60da      	str	r2, [r3, #12]
    return;
  200fac:	e796      	b.n	200edc <chSchGoSleepTimeoutS+0xac>
  vtlp->lasttime = vtlp->lasttime + deltanow;
  200fae:	461a      	mov	r2, r3
  200fb0:	f8c5 8028 	str.w	r8, [r5, #40]	; 0x28
  200fb4:	e7be      	b.n	200f34 <chSchGoSleepTimeoutS+0x104>
  200fb6:	bf00      	nop
  200fb8:	200009d0 	.word	0x200009d0
  200fbc:	00200631 	.word	0x00200631

00200fc0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, sysinterval_t timeout) {
  200fc0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  200fc4:	b083      	sub	sp, #12
  200fc6:	4699      	mov	r9, r3
  qnotify_t nfy = iqp->q_notify;
  200fc8:	69c7      	ldr	r7, [r0, #28]
  200fca:	f04f 0a20 	mov.w	sl, #32
                     size_t n, sysinterval_t timeout) {
  200fce:	9201      	str	r2, [sp, #4]
  200fd0:	f38a 8811 	msr	BASEPRI, sl

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
  200fd4:	b392      	cbz	r2, 20103c <iqReadTimeout+0x7c>
  200fd6:	4604      	mov	r4, r0
  200fd8:	460e      	mov	r6, r1
  200fda:	f8dd b004 	ldr.w	fp, [sp, #4]
  if (n > iqGetFullI(iqp)) {
  200fde:	68a2      	ldr	r2, [r4, #8]
  200fe0:	455a      	cmp	r2, fp
  200fe2:	d232      	bcs.n	20104a <iqReadTimeout+0x8a>
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
  200fe4:	69a1      	ldr	r1, [r4, #24]
  200fe6:	6922      	ldr	r2, [r4, #16]
    n = iqGetFullI(iqp);
  200fe8:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
  200fea:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
  200fee:	45a8      	cmp	r8, r5
  200ff0:	d832      	bhi.n	201058 <iqReadTimeout+0x98>
  else if (n > s1) {
  200ff2:	d256      	bcs.n	2010a2 <iqReadTimeout+0xe2>
    s2 = n - s1;
  200ff4:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
  200ff8:	4642      	mov	r2, r8
  200ffa:	4630      	mov	r0, r6
    s2 = n - s1;
  200ffc:	9300      	str	r3, [sp, #0]
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
  200ffe:	f004 f917 	bl	205230 <memcpy>
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
  201002:	eb06 0008 	add.w	r0, r6, r8
  201006:	f8dd 8000 	ldr.w	r8, [sp]
  20100a:	68e1      	ldr	r1, [r4, #12]
  20100c:	4642      	mov	r2, r8
  20100e:	f004 f90f 	bl	205230 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
  201012:	68e2      	ldr	r2, [r4, #12]
  201014:	4442      	add	r2, r8
  201016:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
  201018:	68a2      	ldr	r2, [r4, #8]
  20101a:	1b52      	subs	r2, r2, r5
  20101c:	60a2      	str	r2, [r4, #8]
    size_t done;

    done = iq_read(iqp, bp, n);
    if (done == (size_t)0) {
  20101e:	b33d      	cbz	r5, 201070 <iqReadTimeout+0xb0>
      }
    }
    else {
      /* Inform the low side that the queue has at least one empty slot
         available.*/
      if (nfy != NULL) {
  201020:	b10f      	cbz	r7, 201026 <iqReadTimeout+0x66>
        nfy(iqp);
  201022:	4620      	mov	r0, r4
  201024:	47b8      	blx	r7
  201026:	2300      	movs	r3, #0
  201028:	f383 8811 	msr	BASEPRI, r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
  20102c:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
  201030:	442e      	add	r6, r5
  201032:	f38a 8811 	msr	BASEPRI, sl
  while (n > 0U) {
  201036:	f1bb 0f00 	cmp.w	fp, #0
  20103a:	d1d0      	bne.n	200fde <iqReadTimeout+0x1e>
  20103c:	9801      	ldr	r0, [sp, #4]
  20103e:	2300      	movs	r3, #0
  201040:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
  201044:	b003      	add	sp, #12
  201046:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
  20104a:	69a1      	ldr	r1, [r4, #24]
  20104c:	465d      	mov	r5, fp
  20104e:	6922      	ldr	r2, [r4, #16]
  201050:	eba2 0801 	sub.w	r8, r2, r1
  if (n < s1) {
  201054:	45a8      	cmp	r8, r5
  201056:	d9cc      	bls.n	200ff2 <iqReadTimeout+0x32>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
  201058:	462a      	mov	r2, r5
  20105a:	4630      	mov	r0, r6
  20105c:	f004 f8e8 	bl	205230 <memcpy>
    iqp->q_rdptr += n;
  201060:	69a2      	ldr	r2, [r4, #24]
  201062:	442a      	add	r2, r5
  201064:	61a2      	str	r2, [r4, #24]
  iqp->q_counter -= n;
  201066:	68a2      	ldr	r2, [r4, #8]
  201068:	1b52      	subs	r2, r2, r5
  20106a:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
  20106c:	2d00      	cmp	r5, #0
  20106e:	d1d7      	bne.n	201020 <iqReadTimeout+0x60>
  if (TIME_IMMEDIATE == timeout) {
  201070:	f1b9 0f00 	cmp.w	r9, #0
  201074:	d00c      	beq.n	201090 <iqReadTimeout+0xd0>
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  201076:	4b0e      	ldr	r3, [pc, #56]	; (2010b0 <iqReadTimeout+0xf0>)
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  201078:	4649      	mov	r1, r9
  p->prev       = qp->prev;
  20107a:	6860      	ldr	r0, [r4, #4]
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  20107c:	699a      	ldr	r2, [r3, #24]
  20107e:	e9c2 4000 	strd	r4, r0, [r2]
  p->prev->next = p;
  201082:	6002      	str	r2, [r0, #0]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  201084:	2004      	movs	r0, #4
  qp->prev      = p;
  201086:	6062      	str	r2, [r4, #4]
  201088:	f7ff fed2 	bl	200e30 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
  20108c:	2800      	cmp	r0, #0
  20108e:	d0a6      	beq.n	200fde <iqReadTimeout+0x1e>
  return max - n;
  201090:	9b01      	ldr	r3, [sp, #4]
  201092:	eba3 000b 	sub.w	r0, r3, fp
  201096:	2300      	movs	r3, #0
  201098:	f383 8811 	msr	BASEPRI, r3
}
  20109c:	b003      	add	sp, #12
  20109e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
  2010a2:	462a      	mov	r2, r5
  2010a4:	4630      	mov	r0, r6
  2010a6:	f004 f8c3 	bl	205230 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
  2010aa:	68e2      	ldr	r2, [r4, #12]
  2010ac:	61a2      	str	r2, [r4, #24]
  2010ae:	e7b3      	b.n	201018 <iqReadTimeout+0x58>
  2010b0:	200009d0 	.word	0x200009d0
	...

002010c0 <_read>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
  2010c0:	f04f 33ff 	mov.w	r3, #4294967295
  2010c4:	300c      	adds	r0, #12
  2010c6:	f7ff bf7b 	b.w	200fc0 <iqReadTimeout>
  2010ca:	bf00      	nop
  2010cc:	0000      	movs	r0, r0
	...

002010d0 <_readt>:
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
  2010d0:	300c      	adds	r0, #12
  2010d2:	f7ff bf75 	b.w	200fc0 <iqReadTimeout>
  2010d6:	bf00      	nop
	...

002010e0 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
  2010e0:	b570      	push	{r4, r5, r6, lr}
  2010e2:	2320      	movs	r3, #32
  2010e4:	4604      	mov	r4, r0
  2010e6:	460d      	mov	r5, r1
  2010e8:	f383 8811 	msr	BASEPRI, r3
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  2010ec:	4e16      	ldr	r6, [pc, #88]	; (201148 <iqGetTimeout+0x68>)
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
}
  2010ee:	e00a      	b.n	201106 <iqGetTimeout+0x26>
  if (TIME_IMMEDIATE == timeout) {
  2010f0:	b31d      	cbz	r5, 20113a <iqGetTimeout+0x5a>
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  2010f2:	69b3      	ldr	r3, [r6, #24]
  p->prev       = qp->prev;
  2010f4:	6862      	ldr	r2, [r4, #4]
  2010f6:	e9c3 4200 	strd	r4, r2, [r3]
  p->prev->next = p;
  2010fa:	6013      	str	r3, [r2, #0]
  qp->prev      = p;
  2010fc:	6063      	str	r3, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  2010fe:	f7ff fe97 	bl	200e30 <chSchGoSleepTimeoutS>
    if (msg < MSG_OK) {
  201102:	2800      	cmp	r0, #0
  201104:	db1b      	blt.n	20113e <iqGetTimeout+0x5e>
  while (iqIsEmptyI(iqp)) {
  201106:	68a3      	ldr	r3, [r4, #8]
  201108:	4629      	mov	r1, r5
  20110a:	2004      	movs	r0, #4
  20110c:	2b00      	cmp	r3, #0
  20110e:	d0ef      	beq.n	2010f0 <iqGetTimeout+0x10>
  iqp->q_counter--;
  201110:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  201112:	69a1      	ldr	r1, [r4, #24]
  iqp->q_counter--;
  201114:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  201116:	1c4a      	adds	r2, r1, #1
  iqp->q_counter--;
  201118:	60a3      	str	r3, [r4, #8]
  if (iqp->q_rdptr >= iqp->q_top) {
  20111a:	6923      	ldr	r3, [r4, #16]
  b = *iqp->q_rdptr++;
  20111c:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
  20111e:	429a      	cmp	r2, r3
  b = *iqp->q_rdptr++;
  201120:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
  201122:	d301      	bcc.n	201128 <iqGetTimeout+0x48>
    iqp->q_rdptr = iqp->q_buffer;
  201124:	68e3      	ldr	r3, [r4, #12]
  201126:	61a3      	str	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
  201128:	69e3      	ldr	r3, [r4, #28]
  20112a:	b10b      	cbz	r3, 201130 <iqGetTimeout+0x50>
    iqp->q_notify(iqp);
  20112c:	4620      	mov	r0, r4
  20112e:	4798      	blx	r3
  201130:	2300      	movs	r3, #0
  201132:	f383 8811 	msr	BASEPRI, r3
  return (msg_t)b;
  201136:	4628      	mov	r0, r5
}
  201138:	bd70      	pop	{r4, r5, r6, pc}
    return MSG_TIMEOUT;
  20113a:	f04f 30ff 	mov.w	r0, #4294967295
  20113e:	2300      	movs	r3, #0
  201140:	f383 8811 	msr	BASEPRI, r3
  201144:	bd70      	pop	{r4, r5, r6, pc}
  201146:	bf00      	nop
  201148:	200009d0 	.word	0x200009d0
  20114c:	00000000 	.word	0x00000000

00201150 <_get>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
  201150:	f04f 31ff 	mov.w	r1, #4294967295
  201154:	300c      	adds	r0, #12
  201156:	f7ff bfc3 	b.w	2010e0 <iqGetTimeout>
  20115a:	bf00      	nop
  20115c:	0000      	movs	r0, r0
	...

00201160 <_gett>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
  201160:	300c      	adds	r0, #12
  201162:	f7ff bfbd 	b.w	2010e0 <iqGetTimeout>
  201166:	bf00      	nop
	...

00201170 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
  201170:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  201174:	2320      	movs	r3, #32
  201176:	4604      	mov	r4, r0
  201178:	460f      	mov	r7, r1
  20117a:	4616      	mov	r6, r2
  20117c:	f383 8811 	msr	BASEPRI, r3
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  201180:	f8df 8060 	ldr.w	r8, [pc, #96]	; 2011e4 <oqPutTimeout+0x74>
  201184:	e00b      	b.n	20119e <oqPutTimeout+0x2e>
  if (TIME_IMMEDIATE == timeout) {
  201186:	b32e      	cbz	r6, 2011d4 <oqPutTimeout+0x64>
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  201188:	f8d8 3018 	ldr.w	r3, [r8, #24]
  p->prev       = qp->prev;
  20118c:	6865      	ldr	r5, [r4, #4]
  20118e:	e9c3 4500 	strd	r4, r5, [r3]
  p->prev->next = p;
  201192:	602b      	str	r3, [r5, #0]
  qp->prev      = p;
  201194:	6063      	str	r3, [r4, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  201196:	f7ff fe4b 	bl	200e30 <chSchGoSleepTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
  20119a:	2800      	cmp	r0, #0
  20119c:	db1c      	blt.n	2011d8 <oqPutTimeout+0x68>
  while (oqIsFullI(oqp)) {
  20119e:	68a3      	ldr	r3, [r4, #8]
  2011a0:	4631      	mov	r1, r6
  2011a2:	2004      	movs	r0, #4
  2011a4:	2b00      	cmp	r3, #0
  2011a6:	d0ee      	beq.n	201186 <oqPutTimeout+0x16>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
  2011a8:	6962      	ldr	r2, [r4, #20]
  oqp->q_counter--;
  2011aa:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
  2011ac:	1c51      	adds	r1, r2, #1
  oqp->q_counter--;
  2011ae:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
  2011b0:	6161      	str	r1, [r4, #20]
  oqp->q_counter--;
  2011b2:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
  2011b4:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
  2011b6:	e9d4 3204 	ldrd	r3, r2, [r4, #16]
  2011ba:	429a      	cmp	r2, r3
  2011bc:	d301      	bcc.n	2011c2 <oqPutTimeout+0x52>
    oqp->q_wrptr = oqp->q_buffer;
  2011be:	68e3      	ldr	r3, [r4, #12]
  2011c0:	6163      	str	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
  2011c2:	69e3      	ldr	r3, [r4, #28]
  2011c4:	b10b      	cbz	r3, 2011ca <oqPutTimeout+0x5a>
    oqp->q_notify(oqp);
  2011c6:	4620      	mov	r0, r4
  2011c8:	4798      	blx	r3
  2011ca:	2000      	movs	r0, #0
  2011cc:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
  2011d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return MSG_TIMEOUT;
  2011d4:	f04f 30ff 	mov.w	r0, #4294967295
  2011d8:	2300      	movs	r3, #0
  2011da:	f383 8811 	msr	BASEPRI, r3
  2011de:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2011e2:	bf00      	nop
  2011e4:	200009d0 	.word	0x200009d0
	...

002011f0 <_put>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
  2011f0:	f04f 32ff 	mov.w	r2, #4294967295
  2011f4:	3030      	adds	r0, #48	; 0x30
  2011f6:	f7ff bfbb 	b.w	201170 <oqPutTimeout>
  2011fa:	bf00      	nop
  2011fc:	0000      	movs	r0, r0
	...

00201200 <_putt>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
  201200:	3030      	adds	r0, #48	; 0x30
  201202:	f7ff bfb5 	b.w	201170 <oqPutTimeout>
  201206:	bf00      	nop
	...

00201210 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
  201210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  201214:	b083      	sub	sp, #12
  201216:	4699      	mov	r9, r3
  qnotify_t nfy = oqp->q_notify;
  201218:	69c7      	ldr	r7, [r0, #28]
  20121a:	f04f 0a20 	mov.w	sl, #32
                      size_t n, sysinterval_t timeout) {
  20121e:	9201      	str	r2, [sp, #4]
  201220:	f38a 8811 	msr	BASEPRI, sl

  osalDbgCheck(n > 0U);

  osalSysLock();

  while (n > 0U) {
  201224:	b392      	cbz	r2, 20128c <oqWriteTimeout+0x7c>
  201226:	4604      	mov	r4, r0
  201228:	460e      	mov	r6, r1
  20122a:	f8dd b004 	ldr.w	fp, [sp, #4]
  if (n > oqGetEmptyI(oqp)) {
  20122e:	68a2      	ldr	r2, [r4, #8]
  201230:	455a      	cmp	r2, fp
  201232:	d232      	bcs.n	20129a <oqWriteTimeout+0x8a>
    n = oqGetEmptyI(oqp);
  201234:	68a5      	ldr	r5, [r4, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
  201236:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
  20123a:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
  20123e:	45a8      	cmp	r8, r5
  201240:	d832      	bhi.n	2012a8 <oqWriteTimeout+0x98>
  else if (n > s1) {
  201242:	d256      	bcs.n	2012f2 <oqWriteTimeout+0xe2>
    s2 = n - s1;
  201244:	eba5 0308 	sub.w	r3, r5, r8
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
  201248:	4642      	mov	r2, r8
  20124a:	4631      	mov	r1, r6
    s2 = n - s1;
  20124c:	9300      	str	r3, [sp, #0]
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
  20124e:	f003 ffef 	bl	205230 <memcpy>
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
  201252:	eb06 0108 	add.w	r1, r6, r8
  201256:	f8dd 8000 	ldr.w	r8, [sp]
  20125a:	68e0      	ldr	r0, [r4, #12]
  20125c:	4642      	mov	r2, r8
  20125e:	f003 ffe7 	bl	205230 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
  201262:	68e2      	ldr	r2, [r4, #12]
  201264:	4442      	add	r2, r8
  201266:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
  201268:	68a2      	ldr	r2, [r4, #8]
  20126a:	1b52      	subs	r2, r2, r5
  20126c:	60a2      	str	r2, [r4, #8]
    size_t done;

    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
  20126e:	b33d      	cbz	r5, 2012c0 <oqWriteTimeout+0xb0>
      }
    }
    else {
      /* Inform the low side that the queue has at least one character
         available.*/
      if (nfy != NULL) {
  201270:	b10f      	cbz	r7, 201276 <oqWriteTimeout+0x66>
        nfy(oqp);
  201272:	4620      	mov	r0, r4
  201274:	47b8      	blx	r7
  201276:	2300      	movs	r3, #0
  201278:	f383 8811 	msr	BASEPRI, r3
      }

      /* Giving a preemption chance in a controlled point.*/
      osalSysUnlock();

      n  -= done;
  20127c:	ebab 0b05 	sub.w	fp, fp, r5
      bp += done;
  201280:	442e      	add	r6, r5
  201282:	f38a 8811 	msr	BASEPRI, sl
  while (n > 0U) {
  201286:	f1bb 0f00 	cmp.w	fp, #0
  20128a:	d1d0      	bne.n	20122e <oqWriteTimeout+0x1e>
  20128c:	9801      	ldr	r0, [sp, #4]
  20128e:	2300      	movs	r3, #0
  201290:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
  201294:	b003      	add	sp, #12
  201296:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
  20129a:	e9d4 2004 	ldrd	r2, r0, [r4, #16]
  20129e:	465d      	mov	r5, fp
  2012a0:	eba2 0800 	sub.w	r8, r2, r0
  if (n < s1) {
  2012a4:	45a8      	cmp	r8, r5
  2012a6:	d9cc      	bls.n	201242 <oqWriteTimeout+0x32>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
  2012a8:	462a      	mov	r2, r5
  2012aa:	4631      	mov	r1, r6
  2012ac:	f003 ffc0 	bl	205230 <memcpy>
    oqp->q_wrptr += n;
  2012b0:	6962      	ldr	r2, [r4, #20]
  2012b2:	442a      	add	r2, r5
  2012b4:	6162      	str	r2, [r4, #20]
  oqp->q_counter -= n;
  2012b6:	68a2      	ldr	r2, [r4, #8]
  2012b8:	1b52      	subs	r2, r2, r5
  2012ba:	60a2      	str	r2, [r4, #8]
    if (done == (size_t)0) {
  2012bc:	2d00      	cmp	r5, #0
  2012be:	d1d7      	bne.n	201270 <oqWriteTimeout+0x60>
  if (TIME_IMMEDIATE == timeout) {
  2012c0:	f1b9 0f00 	cmp.w	r9, #0
  2012c4:	d00c      	beq.n	2012e0 <oqWriteTimeout+0xd0>
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  2012c6:	4b0e      	ldr	r3, [pc, #56]	; (201300 <oqWriteTimeout+0xf0>)
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  2012c8:	4649      	mov	r1, r9
  p->prev       = qp->prev;
  2012ca:	6860      	ldr	r0, [r4, #4]
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  2012cc:	699a      	ldr	r2, [r3, #24]
  2012ce:	e9c2 4000 	strd	r4, r0, [r2]
  p->prev->next = p;
  2012d2:	6002      	str	r2, [r0, #0]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  2012d4:	2004      	movs	r0, #4
  qp->prev      = p;
  2012d6:	6062      	str	r2, [r4, #4]
  2012d8:	f7ff fdaa 	bl	200e30 <chSchGoSleepTimeoutS>
      if (msg != MSG_OK) {
  2012dc:	2800      	cmp	r0, #0
  2012de:	d0a6      	beq.n	20122e <oqWriteTimeout+0x1e>
  return max - n;
  2012e0:	9b01      	ldr	r3, [sp, #4]
  2012e2:	eba3 000b 	sub.w	r0, r3, fp
  2012e6:	2300      	movs	r3, #0
  2012e8:	f383 8811 	msr	BASEPRI, r3
}
  2012ec:	b003      	add	sp, #12
  2012ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
  2012f2:	462a      	mov	r2, r5
  2012f4:	4631      	mov	r1, r6
  2012f6:	f003 ff9b 	bl	205230 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
  2012fa:	68e2      	ldr	r2, [r4, #12]
  2012fc:	6162      	str	r2, [r4, #20]
  2012fe:	e7b3      	b.n	201268 <oqWriteTimeout+0x58>
  201300:	200009d0 	.word	0x200009d0
	...

00201310 <_write>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
  201310:	f04f 33ff 	mov.w	r3, #4294967295
  201314:	3030      	adds	r0, #48	; 0x30
  201316:	f7ff bf7b 	b.w	201210 <oqWriteTimeout>
  20131a:	bf00      	nop
  20131c:	0000      	movs	r0, r0
	...

00201320 <_writet>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
  201320:	3030      	adds	r0, #48	; 0x30
  201322:	f7ff bf75 	b.w	201210 <oqWriteTimeout>
  201326:	bf00      	nop
	...

00201330 <TFT_Send_Cmd>:
  palSetPadMode(WR_GPIO_Port,WR_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  palSetPadMode(RD_GPIO_Port,RD_Pin,PAL_MODE_OUTPUT_PUSHPULL);	
}

void TFT_Send_Cmd(uint8_t cmd)
{
  201330:	b570      	push	{r4, r5, r6, lr}
  DC_low;
  201332:	2240      	movs	r2, #64	; 0x40
  201334:	4c0b      	ldr	r4, [pc, #44]	; (201364 <TFT_Send_Cmd+0x34>)
  RD_Hi;
  201336:	2304      	movs	r3, #4
  CS_low;
  201338:	2510      	movs	r5, #16
  DC_low;
  20133a:	8362      	strh	r2, [r4, #26]
  WR_low;
  20133c:	2602      	movs	r6, #2
  RD_Hi;
  20133e:	8323      	strh	r3, [r4, #24]
  Data_Port=cmd;
  201340:	4b09      	ldr	r3, [pc, #36]	; (201368 <TFT_Send_Cmd+0x38>)
  CS_low;
  201342:	8365      	strh	r5, [r4, #26]
  WR_low;
  201344:	8366      	strh	r6, [r4, #26]
  Data_Port=cmd;
  201346:	6158      	str	r0, [r3, #20]
  201348:	2320      	movs	r3, #32
  20134a:	f383 8811 	msr	BASEPRI, r3
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
  20134e:	2101      	movs	r1, #1
  201350:	2008      	movs	r0, #8
  201352:	f7ff fd6d 	bl	200e30 <chSchGoSleepTimeoutS>
  201356:	2300      	movs	r3, #0
  201358:	f383 8811 	msr	BASEPRI, r3
  chThdSleepMicroseconds(1);
  WR_Hi;
  20135c:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  20135e:	8325      	strh	r5, [r4, #24]
}
  201360:	bd70      	pop	{r4, r5, r6, pc}
  201362:	bf00      	nop
  201364:	40020400 	.word	0x40020400
  201368:	40020c00 	.word	0x40020c00
  20136c:	00000000 	.word	0x00000000

00201370 <TFT_Write_Data>:

void TFT_Write_Data(uint8_t data)
{
  201370:	b570      	push	{r4, r5, r6, lr}
  DC_Hi;
  201372:	2240      	movs	r2, #64	; 0x40
  201374:	4c0b      	ldr	r4, [pc, #44]	; (2013a4 <TFT_Write_Data+0x34>)
  RD_Hi;
  201376:	2304      	movs	r3, #4
  CS_low;
  201378:	2510      	movs	r5, #16
  DC_Hi;
  20137a:	8322      	strh	r2, [r4, #24]
  WR_low;
  20137c:	2602      	movs	r6, #2
  RD_Hi;
  20137e:	8323      	strh	r3, [r4, #24]
  Data_Port=data;
  201380:	4b09      	ldr	r3, [pc, #36]	; (2013a8 <TFT_Write_Data+0x38>)
  CS_low;
  201382:	8365      	strh	r5, [r4, #26]
  WR_low;
  201384:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201386:	6158      	str	r0, [r3, #20]
  201388:	2320      	movs	r3, #32
  20138a:	f383 8811 	msr	BASEPRI, r3
  20138e:	2101      	movs	r1, #1
  201390:	2008      	movs	r0, #8
  201392:	f7ff fd4d 	bl	200e30 <chSchGoSleepTimeoutS>
  201396:	2300      	movs	r3, #0
  201398:	f383 8811 	msr	BASEPRI, r3
  chThdSleepMicroseconds(1);
  WR_Hi;
  20139c:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  20139e:	8325      	strh	r5, [r4, #24]
}
  2013a0:	bd70      	pop	{r4, r5, r6, pc}
  2013a2:	bf00      	nop
  2013a4:	40020400 	.word	0x40020400
  2013a8:	40020c00 	.word	0x40020c00
  2013ac:	00000000 	.word	0x00000000

002013b0 <TFT_Fill_Screen>:
/* Otris. color */
void TFT_Fill_Screen(uint16_t x_left, uint16_t x_right, uint16_t y_up, uint16_t y_down, uint16_t color)
{
	unsigned long  xy=0;
	unsigned long i=0;
	if(x_left > x_right)
  2013b0:	4288      	cmp	r0, r1
{
  2013b2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2013b6:	4683      	mov	fp, r0
  2013b8:	b087      	sub	sp, #28
	if(x_left > x_right)
  2013ba:	d901      	bls.n	2013c0 <TFT_Fill_Screen+0x10>
  2013bc:	468b      	mov	fp, r1
  2013be:	4601      	mov	r1, r0
	{	
		x_left = x_left^x_right;       
		x_right = x_left^x_right;      
		x_left = x_left^x_right;       
	}
	if(y_up > y_down)
  2013c0:	429a      	cmp	r2, r3
  2013c2:	d902      	bls.n	2013ca <TFT_Fill_Screen+0x1a>
  2013c4:	4610      	mov	r0, r2
  2013c6:	461a      	mov	r2, r3
  2013c8:	4603      	mov	r3, r0
		y_down = y_up^y_down;		
		y_up = y_up^y_down;		
	}
	
	
	x_left = constrain(x_left, MIN_X,MAX_X);
  2013ca:	48ad      	ldr	r0, [pc, #692]	; (201680 <TFT_Fill_Screen+0x2d0>)
  2013cc:	465c      	mov	r4, fp
  RD_Hi;
  2013ce:	f04f 0904 	mov.w	r9, #4
  CS_low;
  2013d2:	2510      	movs	r5, #16
	x_left = constrain(x_left, MIN_X,MAX_X);
  2013d4:	6800      	ldr	r0, [r0, #0]
  WR_low;
  2013d6:	f04f 0a02 	mov.w	sl, #2
  Data_Port=cmd;
  2013da:	f8df 82a8 	ldr.w	r8, [pc, #680]	; 201684 <TFT_Fill_Screen+0x2d4>
  2013de:	2620      	movs	r6, #32
  2013e0:	4583      	cmp	fp, r0
  DC_low;
  2013e2:	f04f 0b40 	mov.w	fp, #64	; 0x40
  2013e6:	bf28      	it	cs
  2013e8:	4604      	movcs	r4, r0
	if (c < a)
  2013ea:	4288      	cmp	r0, r1
  2013ec:	bf28      	it	cs
  2013ee:	4608      	movcs	r0, r1
	x_right = constrain(x_right, MIN_X,MAX_X);
	y_up = constrain(y_up, MIN_Y,MAX_Y);
  2013f0:	49a5      	ldr	r1, [pc, #660]	; (201688 <TFT_Fill_Screen+0x2d8>)
	y_down = constrain(y_down, MIN_Y,MAX_Y);

	xy = (x_right - x_left+1);		
  2013f2:	9403      	str	r4, [sp, #12]
	y_up = constrain(y_up, MIN_Y,MAX_Y);
  2013f4:	6809      	ldr	r1, [r1, #0]
	xy = (x_right - x_left+1);		
  2013f6:	9002      	str	r0, [sp, #8]
  2013f8:	1b00      	subs	r0, r0, r4
  2013fa:	428b      	cmp	r3, r1
  DC_low;
  2013fc:	4ca3      	ldr	r4, [pc, #652]	; (20168c <TFT_Fill_Screen+0x2dc>)
  2013fe:	bf28      	it	cs
  201400:	460b      	movcs	r3, r1
  201402:	428a      	cmp	r2, r1
  201404:	bf28      	it	cs
  201406:	460a      	movcs	r2, r1
	xy = xy*(y_down - y_up+1);		
  201408:	1c59      	adds	r1, r3, #1
  20140a:	9305      	str	r3, [sp, #20]
  20140c:	1a89      	subs	r1, r1, r2
  20140e:	9204      	str	r2, [sp, #16]
  201410:	fb00 1301 	mla	r3, r0, r1, r1
  Data_Port=cmd;
  201414:	212a      	movs	r1, #42	; 0x2a
	xy = xy*(y_down - y_up+1);		
  201416:	9301      	str	r3, [sp, #4]
  DC_low;
  201418:	f8a4 b01a 	strh.w	fp, [r4, #26]
  RD_Hi;
  20141c:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201420:	8365      	strh	r5, [r4, #26]
  WR_low;
  201422:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=cmd;
  201426:	f8c8 1014 	str.w	r1, [r8, #20]
  20142a:	f386 8811 	msr	BASEPRI, r6
  20142e:	2101      	movs	r1, #1
  201430:	2008      	movs	r0, #8
  201432:	f7ff fcfd 	bl	200e30 <chSchGoSleepTimeoutS>
  201436:	2700      	movs	r7, #0
  201438:	f387 8811 	msr	BASEPRI, r7
  20143c:	9a03      	ldr	r2, [sp, #12]
  WR_Hi;
  20143e:	f8a4 a018 	strh.w	sl, [r4, #24]
  201442:	f3c2 2107 	ubfx	r1, r2, #8, #8
  CS_Hi;
  201446:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201448:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  20144c:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201450:	8365      	strh	r5, [r4, #26]
  WR_low;
  201452:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=data;
  201456:	f8c8 1014 	str.w	r1, [r8, #20]
  20145a:	f386 8811 	msr	BASEPRI, r6
  20145e:	2101      	movs	r1, #1
  201460:	2008      	movs	r0, #8
  201462:	f7ff fce5 	bl	200e30 <chSchGoSleepTimeoutS>
  201466:	f387 8811 	msr	BASEPRI, r7
  20146a:	f89d 000c 	ldrb.w	r0, [sp, #12]
  WR_Hi;
  20146e:	f8a4 a018 	strh.w	sl, [r4, #24]
  CS_Hi;
  201472:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201474:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  201478:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  20147c:	8365      	strh	r5, [r4, #26]
  WR_low;
  20147e:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=data;
  201482:	f8c8 0014 	str.w	r0, [r8, #20]
  201486:	f386 8811 	msr	BASEPRI, r6
  20148a:	2101      	movs	r1, #1
  20148c:	2008      	movs	r0, #8
  20148e:	f7ff fccf 	bl	200e30 <chSchGoSleepTimeoutS>
  201492:	f387 8811 	msr	BASEPRI, r7
  201496:	9902      	ldr	r1, [sp, #8]
  WR_Hi;
  201498:	f8a4 a018 	strh.w	sl, [r4, #24]
  20149c:	f3c1 2107 	ubfx	r1, r1, #8, #8
  CS_Hi;
  2014a0:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  2014a2:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2014a6:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2014aa:	8365      	strh	r5, [r4, #26]
  WR_low;
  2014ac:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=data;
  2014b0:	f8c8 1014 	str.w	r1, [r8, #20]
  2014b4:	f386 8811 	msr	BASEPRI, r6
  2014b8:	2101      	movs	r1, #1
  2014ba:	2008      	movs	r0, #8
  2014bc:	f7ff fcb8 	bl	200e30 <chSchGoSleepTimeoutS>
  2014c0:	f387 8811 	msr	BASEPRI, r7
  2014c4:	f89d 1008 	ldrb.w	r1, [sp, #8]
  WR_Hi;
  2014c8:	f8a4 a018 	strh.w	sl, [r4, #24]
  CS_Hi;
  2014cc:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  2014ce:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2014d2:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2014d6:	8365      	strh	r5, [r4, #26]
  WR_low;
  2014d8:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=data;
  2014dc:	f8c8 1014 	str.w	r1, [r8, #20]
  2014e0:	f386 8811 	msr	BASEPRI, r6
  2014e4:	2101      	movs	r1, #1
  2014e6:	2008      	movs	r0, #8
  2014e8:	f7ff fca2 	bl	200e30 <chSchGoSleepTimeoutS>
  2014ec:	f387 8811 	msr	BASEPRI, r7
  Data_Port=cmd;
  2014f0:	212b      	movs	r1, #43	; 0x2b
  WR_Hi;
  2014f2:	f8a4 a018 	strh.w	sl, [r4, #24]
  CS_Hi;
  2014f6:	8325      	strh	r5, [r4, #24]
  DC_low;
  2014f8:	f8a4 b01a 	strh.w	fp, [r4, #26]
  RD_Hi;
  2014fc:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201500:	8365      	strh	r5, [r4, #26]
  WR_low;
  201502:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=cmd;
  201506:	f8c8 1014 	str.w	r1, [r8, #20]
  20150a:	f386 8811 	msr	BASEPRI, r6
  20150e:	2101      	movs	r1, #1
  201510:	2008      	movs	r0, #8
  201512:	f7ff fc8d 	bl	200e30 <chSchGoSleepTimeoutS>
  201516:	f387 8811 	msr	BASEPRI, r7
  20151a:	9a04      	ldr	r2, [sp, #16]
  WR_Hi;
  20151c:	f8a4 a018 	strh.w	sl, [r4, #24]
  201520:	f3c2 2107 	ubfx	r1, r2, #8, #8
  CS_Hi;
  201524:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201526:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  20152a:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  20152e:	8365      	strh	r5, [r4, #26]
  WR_low;
  201530:	f8a4 a01a 	strh.w	sl, [r4, #26]
  201534:	9202      	str	r2, [sp, #8]
  Data_Port=data;
  201536:	f8c8 1014 	str.w	r1, [r8, #20]
  20153a:	f386 8811 	msr	BASEPRI, r6
  20153e:	2101      	movs	r1, #1
  201540:	2008      	movs	r0, #8
  201542:	f7ff fc75 	bl	200e30 <chSchGoSleepTimeoutS>
  201546:	f387 8811 	msr	BASEPRI, r7
  20154a:	9a02      	ldr	r2, [sp, #8]
  WR_Hi;
  20154c:	f8a4 a018 	strh.w	sl, [r4, #24]
  201550:	b2d2      	uxtb	r2, r2
  CS_Hi;
  201552:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201554:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  201558:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  20155c:	8365      	strh	r5, [r4, #26]
  WR_low;
  20155e:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=data;
  201562:	f8c8 2014 	str.w	r2, [r8, #20]
  201566:	f386 8811 	msr	BASEPRI, r6
  20156a:	2101      	movs	r1, #1
  20156c:	2008      	movs	r0, #8
  20156e:	f7ff fc5f 	bl	200e30 <chSchGoSleepTimeoutS>
  201572:	f387 8811 	msr	BASEPRI, r7
  201576:	9b05      	ldr	r3, [sp, #20]
  WR_Hi;
  201578:	f8a4 a018 	strh.w	sl, [r4, #24]
  20157c:	f3c3 2207 	ubfx	r2, r3, #8, #8
  CS_Hi;
  201580:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201582:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  201586:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  20158a:	8365      	strh	r5, [r4, #26]
  WR_low;
  20158c:	f8a4 a01a 	strh.w	sl, [r4, #26]
  201590:	9302      	str	r3, [sp, #8]
  Data_Port=data;
  201592:	f8c8 2014 	str.w	r2, [r8, #20]
  201596:	f386 8811 	msr	BASEPRI, r6
  20159a:	2101      	movs	r1, #1
  20159c:	2008      	movs	r0, #8
  20159e:	f7ff fc47 	bl	200e30 <chSchGoSleepTimeoutS>
  2015a2:	f387 8811 	msr	BASEPRI, r7
  2015a6:	9b02      	ldr	r3, [sp, #8]
  WR_Hi;
  2015a8:	f8a4 a018 	strh.w	sl, [r4, #24]
  2015ac:	b2db      	uxtb	r3, r3
  CS_Hi;
  2015ae:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  2015b0:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2015b4:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2015b8:	8365      	strh	r5, [r4, #26]
  WR_low;
  2015ba:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=data;
  2015be:	f8c8 3014 	str.w	r3, [r8, #20]
  2015c2:	f386 8811 	msr	BASEPRI, r6
  2015c6:	2101      	movs	r1, #1
  2015c8:	2008      	movs	r0, #8
  2015ca:	f7ff fc31 	bl	200e30 <chSchGoSleepTimeoutS>
  2015ce:	f387 8811 	msr	BASEPRI, r7
  Data_Port=cmd;
  2015d2:	232c      	movs	r3, #44	; 0x2c
  WR_Hi;
  2015d4:	f8a4 a018 	strh.w	sl, [r4, #24]
  CS_Hi;
  2015d8:	8325      	strh	r5, [r4, #24]
  DC_low;
  2015da:	f8a4 b01a 	strh.w	fp, [r4, #26]
  RD_Hi;
  2015de:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2015e2:	8365      	strh	r5, [r4, #26]
  WR_low;
  2015e4:	f8a4 a01a 	strh.w	sl, [r4, #26]
  Data_Port=cmd;
  2015e8:	f8c8 3014 	str.w	r3, [r8, #20]
  2015ec:	f386 8811 	msr	BASEPRI, r6
  2015f0:	2101      	movs	r1, #1
  2015f2:	2008      	movs	r0, #8
  2015f4:	f7ff fc1c 	bl	200e30 <chSchGoSleepTimeoutS>
  2015f8:	f387 8811 	msr	BASEPRI, r7

	TFT_Set_Column(x_left,x_right);	        
	TFT_Set_Page(y_up, y_down);		
	TFT_Send_Cmd(0x2c);			
	
	for(i=0; i < xy; i++)
  2015fc:	9b01      	ldr	r3, [sp, #4]
  WR_Hi;
  2015fe:	f8a4 a018 	strh.w	sl, [r4, #24]
  CS_Hi;
  201602:	8325      	strh	r5, [r4, #24]
	for(i=0; i < xy; i++)
  201604:	2b00      	cmp	r3, #0
  201606:	d038      	beq.n	20167a <TFT_Fill_Screen+0x2ca>
	uint8_t data1 = data>>8;
  201608:	9b10      	ldr	r3, [sp, #64]	; 0x40
  20160a:	0a1b      	lsrs	r3, r3, #8
  20160c:	9303      	str	r3, [sp, #12]
  20160e:	9b10      	ldr	r3, [sp, #64]	; 0x40
  201610:	b2db      	uxtb	r3, r3
  201612:	9302      	str	r3, [sp, #8]
  DC_Hi;
  201614:	f04f 0340 	mov.w	r3, #64	; 0x40
  RD_Hi;
  201618:	2204      	movs	r2, #4
  CS_low;
  20161a:	2510      	movs	r5, #16
  WR_low;
  20161c:	2602      	movs	r6, #2
  DC_Hi;
  20161e:	8323      	strh	r3, [r4, #24]
  201620:	f04f 0920 	mov.w	r9, #32
  Data_Port=data;
  201624:	f8df a05c 	ldr.w	sl, [pc, #92]	; 201684 <TFT_Fill_Screen+0x2d4>
  201628:	9b03      	ldr	r3, [sp, #12]
  RD_Hi;
  20162a:	8322      	strh	r2, [r4, #24]
  CS_low;
  20162c:	8365      	strh	r5, [r4, #26]
  WR_low;
  20162e:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201630:	f8ca 3014 	str.w	r3, [sl, #20]
  201634:	f389 8811 	msr	BASEPRI, r9
  201638:	2101      	movs	r1, #1
  20163a:	2008      	movs	r0, #8
  20163c:	f7ff fbf8 	bl	200e30 <chSchGoSleepTimeoutS>
  201640:	f04f 0800 	mov.w	r8, #0
  201644:	f388 8811 	msr	BASEPRI, r8
  RD_Hi;
  201648:	2204      	movs	r2, #4
  Data_Port=data;
  20164a:	9b02      	ldr	r3, [sp, #8]
  WR_Hi;
  20164c:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  20164e:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201650:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  201654:	8322      	strh	r2, [r4, #24]
  CS_low;
  201656:	8365      	strh	r5, [r4, #26]
  WR_low;
  201658:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  20165a:	f8ca 3014 	str.w	r3, [sl, #20]
  20165e:	f389 8811 	msr	BASEPRI, r9
  201662:	2101      	movs	r1, #1
  201664:	2008      	movs	r0, #8
  201666:	f7ff fbe3 	bl	200e30 <chSchGoSleepTimeoutS>
  20166a:	f388 8811 	msr	BASEPRI, r8
	for(i=0; i < xy; i++)
  20166e:	3701      	adds	r7, #1
  201670:	9b01      	ldr	r3, [sp, #4]
  WR_Hi;
  201672:	8326      	strh	r6, [r4, #24]
	for(i=0; i < xy; i++)
  201674:	42bb      	cmp	r3, r7
  CS_Hi;
  201676:	8325      	strh	r5, [r4, #24]
	for(i=0; i < xy; i++)
  201678:	d1cc      	bne.n	201614 <TFT_Fill_Screen+0x264>
	{
		TFT_Send_Data(color);	
	}
}
  20167a:	b007      	add	sp, #28
  20167c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  201680:	20000820 	.word	0x20000820
  201684:	40020c00 	.word	0x40020c00
  201688:	20000824 	.word	0x20000824
  20168c:	40020400 	.word	0x40020400

00201690 <TFT_Draw_Char.constprop.0>:
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
	}
	
}
/*Simvol*/
void TFT_Draw_Char(uint16_t x, uint16_t y, uint16_t color, uint16_t phone, uint8_t ascii, uint8_t size)
  201690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  201694:	b089      	sub	sp, #36	; 0x24
{
	for (int i = 0; i < FONT_Y; i++ )
	{
		for(uint8_t f = 0; f < FONT_X; f++)
		{
			if(((simbols[ascii-0x20][i])>>(7-f))&0x01)
  201696:	3b20      	subs	r3, #32
void TFT_Draw_Char(uint16_t x, uint16_t y, uint16_t color, uint16_t phone, uint8_t ascii, uint8_t size)
  201698:	f89d 7048 	ldrb.w	r7, [sp, #72]	; 0x48
  20169c:	9203      	str	r2, [sp, #12]
  20169e:	eb01 0b07 	add.w	fp, r1, r7
  2016a2:	4a20      	ldr	r2, [pc, #128]	; (201724 <TFT_Draw_Char.constprop.0+0x94>)
  2016a4:	1e41      	subs	r1, r0, #1
  2016a6:	9006      	str	r0, [sp, #24]
  2016a8:	9107      	str	r1, [sp, #28]
  2016aa:	f102 0108 	add.w	r1, r2, #8
  2016ae:	eb02 02c3 	add.w	r2, r2, r3, lsl #3
  2016b2:	eb01 03c3 	add.w	r3, r1, r3, lsl #3
  2016b6:	9204      	str	r2, [sp, #16]
  2016b8:	9305      	str	r3, [sp, #20]
			if(((simbols[ascii-0x20][i])>>(7-f))&0x01)
  2016ba:	9b04      	ldr	r3, [sp, #16]
			{
				TFT_Fill_Rectangle(x+f*size, y+i*size, size, size, color);
			}
			else
			{
				TFT_Fill_Rectangle(x+f*size, y+i*size, size, size, phone);
  2016bc:	ebab 0907 	sub.w	r9, fp, r7
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
  2016c0:	f10b 38ff 	add.w	r8, fp, #4294967295
			if(((simbols[ascii-0x20][i])>>(7-f))&0x01)
  2016c4:	9d06      	ldr	r5, [sp, #24]
  2016c6:	f813 ab01 	ldrb.w	sl, [r3], #1
  2016ca:	2407      	movs	r4, #7
  2016cc:	9304      	str	r3, [sp, #16]
  2016ce:	9b07      	ldr	r3, [sp, #28]
  2016d0:	19de      	adds	r6, r3, r7
  2016d2:	e00a      	b.n	2016ea <TFT_Draw_Char.constprop.0+0x5a>
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
  2016d4:	f8dd c00c 	ldr.w	ip, [sp, #12]
		for(uint8_t f = 0; f < FONT_X; f++)
  2016d8:	3c01      	subs	r4, #1
  2016da:	443d      	add	r5, r7
  2016dc:	443e      	add	r6, r7
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
  2016de:	f8cd c000 	str.w	ip, [sp]
  2016e2:	f7ff fe65 	bl	2013b0 <TFT_Fill_Screen>
		for(uint8_t f = 0; f < FONT_X; f++)
  2016e6:	1c63      	adds	r3, r4, #1
  2016e8:	d013      	beq.n	201712 <TFT_Draw_Char.constprop.0+0x82>
			if(((simbols[ascii-0x20][i])>>(7-f))&0x01)
  2016ea:	fa4a f004 	asr.w	r0, sl, r4
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
  2016ee:	4643      	mov	r3, r8
  2016f0:	464a      	mov	r2, r9
  2016f2:	4631      	mov	r1, r6
			if(((simbols[ascii-0x20][i])>>(7-f))&0x01)
  2016f4:	f010 0f01 	tst.w	r0, #1
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
  2016f8:	4628      	mov	r0, r5
			if(((simbols[ascii-0x20][i])>>(7-f))&0x01)
  2016fa:	d1eb      	bne.n	2016d4 <TFT_Draw_Char.constprop.0+0x44>
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
  2016fc:	f64f 7cff 	movw	ip, #65535	; 0xffff
		for(uint8_t f = 0; f < FONT_X; f++)
  201700:	3c01      	subs	r4, #1
  201702:	443d      	add	r5, r7
  201704:	443e      	add	r6, r7
		TFT_Fill_Screen(x, x+length - 1, y, y+width - 1, color);
  201706:	f8cd c000 	str.w	ip, [sp]
  20170a:	f7ff fe51 	bl	2013b0 <TFT_Fill_Screen>
		for(uint8_t f = 0; f < FONT_X; f++)
  20170e:	1c63      	adds	r3, r4, #1
  201710:	d1eb      	bne.n	2016ea <TFT_Draw_Char.constprop.0+0x5a>
	for (int i = 0; i < FONT_Y; i++ )
  201712:	44bb      	add	fp, r7
  201714:	e9dd 3204 	ldrd	r3, r2, [sp, #16]
  201718:	4293      	cmp	r3, r2
  20171a:	d1ce      	bne.n	2016ba <TFT_Draw_Char.constprop.0+0x2a>
			}

		}

	}
}
  20171c:	b009      	add	sp, #36	; 0x24
  20171e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  201722:	bf00      	nop
  201724:	08005cf4 	.word	0x08005cf4
	...

00201730 <TFT_Draw_String.constprop.0>:
/*Stroka*/
void TFT_Draw_String(uint16_t x, uint16_t y, uint16_t color,uint16_t phone,char *string, uint8_t size)
  201730:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  201734:	461d      	mov	r5, r3
  201736:	b082      	sub	sp, #8
{
        
	while(*string)
  201738:	781b      	ldrb	r3, [r3, #0]
void TFT_Draw_String(uint16_t x, uint16_t y, uint16_t color,uint16_t phone,char *string, uint8_t size)
  20173a:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
	while(*string)
  20173e:	b1d3      	cbz	r3, 201776 <TFT_Draw_String.constprop.0+0x46>
  201740:	4604      	mov	r4, r0
  201742:	468a      	mov	sl, r1
  201744:	4617      	mov	r7, r2
	{      
                
		if((x + FONT_X) > MAX_X)
		{
			x = 1;
			y = y + FONT_X*size;
  201746:	ea4f 06c8 	mov.w	r6, r8, lsl #3
  20174a:	f8df 9030 	ldr.w	r9, [pc, #48]	; 20177c <TFT_Draw_String.constprop.0+0x4c>
		if((x + FONT_X) > MAX_X)
  20174e:	f104 0008 	add.w	r0, r4, #8
  201752:	f8d9 1000 	ldr.w	r1, [r9]
		}
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201756:	463a      	mov	r2, r7
		if((x + FONT_X) > MAX_X)
  201758:	4288      	cmp	r0, r1
  20175a:	d901      	bls.n	201760 <TFT_Draw_String.constprop.0+0x30>
			x = 1;
  20175c:	2401      	movs	r4, #1
			y = y + FONT_X*size;
  20175e:	44b2      	add	sl, r6
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201760:	4620      	mov	r0, r4
  201762:	4651      	mov	r1, sl
  201764:	f8cd 8000 	str.w	r8, [sp]
		x += FONT_X*size;     
  201768:	4434      	add	r4, r6
		TFT_Draw_Char(x, y, color, phone,*string, size);
  20176a:	f7ff ff91 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  20176e:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  201772:	2b00      	cmp	r3, #0
  201774:	d1eb      	bne.n	20174e <TFT_Draw_String.constprop.0+0x1e>
		*string++;           
	}
}
  201776:	b002      	add	sp, #8
  201778:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  20177c:	20000820 	.word	0x20000820

00201780 <Cursor>:
    TFT_Draw_String(current->x_pos,current->y_pos, RED, WHITE, current->text, 2);
  201780:	4b12      	ldr	r3, [pc, #72]	; (2017cc <Cursor+0x4c>)
  201782:	681b      	ldr	r3, [r3, #0]
{
  201784:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    TFT_Draw_String(current->x_pos,current->y_pos, RED, WHITE, current->text, 2);
  201788:	681d      	ldr	r5, [r3, #0]
{
  20178a:	b082      	sub	sp, #8
    TFT_Draw_String(current->x_pos,current->y_pos, RED, WHITE, current->text, 2);
  20178c:	e9d3 4807 	ldrd	r4, r8, [r3, #28]
	while(*string)
  201790:	782b      	ldrb	r3, [r5, #0]
  201792:	b1bb      	cbz	r3, 2017c4 <Cursor+0x44>
  201794:	4f0e      	ldr	r7, [pc, #56]	; (2017d0 <Cursor+0x50>)
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201796:	2602      	movs	r6, #2
  201798:	e00a      	b.n	2017b0 <Cursor+0x30>
		x += FONT_X*size;     
  20179a:	4620      	mov	r0, r4
  20179c:	3410      	adds	r4, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  20179e:	f44f 4278 	mov.w	r2, #63488	; 0xf800
  2017a2:	4641      	mov	r1, r8
  2017a4:	9600      	str	r6, [sp, #0]
  2017a6:	f7ff ff73 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  2017aa:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  2017ae:	b14b      	cbz	r3, 2017c4 <Cursor+0x44>
		if((x + FONT_X) > MAX_X)
  2017b0:	f104 0208 	add.w	r2, r4, #8
  2017b4:	6839      	ldr	r1, [r7, #0]
			x = 1;
  2017b6:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  2017b8:	428a      	cmp	r2, r1
  2017ba:	d9ee      	bls.n	20179a <Cursor+0x1a>
			y = y + FONT_X*size;
  2017bc:	f108 0810 	add.w	r8, r8, #16
  2017c0:	2411      	movs	r4, #17
  2017c2:	e7ec      	b.n	20179e <Cursor+0x1e>
}
  2017c4:	b002      	add	sp, #8
  2017c6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  2017ca:	bf00      	nop
  2017cc:	20000ef0 	.word	0x20000ef0
  2017d0:	20000820 	.word	0x20000820
	...

002017e0 <TFT_Draw_Line.constprop.0>:
/* Line*/
void TFT_Draw_Line( uint16_t x0,uint16_t y0,uint16_t x1, uint16_t y1,uint16_t color)
  2017e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2017e4:	b08f      	sub	sp, #60	; 0x3c
  2017e6:	461c      	mov	r4, r3
  DC_low;
  2017e8:	f04f 0b40 	mov.w	fp, #64	; 0x40
  Data_Port=cmd;
  2017ec:	f8df a298 	ldr.w	sl, [pc, #664]	; 201a88 <TFT_Draw_Line.constprop.0+0x2a8>
void TFT_Draw_Line( uint16_t x0,uint16_t y0,uint16_t x1, uint16_t y1,uint16_t color)
  2017f0:	930c      	str	r3, [sp, #48]	; 0x30
{

	int x = x1-x0;
	int y = y1-y0;
  2017f2:	1a5b      	subs	r3, r3, r1
void TFT_Draw_Line( uint16_t x0,uint16_t y0,uint16_t x1, uint16_t y1,uint16_t color)
  2017f4:	9209      	str	r2, [sp, #36]	; 0x24
	int dx = abs(x), sx = x0<x1 ? 1 : -1;
	int dy = -abs(y), sy = y0<y1 ? 1 : -1;
  2017f6:	ea83 75e3 	eor.w	r5, r3, r3, asr #31
void TFT_Draw_Line( uint16_t x0,uint16_t y0,uint16_t x1, uint16_t y1,uint16_t color)
  2017fa:	9108      	str	r1, [sp, #32]
  2017fc:	9000      	str	r0, [sp, #0]
	int dy = -abs(y), sy = y0<y1 ? 1 : -1;
  2017fe:	eba5 75e3 	sub.w	r5, r5, r3, asr #31
	int x = x1-x0;
  201802:	1a13      	subs	r3, r2, r0
	int dx = abs(x), sx = x0<x1 ? 1 : -1;
  201804:	ea83 76e3 	eor.w	r6, r3, r3, asr #31
	int dy = -abs(y), sy = y0<y1 ? 1 : -1;
  201808:	950a      	str	r5, [sp, #40]	; 0x28
	int dx = abs(x), sx = x0<x1 ? 1 : -1;
  20180a:	eba6 76e3 	sub.w	r6, r6, r3, asr #31
  20180e:	4282      	cmp	r2, r0
  201810:	bf8c      	ite	hi
  201812:	2301      	movhi	r3, #1
  201814:	f04f 33ff 	movls.w	r3, #4294967295
	int dy = -abs(y), sy = y0<y1 ? 1 : -1;
  201818:	426a      	negs	r2, r5
	int dx = abs(x), sx = x0<x1 ? 1 : -1;
  20181a:	930b      	str	r3, [sp, #44]	; 0x2c
  20181c:	0a0b      	lsrs	r3, r1, #8
	int dy = -abs(y), sy = y0<y1 ? 1 : -1;
  20181e:	9206      	str	r2, [sp, #24]
  201820:	428c      	cmp	r4, r1
  201822:	bf8c      	ite	hi
  201824:	2201      	movhi	r2, #1
  201826:	f04f 32ff 	movls.w	r2, #4294967295
  20182a:	9305      	str	r3, [sp, #20]
  20182c:	b2cb      	uxtb	r3, r1
  20182e:	920d      	str	r2, [sp, #52]	; 0x34
  201830:	1b72      	subs	r2, r6, r5
  DC_low;
  201832:	4c96      	ldr	r4, [pc, #600]	; (201a8c <TFT_Draw_Line.constprop.0+0x2ac>)
	int dx = abs(x), sx = x0<x1 ? 1 : -1;
  201834:	9607      	str	r6, [sp, #28]
  201836:	9301      	str	r3, [sp, #4]
  RD_Hi;
  201838:	f04f 0904 	mov.w	r9, #4
  CS_low;
  20183c:	2510      	movs	r5, #16
  WR_low;
  20183e:	2602      	movs	r6, #2
  Data_Port=cmd;
  201840:	232a      	movs	r3, #42	; 0x2a
  201842:	9204      	str	r2, [sp, #16]
  201844:	f04f 0820 	mov.w	r8, #32
  DC_low;
  201848:	f8a4 b01a 	strh.w	fp, [r4, #26]
  RD_Hi;
  20184c:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201850:	8365      	strh	r5, [r4, #26]
  WR_low;
  201852:	8366      	strh	r6, [r4, #26]
  Data_Port=cmd;
  201854:	f8ca 3014 	str.w	r3, [sl, #20]
  201858:	f388 8811 	msr	BASEPRI, r8
  20185c:	2101      	movs	r1, #1
  20185e:	2008      	movs	r0, #8
  201860:	f7ff fae6 	bl	200e30 <chSchGoSleepTimeoutS>
  201864:	2700      	movs	r7, #0
  201866:	f387 8811 	msr	BASEPRI, r7
  20186a:	9800      	ldr	r0, [sp, #0]
  WR_Hi;
  20186c:	8326      	strh	r6, [r4, #24]
  20186e:	f3c0 2307 	ubfx	r3, r0, #8, #8
  CS_Hi;
  201872:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201874:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  201878:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  20187c:	8365      	strh	r5, [r4, #26]
  WR_low;
  20187e:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201880:	9302      	str	r3, [sp, #8]
  201882:	f8ca 3014 	str.w	r3, [sl, #20]
  201886:	f388 8811 	msr	BASEPRI, r8
  20188a:	2101      	movs	r1, #1
  20188c:	2008      	movs	r0, #8
  20188e:	f7ff facf 	bl	200e30 <chSchGoSleepTimeoutS>
  201892:	f387 8811 	msr	BASEPRI, r7
  201896:	f89d 3000 	ldrb.w	r3, [sp]
  WR_Hi;
  20189a:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  20189c:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  20189e:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2018a2:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2018a6:	8365      	strh	r5, [r4, #26]
  WR_low;
  2018a8:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  2018aa:	f8ca 3014 	str.w	r3, [sl, #20]
  2018ae:	9303      	str	r3, [sp, #12]
  2018b0:	f388 8811 	msr	BASEPRI, r8
  2018b4:	2101      	movs	r1, #1
  2018b6:	2008      	movs	r0, #8
  2018b8:	f7ff faba 	bl	200e30 <chSchGoSleepTimeoutS>
  2018bc:	f387 8811 	msr	BASEPRI, r7
  2018c0:	9b02      	ldr	r3, [sp, #8]
  WR_Hi;
  2018c2:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  2018c4:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  2018c6:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2018ca:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2018ce:	8365      	strh	r5, [r4, #26]
  WR_low;
  2018d0:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  2018d2:	f8ca 3014 	str.w	r3, [sl, #20]
  2018d6:	f388 8811 	msr	BASEPRI, r8
  2018da:	2101      	movs	r1, #1
  2018dc:	2008      	movs	r0, #8
  2018de:	f7ff faa7 	bl	200e30 <chSchGoSleepTimeoutS>
  2018e2:	f387 8811 	msr	BASEPRI, r7
  2018e6:	9b03      	ldr	r3, [sp, #12]
  WR_Hi;
  2018e8:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  2018ea:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  2018ec:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2018f0:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2018f4:	8365      	strh	r5, [r4, #26]
  WR_low;
  2018f6:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  2018f8:	f8ca 3014 	str.w	r3, [sl, #20]
  2018fc:	f388 8811 	msr	BASEPRI, r8
  201900:	2101      	movs	r1, #1
  201902:	2008      	movs	r0, #8
  201904:	f7ff fa94 	bl	200e30 <chSchGoSleepTimeoutS>
  201908:	f387 8811 	msr	BASEPRI, r7
  Data_Port=cmd;
  20190c:	232b      	movs	r3, #43	; 0x2b
  WR_Hi;
  20190e:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  201910:	8325      	strh	r5, [r4, #24]
  DC_low;
  201912:	f8a4 b01a 	strh.w	fp, [r4, #26]
  RD_Hi;
  201916:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  20191a:	8365      	strh	r5, [r4, #26]
  WR_low;
  20191c:	8366      	strh	r6, [r4, #26]
  Data_Port=cmd;
  20191e:	f8ca 3014 	str.w	r3, [sl, #20]
  201922:	f388 8811 	msr	BASEPRI, r8
  201926:	2101      	movs	r1, #1
  201928:	2008      	movs	r0, #8
  20192a:	f7ff fa81 	bl	200e30 <chSchGoSleepTimeoutS>
  20192e:	f387 8811 	msr	BASEPRI, r7
  201932:	f89d 3014 	ldrb.w	r3, [sp, #20]
  WR_Hi;
  201936:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  201938:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  20193a:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  20193e:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201942:	8365      	strh	r5, [r4, #26]
  WR_low;
  201944:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201946:	f8ca 3014 	str.w	r3, [sl, #20]
  20194a:	9302      	str	r3, [sp, #8]
  20194c:	f388 8811 	msr	BASEPRI, r8
  201950:	2101      	movs	r1, #1
  201952:	2008      	movs	r0, #8
  201954:	f7ff fa6c 	bl	200e30 <chSchGoSleepTimeoutS>
  201958:	f387 8811 	msr	BASEPRI, r7
  20195c:	9b01      	ldr	r3, [sp, #4]
  WR_Hi;
  20195e:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  201960:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201962:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  201966:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  20196a:	8365      	strh	r5, [r4, #26]
  WR_low;
  20196c:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  20196e:	f8ca 3014 	str.w	r3, [sl, #20]
  201972:	f388 8811 	msr	BASEPRI, r8
  201976:	2101      	movs	r1, #1
  201978:	2008      	movs	r0, #8
  20197a:	f7ff fa59 	bl	200e30 <chSchGoSleepTimeoutS>
  20197e:	f387 8811 	msr	BASEPRI, r7
  201982:	9b02      	ldr	r3, [sp, #8]
  WR_Hi;
  201984:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  201986:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201988:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  20198c:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201990:	8365      	strh	r5, [r4, #26]
  WR_low;
  201992:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201994:	f8ca 3014 	str.w	r3, [sl, #20]
  201998:	f388 8811 	msr	BASEPRI, r8
  20199c:	2101      	movs	r1, #1
  20199e:	2008      	movs	r0, #8
  2019a0:	f7ff fa46 	bl	200e30 <chSchGoSleepTimeoutS>
  2019a4:	f387 8811 	msr	BASEPRI, r7
  2019a8:	9b01      	ldr	r3, [sp, #4]
  WR_Hi;
  2019aa:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  2019ac:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  2019ae:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2019b2:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2019b6:	8365      	strh	r5, [r4, #26]
  WR_low;
  2019b8:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  2019ba:	f8ca 3014 	str.w	r3, [sl, #20]
  2019be:	f388 8811 	msr	BASEPRI, r8
  2019c2:	2101      	movs	r1, #1
  2019c4:	2008      	movs	r0, #8
  2019c6:	f7ff fa33 	bl	200e30 <chSchGoSleepTimeoutS>
  2019ca:	f387 8811 	msr	BASEPRI, r7
  Data_Port=cmd;
  2019ce:	232c      	movs	r3, #44	; 0x2c
  WR_Hi;
  2019d0:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  2019d2:	8325      	strh	r5, [r4, #24]
  DC_low;
  2019d4:	f8a4 b01a 	strh.w	fp, [r4, #26]
  RD_Hi;
  2019d8:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  2019dc:	8365      	strh	r5, [r4, #26]
  WR_low;
  2019de:	8366      	strh	r6, [r4, #26]
  Data_Port=cmd;
  2019e0:	f8ca 3014 	str.w	r3, [sl, #20]
  2019e4:	f388 8811 	msr	BASEPRI, r8
  2019e8:	2101      	movs	r1, #1
  2019ea:	2008      	movs	r0, #8
  2019ec:	f7ff fa20 	bl	200e30 <chSchGoSleepTimeoutS>
  2019f0:	f387 8811 	msr	BASEPRI, r7
  WR_Hi;
  2019f4:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  2019f6:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  2019f8:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  2019fc:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201a00:	8365      	strh	r5, [r4, #26]
  WR_low;
  201a02:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201a04:	f8ca 7014 	str.w	r7, [sl, #20]
  201a08:	f388 8811 	msr	BASEPRI, r8
  201a0c:	2101      	movs	r1, #1
  201a0e:	2008      	movs	r0, #8
  201a10:	f7ff fa0e 	bl	200e30 <chSchGoSleepTimeoutS>
  201a14:	f387 8811 	msr	BASEPRI, r7
  WR_Hi;
  201a18:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  201a1a:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201a1c:	f8a4 b018 	strh.w	fp, [r4, #24]
  RD_Hi;
  201a20:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201a24:	8365      	strh	r5, [r4, #26]
  WR_low;
  201a26:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201a28:	f8ca 7014 	str.w	r7, [sl, #20]
  201a2c:	f388 8811 	msr	BASEPRI, r8
  201a30:	2101      	movs	r1, #1
  201a32:	2008      	movs	r0, #8
  201a34:	f7ff f9fc 	bl	200e30 <chSchGoSleepTimeoutS>
  201a38:	f387 8811 	msr	BASEPRI, r7
	int err = dx+dy, e2;
	for (;;){
		TFT_Draw_Pixel(x0,y0,color);
		e2 = 2*err;
  201a3c:	9a04      	ldr	r2, [sp, #16]
		if (e2 >= dy) {
  201a3e:	9906      	ldr	r1, [sp, #24]
  WR_Hi;
  201a40:	8326      	strh	r6, [r4, #24]
		e2 = 2*err;
  201a42:	0053      	lsls	r3, r2, #1
		if (e2 >= dy) {
  201a44:	ebb1 0f42 	cmp.w	r1, r2, lsl #1
  CS_Hi;
  201a48:	8325      	strh	r5, [r4, #24]
		if (e2 >= dy) {
  201a4a:	dc0c      	bgt.n	201a66 <TFT_Draw_Line.constprop.0+0x286>
			if (x0 == x1) break;
  201a4c:	9909      	ldr	r1, [sp, #36]	; 0x24
  201a4e:	9800      	ldr	r0, [sp, #0]
  201a50:	4281      	cmp	r1, r0
  201a52:	d016      	beq.n	201a82 <TFT_Draw_Line.constprop.0+0x2a2>
  201a54:	990a      	ldr	r1, [sp, #40]	; 0x28
  201a56:	1a52      	subs	r2, r2, r1
			err += dy; x0 += sx;
  201a58:	990b      	ldr	r1, [sp, #44]	; 0x2c
  201a5a:	4408      	add	r0, r1
		}
		if (e2 <= dx) {
  201a5c:	9907      	ldr	r1, [sp, #28]
  201a5e:	4299      	cmp	r1, r3
			err += dy; x0 += sx;
  201a60:	9000      	str	r0, [sp, #0]
		if (e2 <= dx) {
  201a62:	f6ff aee9 	blt.w	201838 <TFT_Draw_Line.constprop.0+0x58>
			if (y0 == y1) break;
  201a66:	990c      	ldr	r1, [sp, #48]	; 0x30
  201a68:	9b08      	ldr	r3, [sp, #32]
  201a6a:	4299      	cmp	r1, r3
  201a6c:	d009      	beq.n	201a82 <TFT_Draw_Line.constprop.0+0x2a2>
			err += dx; y0 += sy;
  201a6e:	990d      	ldr	r1, [sp, #52]	; 0x34
  201a70:	440b      	add	r3, r1
  201a72:	9907      	ldr	r1, [sp, #28]
  201a74:	9308      	str	r3, [sp, #32]
  201a76:	440a      	add	r2, r1
  201a78:	0a19      	lsrs	r1, r3, #8
  201a7a:	b2db      	uxtb	r3, r3
  201a7c:	9105      	str	r1, [sp, #20]
  201a7e:	9301      	str	r3, [sp, #4]
  201a80:	e6da      	b.n	201838 <TFT_Draw_Line.constprop.0+0x58>
		}
	}
}
  201a82:	b00f      	add	sp, #60	; 0x3c
  201a84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  201a88:	40020c00 	.word	0x40020c00
  201a8c:	40020400 	.word	0x40020400

00201a90 <TFT_Draw_Triangle.constprop.0>:
	for(i=0; i<length; i++)
	TFT_Send_Data(color);
}

/*Treugol*/
void TFT_Draw_Triangle( uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t x3, uint16_t y3, uint16_t color)
  201a90:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  201a94:	4616      	mov	r6, r2
  201a96:	461f      	mov	r7, r3
  201a98:	4604      	mov	r4, r0
  201a9a:	460d      	mov	r5, r1
  201a9c:	e9dd 8908 	ldrd	r8, r9, [sp, #32]
{
	TFT_Draw_Line( x1, y1, x2, y2, color);
  201aa0:	f7ff fe9e 	bl	2017e0 <TFT_Draw_Line.constprop.0>
	TFT_Draw_Line( x2, y2, x3, y3, color);
  201aa4:	4639      	mov	r1, r7
  201aa6:	464b      	mov	r3, r9
  201aa8:	4642      	mov	r2, r8
  201aaa:	4630      	mov	r0, r6
  201aac:	f7ff fe98 	bl	2017e0 <TFT_Draw_Line.constprop.0>
	TFT_Draw_Line( x3, y3, x1, y1, color);
  201ab0:	462b      	mov	r3, r5
  201ab2:	4622      	mov	r2, r4
  201ab4:	4649      	mov	r1, r9
  201ab6:	4640      	mov	r0, r8
}
  201ab8:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	TFT_Draw_Line( x3, y3, x1, y1, color);
  201abc:	f7ff be90 	b.w	2017e0 <TFT_Draw_Line.constprop.0>

00201ac0 <TFT_Draw_Horizontal_Line.constprop.0>:
void  TFT_Draw_Horizontal_Line( uint16_t x, uint16_t y, uint16_t length,uint16_t color)
  201ac0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  Data_Port=cmd;
  201ac4:	222a      	movs	r2, #42	; 0x2a
  DC_low;
  201ac6:	4c90      	ldr	r4, [pc, #576]	; (201d08 <TFT_Draw_Horizontal_Line.constprop.0+0x248>)
void  TFT_Draw_Horizontal_Line( uint16_t x, uint16_t y, uint16_t length,uint16_t color)
  201ac8:	b083      	sub	sp, #12
  DC_low;
  201aca:	f04f 0a40 	mov.w	sl, #64	; 0x40
  RD_Hi;
  201ace:	f04f 0904 	mov.w	r9, #4
  CS_low;
  201ad2:	2510      	movs	r5, #16
  WR_low;
  201ad4:	f04f 0b02 	mov.w	fp, #2
  Data_Port=cmd;
  201ad8:	4f8c      	ldr	r7, [pc, #560]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
void  TFT_Draw_Horizontal_Line( uint16_t x, uint16_t y, uint16_t length,uint16_t color)
  201ada:	9001      	str	r0, [sp, #4]
  201adc:	f04f 0820 	mov.w	r8, #32
  DC_low;
  201ae0:	f8a4 a01a 	strh.w	sl, [r4, #26]
  RD_Hi;
  201ae4:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201ae8:	8365      	strh	r5, [r4, #26]
  WR_low;
  201aea:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=cmd;
  201aee:	617a      	str	r2, [r7, #20]
  201af0:	f388 8811 	msr	BASEPRI, r8
  201af4:	2101      	movs	r1, #1
  201af6:	2008      	movs	r0, #8
  201af8:	f7ff f99a 	bl	200e30 <chSchGoSleepTimeoutS>
  201afc:	2600      	movs	r6, #0
  201afe:	f386 8811 	msr	BASEPRI, r6
  WR_Hi;
  201b02:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201b06:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201b08:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201b0c:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201b10:	8365      	strh	r5, [r4, #26]
  WR_low;
  201b12:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201b16:	617e      	str	r6, [r7, #20]
  201b18:	f388 8811 	msr	BASEPRI, r8
  201b1c:	2101      	movs	r1, #1
  201b1e:	2008      	movs	r0, #8
  201b20:	f7ff f986 	bl	200e30 <chSchGoSleepTimeoutS>
  201b24:	f386 8811 	msr	BASEPRI, r6
  WR_Hi;
  201b28:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201b2c:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201b2e:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201b32:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201b36:	8365      	strh	r5, [r4, #26]
  WR_low;
  201b38:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201b3c:	617e      	str	r6, [r7, #20]
  201b3e:	f388 8811 	msr	BASEPRI, r8
  201b42:	2101      	movs	r1, #1
  201b44:	2008      	movs	r0, #8
  201b46:	f7ff f973 	bl	200e30 <chSchGoSleepTimeoutS>
  201b4a:	f386 8811 	msr	BASEPRI, r6
  201b4e:	2701      	movs	r7, #1
  201b50:	4b6e      	ldr	r3, [pc, #440]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  WR_Hi;
  201b52:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201b56:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201b58:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201b5c:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201b60:	8365      	strh	r5, [r4, #26]
  WR_low;
  201b62:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201b66:	615f      	str	r7, [r3, #20]
  201b68:	f388 8811 	msr	BASEPRI, r8
  201b6c:	2008      	movs	r0, #8
  201b6e:	4639      	mov	r1, r7
  201b70:	f7ff f95e 	bl	200e30 <chSchGoSleepTimeoutS>
  201b74:	f386 8811 	msr	BASEPRI, r6
  201b78:	4b64      	ldr	r3, [pc, #400]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  WR_Hi;
  201b7a:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201b7e:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201b80:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201b84:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201b88:	8365      	strh	r5, [r4, #26]
  WR_low;
  201b8a:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201b8e:	f8c3 a014 	str.w	sl, [r3, #20]
  201b92:	f388 8811 	msr	BASEPRI, r8
  201b96:	2008      	movs	r0, #8
  201b98:	4639      	mov	r1, r7
  201b9a:	f7ff f949 	bl	200e30 <chSchGoSleepTimeoutS>
  201b9e:	f386 8811 	msr	BASEPRI, r6
  Data_Port=cmd;
  201ba2:	222b      	movs	r2, #43	; 0x2b
  201ba4:	4b59      	ldr	r3, [pc, #356]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  WR_Hi;
  201ba6:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201baa:	8325      	strh	r5, [r4, #24]
  DC_low;
  201bac:	f8a4 a01a 	strh.w	sl, [r4, #26]
  RD_Hi;
  201bb0:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201bb4:	8365      	strh	r5, [r4, #26]
  WR_low;
  201bb6:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=cmd;
  201bba:	615a      	str	r2, [r3, #20]
  201bbc:	f388 8811 	msr	BASEPRI, r8
  201bc0:	2008      	movs	r0, #8
  201bc2:	4639      	mov	r1, r7
  201bc4:	f7ff f934 	bl	200e30 <chSchGoSleepTimeoutS>
  201bc8:	f386 8811 	msr	BASEPRI, r6
  Data_Port=data;
  201bcc:	4b4f      	ldr	r3, [pc, #316]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  WR_Hi;
  201bce:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201bd2:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201bd4:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201bd8:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201bdc:	8365      	strh	r5, [r4, #26]
  WR_low;
  201bde:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201be2:	615e      	str	r6, [r3, #20]
  201be4:	f388 8811 	msr	BASEPRI, r8
  201be8:	2008      	movs	r0, #8
  201bea:	4639      	mov	r1, r7
  201bec:	f7ff f920 	bl	200e30 <chSchGoSleepTimeoutS>
  201bf0:	f386 8811 	msr	BASEPRI, r6
  201bf4:	4b45      	ldr	r3, [pc, #276]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  201bf6:	9a01      	ldr	r2, [sp, #4]
  WR_Hi;
  201bf8:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201bfc:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201bfe:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201c02:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201c06:	8365      	strh	r5, [r4, #26]
  WR_low;
  201c08:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201c0c:	615a      	str	r2, [r3, #20]
  201c0e:	f388 8811 	msr	BASEPRI, r8
  201c12:	2008      	movs	r0, #8
  201c14:	4639      	mov	r1, r7
  201c16:	f7ff f90b 	bl	200e30 <chSchGoSleepTimeoutS>
  201c1a:	f386 8811 	msr	BASEPRI, r6
  201c1e:	4b3b      	ldr	r3, [pc, #236]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  WR_Hi;
  201c20:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201c24:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201c26:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201c2a:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201c2e:	8365      	strh	r5, [r4, #26]
  WR_low;
  201c30:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201c34:	615e      	str	r6, [r3, #20]
  201c36:	f388 8811 	msr	BASEPRI, r8
  201c3a:	2008      	movs	r0, #8
  201c3c:	4639      	mov	r1, r7
  201c3e:	f7ff f8f7 	bl	200e30 <chSchGoSleepTimeoutS>
  201c42:	f386 8811 	msr	BASEPRI, r6
  201c46:	4b31      	ldr	r3, [pc, #196]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  201c48:	9a01      	ldr	r2, [sp, #4]
  WR_Hi;
  201c4a:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201c4e:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201c50:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201c54:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201c58:	8365      	strh	r5, [r4, #26]
  WR_low;
  201c5a:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=data;
  201c5e:	615a      	str	r2, [r3, #20]
  201c60:	f388 8811 	msr	BASEPRI, r8
  201c64:	2008      	movs	r0, #8
  201c66:	4639      	mov	r1, r7
  201c68:	f7ff f8e2 	bl	200e30 <chSchGoSleepTimeoutS>
  201c6c:	f386 8811 	msr	BASEPRI, r6
  Data_Port=cmd;
  201c70:	222c      	movs	r2, #44	; 0x2c
  201c72:	4b26      	ldr	r3, [pc, #152]	; (201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>)
  WR_Hi;
  201c74:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201c78:	8325      	strh	r5, [r4, #24]
  DC_low;
  201c7a:	f8a4 a01a 	strh.w	sl, [r4, #26]
  RD_Hi;
  201c7e:	f8a4 9018 	strh.w	r9, [r4, #24]
  CS_low;
  201c82:	8365      	strh	r5, [r4, #26]
  WR_low;
  201c84:	f8a4 b01a 	strh.w	fp, [r4, #26]
  Data_Port=cmd;
  201c88:	615a      	str	r2, [r3, #20]
  201c8a:	f388 8811 	msr	BASEPRI, r8
  201c8e:	2008      	movs	r0, #8
  201c90:	4639      	mov	r1, r7
  201c92:	f7ff f8cd 	bl	200e30 <chSchGoSleepTimeoutS>
  201c96:	f386 8811 	msr	BASEPRI, r6
  CS_Hi;
  201c9a:	f44f 78a0 	mov.w	r8, #320	; 0x140
  WR_Hi;
  201c9e:	f8a4 b018 	strh.w	fp, [r4, #24]
  CS_Hi;
  201ca2:	8325      	strh	r5, [r4, #24]
  RD_Hi;
  201ca4:	2204      	movs	r2, #4
  CS_low;
  201ca6:	2510      	movs	r5, #16
  WR_low;
  201ca8:	2602      	movs	r6, #2
  Data_Port=data;
  201caa:	f8df b060 	ldr.w	fp, [pc, #96]	; 201d0c <TFT_Draw_Horizontal_Line.constprop.0+0x24c>
  201cae:	2700      	movs	r7, #0
  DC_Hi;
  201cb0:	f04f 0340 	mov.w	r3, #64	; 0x40
  201cb4:	f04f 0920 	mov.w	r9, #32
  201cb8:	8323      	strh	r3, [r4, #24]
  RD_Hi;
  201cba:	8322      	strh	r2, [r4, #24]
  CS_low;
  201cbc:	8365      	strh	r5, [r4, #26]
  WR_low;
  201cbe:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201cc0:	f8cb 7014 	str.w	r7, [fp, #20]
  201cc4:	f389 8811 	msr	BASEPRI, r9
  201cc8:	2101      	movs	r1, #1
  201cca:	2008      	movs	r0, #8
  201ccc:	f7ff f8b0 	bl	200e30 <chSchGoSleepTimeoutS>
  201cd0:	f387 8811 	msr	BASEPRI, r7
  RD_Hi;
  201cd4:	2204      	movs	r2, #4
  WR_Hi;
  201cd6:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  201cd8:	8325      	strh	r5, [r4, #24]
  DC_Hi;
  201cda:	f8a4 a018 	strh.w	sl, [r4, #24]
  RD_Hi;
  201cde:	8322      	strh	r2, [r4, #24]
  CS_low;
  201ce0:	8365      	strh	r5, [r4, #26]
  WR_low;
  201ce2:	8366      	strh	r6, [r4, #26]
  Data_Port=data;
  201ce4:	f8cb 7014 	str.w	r7, [fp, #20]
  201ce8:	f389 8811 	msr	BASEPRI, r9
  201cec:	2101      	movs	r1, #1
  201cee:	2008      	movs	r0, #8
  201cf0:	f7ff f89e 	bl	200e30 <chSchGoSleepTimeoutS>
  201cf4:	f387 8811 	msr	BASEPRI, r7
	for( i=0; i<length; i++)
  201cf8:	f1b8 0801 	subs.w	r8, r8, #1
  WR_Hi;
  201cfc:	8326      	strh	r6, [r4, #24]
  CS_Hi;
  201cfe:	8325      	strh	r5, [r4, #24]
	for( i=0; i<length; i++)
  201d00:	d1d0      	bne.n	201ca4 <TFT_Draw_Horizontal_Line.constprop.0+0x1e4>
}
  201d02:	b003      	add	sp, #12
  201d04:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  201d08:	40020400 	.word	0x40020400
  201d0c:	40020c00 	.word	0x40020c00

00201d10 <chSchWakeupS.constprop.0>:
  thread_t *otp = currp;
  201d10:	4a14      	ldr	r2, [pc, #80]	; (201d64 <chSchWakeupS.constprop.0+0x54>)
  201d12:	6991      	ldr	r1, [r2, #24]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  201d14:	b470      	push	{r4, r5, r6}
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
  201d16:	6885      	ldr	r5, [r0, #8]
  ntp->u.rdymsg = msg;
  201d18:	2600      	movs	r6, #0
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
  201d1a:	688c      	ldr	r4, [r1, #8]
  ntp->u.rdymsg = msg;
  201d1c:	6246      	str	r6, [r0, #36]	; 0x24
  if (ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio) {
  201d1e:	42a5      	cmp	r5, r4
  201d20:	d912      	bls.n	201d48 <chSchWakeupS.constprop.0+0x38>
  return (thread_t *)ch_pqueue_insert_ahead(&ch.rlist.pqueue,
  201d22:	4613      	mov	r3, r2
  tp->state = CH_STATE_READY;
  201d24:	f881 6020 	strb.w	r6, [r1, #32]
static inline ch_priority_queue_t *ch_pqueue_insert_ahead(ch_priority_queue_t *pqp,
                                                          ch_priority_queue_t *p) {

  /* Scanning priority queue.*/
  do {
    pqp = pqp->next;
  201d28:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio > p->prio);
  201d2a:	689d      	ldr	r5, [r3, #8]
  201d2c:	42ac      	cmp	r4, r5
  201d2e:	d3fb      	bcc.n	201d28 <chSchWakeupS.constprop.0+0x18>

  /* Insertion on prev.*/
  p->next       = pqp;
  p->prev       = pqp->prev;
  201d30:	685c      	ldr	r4, [r3, #4]
  201d32:	e9c1 3400 	strd	r3, r4, [r1]
  p->prev->next = p;
  201d36:	6021      	str	r1, [r4, #0]
    ntp->state = CH_STATE_CURRENT;
  201d38:	2401      	movs	r4, #1
  pqp->prev     = p;
  201d3a:	6059      	str	r1, [r3, #4]
  201d3c:	f880 4020 	strb.w	r4, [r0, #32]
    currp = ntp;
  201d40:	6190      	str	r0, [r2, #24]
}
  201d42:	bc70      	pop	{r4, r5, r6}
    chSysSwitch(ntp, otp);
  201d44:	f7fe bacc 	b.w	2002e0 <_port_switch>
  return (thread_t *)ch_pqueue_insert_behind(&ch.rlist.pqueue,
  201d48:	4613      	mov	r3, r2
  tp->state = CH_STATE_READY;
  201d4a:	f880 6020 	strb.w	r6, [r0, #32]
    pqp = pqp->next;
  201d4e:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  201d50:	689a      	ldr	r2, [r3, #8]
  201d52:	4295      	cmp	r5, r2
  201d54:	d9fb      	bls.n	201d4e <chSchWakeupS.constprop.0+0x3e>
  p->prev       = pqp->prev;
  201d56:	685a      	ldr	r2, [r3, #4]
}
  201d58:	bc70      	pop	{r4, r5, r6}
  201d5a:	e9c0 3200 	strd	r3, r2, [r0]
  p->prev->next = p;
  201d5e:	6010      	str	r0, [r2, #0]
  pqp->prev     = p;
  201d60:	6058      	str	r0, [r3, #4]
  201d62:	4770      	bx	lr
  201d64:	200009d0 	.word	0x200009d0
	...

00201d70 <chThdCreateStatic.constprop.0.isra.0>:
thread_t *chThdCreateStatic(void *wsp, size_t size,
  201d70:	b570      	push	{r4, r5, r6, lr}
  201d72:	4605      	mov	r5, r0
  201d74:	2020      	movs	r0, #32
  201d76:	f380 8811 	msr	BASEPRI, r0
  tp = (thread_t *)((uint8_t *)wsp + size -
  201d7a:	3948      	subs	r1, #72	; 0x48
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201d7c:	4e14      	ldr	r6, [pc, #80]	; (201dd0 <chThdCreateStatic.constprop.0.isra.0+0x60>)
  201d7e:	2400      	movs	r4, #0
  tp = (thread_t *)((uint8_t *)wsp + size -
  201d80:	1868      	adds	r0, r5, r1
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201d82:	f1a0 0124 	sub.w	r1, r0, #36	; 0x24
  201d86:	f840 3c24 	str.w	r3, [r0, #-36]
  REG_INSERT(tp);
  201d8a:	4b12      	ldr	r3, [pc, #72]	; (201dd4 <chThdCreateStatic.constprop.0.isra.0+0x64>)
  tp->wabase = (stkalign_t *)wsp;
  201d8c:	61c5      	str	r5, [r0, #28]
  ch_list_init(&tp->waiting);
  201d8e:	f100 0528 	add.w	r5, r0, #40	; 0x28
  tp->realprio        = prio;
  201d92:	63c2      	str	r2, [r0, #60]	; 0x3c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201d94:	f840 4c20 	str.w	r4, [r0, #-32]
  REG_INSERT(tp);
  201d98:	6103      	str	r3, [r0, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201d9a:	e9c0 2102 	strd	r2, r1, [r0, #8]
  tp->state           = CH_STATE_WTSTART;
  201d9e:	2102      	movs	r1, #2
  ch_queue_init(&tp->msgqueue);
  201da0:	f100 022c 	add.w	r2, r0, #44	; 0x2c
  tp->state           = CH_STATE_WTSTART;
  201da4:	8401      	strh	r1, [r0, #32]
  REG_INSERT(tp);
  201da6:	6959      	ldr	r1, [r3, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  201da8:	f840 6c04 	str.w	r6, [r0, #-4]
  tp->refs            = (trefs_t)1;
  201dac:	2601      	movs	r6, #1
  REG_INSERT(tp);
  201dae:	6141      	str	r1, [r0, #20]
  tp->refs            = (trefs_t)1;
  201db0:	f880 6022 	strb.w	r6, [r0, #34]	; 0x22
  tp->name            = name;
  201db4:	4e08      	ldr	r6, [pc, #32]	; (201dd8 <chThdCreateStatic.constprop.0.isra.0+0x68>)
  tp->epending        = (eventmask_t)0;
  201db6:	e9c0 440d 	strd	r4, r4, [r0, #52]	; 0x34
  tp->name            = name;
  201dba:	6186      	str	r6, [r0, #24]
  REG_INSERT(tp);
  201dbc:	6108      	str	r0, [r1, #16]
  qp->prev = qp;
  201dbe:	6302      	str	r2, [r0, #48]	; 0x30
  201dc0:	6158      	str	r0, [r3, #20]
  qp->next = qp;
  201dc2:	e9c0 520a 	strd	r5, r2, [r0, #40]	; 0x28
  chSchWakeupS(tp, MSG_OK);
  201dc6:	f7ff ffa3 	bl	201d10 <chSchWakeupS.constprop.0>
  201dca:	f384 8811 	msr	BASEPRI, r4
}
  201dce:	bd70      	pop	{r4, r5, r6, pc}
  201dd0:	002002f1 	.word	0x002002f1
  201dd4:	200009d0 	.word	0x200009d0
  201dd8:	08005aac 	.word	0x08005aac
  201ddc:	00000000 	.word	0x00000000

00201de0 <Menu_Disp>:
{
  201de0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  TFT_Fill_Screen(0,320,0,200,WHITE);
  201de4:	2200      	movs	r2, #0
{
  201de6:	b088      	sub	sp, #32
  TFT_Fill_Screen(0,320,0,200,WHITE);
  201de8:	f64f 74ff 	movw	r4, #65535	; 0xffff
  201dec:	23c8      	movs	r3, #200	; 0xc8
  201dee:	f44f 71a0 	mov.w	r1, #320	; 0x140
  201df2:	4610      	mov	r0, r2
  201df4:	9400      	str	r4, [sp, #0]
  201df6:	f7ff fadb 	bl	2013b0 <TFT_Fill_Screen>
  i=current;
  201dfa:	4b4c      	ldr	r3, [pc, #304]	; (201f2c <Menu_Disp+0x14c>)
  201dfc:	681b      	ldr	r3, [r3, #0]
  while(i->prev!=NULL)
  201dfe:	461f      	mov	r7, r3
  201e00:	68db      	ldr	r3, [r3, #12]
  201e02:	2b00      	cmp	r3, #0
  201e04:	d1fb      	bne.n	201dfe <Menu_Disp+0x1e>
  if(i->starttext!=NULL)
  201e06:	687d      	ldr	r5, [r7, #4]
  201e08:	b31d      	cbz	r5, 201e52 <Menu_Disp+0x72>
	while(*string)
  201e0a:	782b      	ldrb	r3, [r5, #0]
  201e0c:	b1db      	cbz	r3, 201e46 <Menu_Disp+0x66>
  201e0e:	260a      	movs	r6, #10
  201e10:	f8df 911c 	ldr.w	r9, [pc, #284]	; 201f30 <Menu_Disp+0x150>
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201e14:	f04f 0802 	mov.w	r8, #2
	while(*string)
  201e18:	4634      	mov	r4, r6
  201e1a:	e00a      	b.n	201e32 <Menu_Disp+0x52>
		x += FONT_X*size;     
  201e1c:	4620      	mov	r0, r4
  201e1e:	3410      	adds	r4, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201e20:	2200      	movs	r2, #0
  201e22:	4631      	mov	r1, r6
  201e24:	f8cd 8000 	str.w	r8, [sp]
  201e28:	f7ff fc32 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  201e2c:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  201e30:	b14b      	cbz	r3, 201e46 <Menu_Disp+0x66>
		if((x + FONT_X) > MAX_X)
  201e32:	f104 0208 	add.w	r2, r4, #8
  201e36:	f8d9 1000 	ldr.w	r1, [r9]
			x = 1;
  201e3a:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  201e3c:	428a      	cmp	r2, r1
  201e3e:	d9ed      	bls.n	201e1c <Menu_Disp+0x3c>
			y = y + FONT_X*size;
  201e40:	3610      	adds	r6, #16
  201e42:	2411      	movs	r4, #17
  201e44:	e7ec      	b.n	201e20 <Menu_Disp+0x40>
    TFT_Draw_Horizontal_Line(0,30,320,BLACK);
  201e46:	201e      	movs	r0, #30
  201e48:	f7ff fe3a 	bl	201ac0 <TFT_Draw_Horizontal_Line.constprop.0>
    TFT_Draw_Horizontal_Line(0,31,320,BLACK);
  201e4c:	201f      	movs	r0, #31
  201e4e:	f7ff fe37 	bl	201ac0 <TFT_Draw_Horizontal_Line.constprop.0>
  201e52:	4e37      	ldr	r6, [pc, #220]	; (201f30 <Menu_Disp+0x150>)
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201e54:	f04f 0901 	mov.w	r9, #1
      if(i->bool_value!=NULL)
  201e58:	6a7d      	ldr	r5, [r7, #36]	; 0x24
  201e5a:	b1d5      	cbz	r5, 201e92 <Menu_Disp+0xb2>
        TFT_Draw_String(i->x_pos+220,i->y_pos, BLUE, WHITE, i->bool_value, 1);
  201e5c:	69fc      	ldr	r4, [r7, #28]
	while(*string)
  201e5e:	782b      	ldrb	r3, [r5, #0]
  201e60:	f8d7 8020 	ldr.w	r8, [r7, #32]
  201e64:	34dc      	adds	r4, #220	; 0xdc
  201e66:	b1a3      	cbz	r3, 201e92 <Menu_Disp+0xb2>
		if((x + FONT_X) > MAX_X)
  201e68:	f104 0208 	add.w	r2, r4, #8
  201e6c:	6831      	ldr	r1, [r6, #0]
  201e6e:	4620      	mov	r0, r4
  201e70:	428a      	cmp	r2, r1
  201e72:	4614      	mov	r4, r2
  201e74:	d903      	bls.n	201e7e <Menu_Disp+0x9e>
			y = y + FONT_X*size;
  201e76:	f108 0808 	add.w	r8, r8, #8
  201e7a:	2409      	movs	r4, #9
			x = 1;
  201e7c:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201e7e:	221f      	movs	r2, #31
  201e80:	4641      	mov	r1, r8
  201e82:	f8cd 9000 	str.w	r9, [sp]
  201e86:	f7ff fc03 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  201e8a:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  201e8e:	2b00      	cmp	r3, #0
  201e90:	d1ea      	bne.n	201e68 <Menu_Disp+0x88>
      if(i->menu_value!=-1)
  201e92:	f9b7 2028 	ldrsh.w	r2, [r7, #40]	; 0x28
  201e96:	1c53      	adds	r3, r2, #1
  201e98:	d024      	beq.n	201ee4 <Menu_Disp+0x104>
        sprintf(String,"%d",i->menu_value);
  201e9a:	4926      	ldr	r1, [pc, #152]	; (201f34 <Menu_Disp+0x154>)
  201e9c:	a803      	add	r0, sp, #12
  201e9e:	f003 fa91 	bl	2053c4 <siprintf>
        TFT_Draw_String(i->x_pos+150,i->y_pos, BLUE, WHITE,String , 2);
  201ea2:	69fc      	ldr	r4, [r7, #28]
  201ea4:	f89d 300c 	ldrb.w	r3, [sp, #12]
  201ea8:	f8d7 a020 	ldr.w	sl, [r7, #32]
  201eac:	f104 0596 	add.w	r5, r4, #150	; 0x96
  201eb0:	b1d3      	cbz	r3, 201ee8 <Menu_Disp+0x108>
  201eb2:	ac03      	add	r4, sp, #12
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201eb4:	f04f 0802 	mov.w	r8, #2
  201eb8:	e00a      	b.n	201ed0 <Menu_Disp+0xf0>
		x += FONT_X*size;     
  201eba:	4628      	mov	r0, r5
  201ebc:	3510      	adds	r5, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201ebe:	221f      	movs	r2, #31
  201ec0:	4651      	mov	r1, sl
  201ec2:	f8cd 8000 	str.w	r8, [sp]
  201ec6:	f7ff fbe3 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  201eca:	f814 3f01 	ldrb.w	r3, [r4, #1]!
  201ece:	b14b      	cbz	r3, 201ee4 <Menu_Disp+0x104>
		if((x + FONT_X) > MAX_X)
  201ed0:	f105 0208 	add.w	r2, r5, #8
  201ed4:	6831      	ldr	r1, [r6, #0]
			x = 1;
  201ed6:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  201ed8:	428a      	cmp	r2, r1
  201eda:	d9ee      	bls.n	201eba <Menu_Disp+0xda>
			y = y + FONT_X*size;
  201edc:	f10a 0a10 	add.w	sl, sl, #16
  201ee0:	2511      	movs	r5, #17
  201ee2:	e7ec      	b.n	201ebe <Menu_Disp+0xde>
      TFT_Draw_String(i->x_pos,i->y_pos, BLACK, WHITE, i->text, 2);
  201ee4:	e9d7 4a07 	ldrd	r4, sl, [r7, #28]
  201ee8:	683d      	ldr	r5, [r7, #0]
	while(*string)
  201eea:	782b      	ldrb	r3, [r5, #0]
  201eec:	b1bb      	cbz	r3, 201f1e <Menu_Disp+0x13e>
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201eee:	f04f 0802 	mov.w	r8, #2
  201ef2:	e00a      	b.n	201f0a <Menu_Disp+0x12a>
		x += FONT_X*size;     
  201ef4:	4620      	mov	r0, r4
  201ef6:	3410      	adds	r4, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  201ef8:	2200      	movs	r2, #0
  201efa:	4651      	mov	r1, sl
  201efc:	f8cd 8000 	str.w	r8, [sp]
  201f00:	f7ff fbc6 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  201f04:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  201f08:	b14b      	cbz	r3, 201f1e <Menu_Disp+0x13e>
		if((x + FONT_X) > MAX_X)
  201f0a:	f104 0208 	add.w	r2, r4, #8
  201f0e:	6831      	ldr	r1, [r6, #0]
			x = 1;
  201f10:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  201f12:	428a      	cmp	r2, r1
  201f14:	d9ee      	bls.n	201ef4 <Menu_Disp+0x114>
			y = y + FONT_X*size;
  201f16:	f10a 0a10 	add.w	sl, sl, #16
  201f1a:	2411      	movs	r4, #17
  201f1c:	e7ec      	b.n	201ef8 <Menu_Disp+0x118>
      i=i->next;
  201f1e:	693f      	ldr	r7, [r7, #16]
  while(i!=NULL)
  201f20:	2f00      	cmp	r7, #0
  201f22:	d199      	bne.n	201e58 <Menu_Disp+0x78>
}
  201f24:	b008      	add	sp, #32
  201f26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  201f2a:	bf00      	nop
  201f2c:	20000ef0 	.word	0x20000ef0
  201f30:	20000820 	.word	0x20000820
  201f34:	08005ab4 	.word	0x08005ab4
	...

00201f40 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
  201f40:	b510      	push	{r4, lr}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  201f42:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  201f46:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  201f4a:	481c      	ldr	r0, [pc, #112]	; (201fbc <__core_init+0x7c>)
  201f4c:	2200      	movs	r2, #0
  201f4e:	f8c0 2250 	str.w	r2, [r0, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
  201f52:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  201f56:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  201f5a:	6943      	ldr	r3, [r0, #20]
  201f5c:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  201f60:	6143      	str	r3, [r0, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  201f62:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  201f66:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U; /*(0U << 1U) | 0U;*/  /* Level 1 data cache */
  201f6a:	f8c0 2084 	str.w	r2, [r0, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  201f6e:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
  201f72:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  201f76:	f643 74e0 	movw	r4, #16352	; 0x3fe0
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  201f7a:	f3c3 3c4e 	ubfx	ip, r3, #13, #15
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  201f7e:	f3c3 0ec9 	ubfx	lr, r3, #3, #10
  201f82:	ea4f 1c4c 	mov.w	ip, ip, lsl #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  201f86:	ea0c 0104 	and.w	r1, ip, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  201f8a:	4673      	mov	r3, lr
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  201f8c:	ea41 7283 	orr.w	r2, r1, r3, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
  201f90:	3b01      	subs	r3, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  201f92:	f8c0 2260 	str.w	r2, [r0, #608]	; 0x260
      } while (ways-- != 0U);
  201f96:	1c5a      	adds	r2, r3, #1
  201f98:	d1f8      	bne.n	201f8c <__core_init+0x4c>
    } while(sets-- != 0U);
  201f9a:	f1ac 0c20 	sub.w	ip, ip, #32
  201f9e:	f11c 0f20 	cmn.w	ip, #32
  201fa2:	d1f0      	bne.n	201f86 <__core_init+0x46>
  201fa4:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  201fa8:	6943      	ldr	r3, [r0, #20]
  201faa:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  201fae:	6143      	str	r3, [r0, #20]
  201fb0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  201fb4:	f3bf 8f6f 	isb	sy

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
  201fb8:	bd10      	pop	{r4, pc}
  201fba:	bf00      	nop
  201fbc:	e000ed00 	.word	0xe000ed00

00201fc0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
  201fc0:	4770      	bx	lr
  201fc2:	bf00      	nop
	...

00201fd0 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  201fd0:	e7fe      	b.n	201fd0 <__default_exit>
  201fd2:	bf00      	nop
	...

00201fe0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
  201fe0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  201fe2:	4d15      	ldr	r5, [pc, #84]	; (202038 <__init_ram_areas+0x58>)
  201fe4:	4f15      	ldr	r7, [pc, #84]	; (20203c <__init_ram_areas+0x5c>)
  201fe6:	4916      	ldr	r1, [pc, #88]	; (202040 <__init_ram_areas+0x60>)
  201fe8:	f105 0470 	add.w	r4, r5, #112	; 0x70
  201fec:	4815      	ldr	r0, [pc, #84]	; (202044 <__init_ram_areas+0x64>)
  201fee:	4a16      	ldr	r2, [pc, #88]	; (202048 <__init_ram_areas+0x68>)
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
  201ff0:	4281      	cmp	r1, r0
  201ff2:	d90d      	bls.n	202010 <__init_ram_areas+0x30>
  201ff4:	3a04      	subs	r2, #4
  201ff6:	4603      	mov	r3, r0
      *p = *tp;
  201ff8:	f852 6f04 	ldr.w	r6, [r2, #4]!
  201ffc:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->clear_area) {
  202000:	4299      	cmp	r1, r3
  202002:	d8f9      	bhi.n	201ff8 <__init_ram_areas+0x18>
      p++;
  202004:	1e4b      	subs	r3, r1, #1
  202006:	1a1b      	subs	r3, r3, r0
  202008:	f023 0303 	bic.w	r3, r3, #3
  20200c:	3304      	adds	r3, #4
  20200e:	4418      	add	r0, r3
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
  202010:	4287      	cmp	r7, r0
  202012:	d907      	bls.n	202024 <__init_ram_areas+0x44>
      *p = 0;
  202014:	3f01      	subs	r7, #1
  202016:	2100      	movs	r1, #0
  202018:	1a3f      	subs	r7, r7, r0
  20201a:	f027 0203 	bic.w	r2, r7, #3
  20201e:	3204      	adds	r2, #4
  202020:	f003 f914 	bl	20524c <memset>
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
  202024:	42a5      	cmp	r5, r4
  202026:	d005      	beq.n	202034 <__init_ram_areas+0x54>
    uint32_t *p = rap->init_area;
  202028:	e9d5 2004 	ldrd	r2, r0, [r5, #16]
    while (p < rap->no_init_area) {
  20202c:	e9d5 1706 	ldrd	r1, r7, [r5, #24]
  202030:	3510      	adds	r5, #16
  202032:	e7dd      	b.n	201ff0 <__init_ram_areas+0x10>
#endif
}
  202034:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  202036:	bf00      	nop
  202038:	08005c74 	.word	0x08005c74
  20203c:	200200d0 	.word	0x200200d0
  202040:	200200d0 	.word	0x200200d0
  202044:	200200d0 	.word	0x200200d0
  202048:	08006120 	.word	0x08006120
  20204c:	00000000 	.word	0x00000000

00202050 <Vector58>:
OSAL_IRQ_HANDLER(STM32_EXTI0_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 0, pr);
  202050:	4a14      	ldr	r2, [pc, #80]	; (2020a4 <Vector58+0x54>)
OSAL_IRQ_HANDLER(STM32_EXTI0_HANDLER) {
  202052:	b508      	push	{r3, lr}
  extiGetAndClearGroup1(1U << 0, pr);
  202054:	6953      	ldr	r3, [r2, #20]
  202056:	f003 0301 	and.w	r3, r3, #1
  20205a:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 0);
  20205c:	b123      	cbz	r3, 202068 <Vector58+0x18>
  20205e:	4a12      	ldr	r2, [pc, #72]	; (2020a8 <Vector58+0x58>)
  202060:	6813      	ldr	r3, [r2, #0]
  202062:	b10b      	cbz	r3, 202068 <Vector58+0x18>
  202064:	6850      	ldr	r0, [r2, #4]
  202066:	4798      	blx	r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202068:	2320      	movs	r3, #32
  20206a:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  20206e:	4b0f      	ldr	r3, [pc, #60]	; (2020ac <Vector58+0x5c>)
  202070:	685b      	ldr	r3, [r3, #4]
  202072:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202076:	d102      	bne.n	20207e <Vector58+0x2e>
  202078:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  20207c:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  20207e:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202082:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202086:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202088:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  20208a:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  20208e:	4a08      	ldr	r2, [pc, #32]	; (2020b0 <Vector58+0x60>)
  202090:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202092:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202094:	6889      	ldr	r1, [r1, #8]
  202096:	6892      	ldr	r2, [r2, #8]
  202098:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  20209a:	bf8c      	ite	hi
  20209c:	4a05      	ldrhi	r2, [pc, #20]	; (2020b4 <Vector58+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  20209e:	4a06      	ldrls	r2, [pc, #24]	; (2020b8 <Vector58+0x68>)
  2020a0:	619a      	str	r2, [r3, #24]
  2020a2:	bd08      	pop	{r3, pc}
  2020a4:	40013c00 	.word	0x40013c00
  2020a8:	200008e8 	.word	0x200008e8
  2020ac:	e000ed00 	.word	0xe000ed00
  2020b0:	200009d0 	.word	0x200009d0
  2020b4:	00200303 	.word	0x00200303
  2020b8:	00200306 	.word	0x00200306
  2020bc:	00000000 	.word	0x00000000

002020c0 <Vector5C>:
OSAL_IRQ_HANDLER(STM32_EXTI1_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 1, pr);
  2020c0:	4a14      	ldr	r2, [pc, #80]	; (202114 <Vector5C+0x54>)
OSAL_IRQ_HANDLER(STM32_EXTI1_HANDLER) {
  2020c2:	b508      	push	{r3, lr}
  extiGetAndClearGroup1(1U << 1, pr);
  2020c4:	6953      	ldr	r3, [r2, #20]
  2020c6:	f003 0302 	and.w	r3, r3, #2
  2020ca:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 1);
  2020cc:	b123      	cbz	r3, 2020d8 <Vector5C+0x18>
  2020ce:	4a12      	ldr	r2, [pc, #72]	; (202118 <Vector5C+0x58>)
  2020d0:	6893      	ldr	r3, [r2, #8]
  2020d2:	b10b      	cbz	r3, 2020d8 <Vector5C+0x18>
  2020d4:	68d0      	ldr	r0, [r2, #12]
  2020d6:	4798      	blx	r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2020d8:	2320      	movs	r3, #32
  2020da:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2020de:	4b0f      	ldr	r3, [pc, #60]	; (20211c <Vector5C+0x5c>)
  2020e0:	685b      	ldr	r3, [r3, #4]
  2020e2:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2020e6:	d102      	bne.n	2020ee <Vector5C+0x2e>
  2020e8:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  2020ec:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2020ee:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  2020f2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  2020f6:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2020f8:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2020fa:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2020fe:	4a08      	ldr	r2, [pc, #32]	; (202120 <Vector5C+0x60>)
  202100:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202102:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202104:	6889      	ldr	r1, [r1, #8]
  202106:	6892      	ldr	r2, [r2, #8]
  202108:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  20210a:	bf8c      	ite	hi
  20210c:	4a05      	ldrhi	r2, [pc, #20]	; (202124 <Vector5C+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  20210e:	4a06      	ldrls	r2, [pc, #24]	; (202128 <Vector5C+0x68>)
  202110:	619a      	str	r2, [r3, #24]
  202112:	bd08      	pop	{r3, pc}
  202114:	40013c00 	.word	0x40013c00
  202118:	200008e8 	.word	0x200008e8
  20211c:	e000ed00 	.word	0xe000ed00
  202120:	200009d0 	.word	0x200009d0
  202124:	00200303 	.word	0x00200303
  202128:	00200306 	.word	0x00200306
  20212c:	00000000 	.word	0x00000000

00202130 <Vector60>:
OSAL_IRQ_HANDLER(STM32_EXTI2_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 2, pr);
  202130:	4a14      	ldr	r2, [pc, #80]	; (202184 <Vector60+0x54>)
OSAL_IRQ_HANDLER(STM32_EXTI2_HANDLER) {
  202132:	b508      	push	{r3, lr}
  extiGetAndClearGroup1(1U << 2, pr);
  202134:	6953      	ldr	r3, [r2, #20]
  202136:	f003 0304 	and.w	r3, r3, #4
  20213a:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 2);
  20213c:	b123      	cbz	r3, 202148 <Vector60+0x18>
  20213e:	4a12      	ldr	r2, [pc, #72]	; (202188 <Vector60+0x58>)
  202140:	6913      	ldr	r3, [r2, #16]
  202142:	b10b      	cbz	r3, 202148 <Vector60+0x18>
  202144:	6950      	ldr	r0, [r2, #20]
  202146:	4798      	blx	r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202148:	2320      	movs	r3, #32
  20214a:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  20214e:	4b0f      	ldr	r3, [pc, #60]	; (20218c <Vector60+0x5c>)
  202150:	685b      	ldr	r3, [r3, #4]
  202152:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202156:	d102      	bne.n	20215e <Vector60+0x2e>
  202158:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  20215c:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  20215e:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202162:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202166:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202168:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  20216a:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  20216e:	4a08      	ldr	r2, [pc, #32]	; (202190 <Vector60+0x60>)
  202170:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202172:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202174:	6889      	ldr	r1, [r1, #8]
  202176:	6892      	ldr	r2, [r2, #8]
  202178:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  20217a:	bf8c      	ite	hi
  20217c:	4a05      	ldrhi	r2, [pc, #20]	; (202194 <Vector60+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  20217e:	4a06      	ldrls	r2, [pc, #24]	; (202198 <Vector60+0x68>)
  202180:	619a      	str	r2, [r3, #24]
  202182:	bd08      	pop	{r3, pc}
  202184:	40013c00 	.word	0x40013c00
  202188:	200008e8 	.word	0x200008e8
  20218c:	e000ed00 	.word	0xe000ed00
  202190:	200009d0 	.word	0x200009d0
  202194:	00200303 	.word	0x00200303
  202198:	00200306 	.word	0x00200306
  20219c:	00000000 	.word	0x00000000

002021a0 <Vector64>:
OSAL_IRQ_HANDLER(STM32_EXTI3_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 3, pr);
  2021a0:	4a14      	ldr	r2, [pc, #80]	; (2021f4 <Vector64+0x54>)
OSAL_IRQ_HANDLER(STM32_EXTI3_HANDLER) {
  2021a2:	b508      	push	{r3, lr}
  extiGetAndClearGroup1(1U << 3, pr);
  2021a4:	6953      	ldr	r3, [r2, #20]
  2021a6:	f003 0308 	and.w	r3, r3, #8
  2021aa:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 3);
  2021ac:	b123      	cbz	r3, 2021b8 <Vector64+0x18>
  2021ae:	4a12      	ldr	r2, [pc, #72]	; (2021f8 <Vector64+0x58>)
  2021b0:	6993      	ldr	r3, [r2, #24]
  2021b2:	b10b      	cbz	r3, 2021b8 <Vector64+0x18>
  2021b4:	69d0      	ldr	r0, [r2, #28]
  2021b6:	4798      	blx	r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2021b8:	2320      	movs	r3, #32
  2021ba:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2021be:	4b0f      	ldr	r3, [pc, #60]	; (2021fc <Vector64+0x5c>)
  2021c0:	685b      	ldr	r3, [r3, #4]
  2021c2:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2021c6:	d102      	bne.n	2021ce <Vector64+0x2e>
  2021c8:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  2021cc:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2021ce:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  2021d2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  2021d6:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2021d8:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2021da:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2021de:	4a08      	ldr	r2, [pc, #32]	; (202200 <Vector64+0x60>)
  2021e0:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  2021e2:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  2021e4:	6889      	ldr	r1, [r1, #8]
  2021e6:	6892      	ldr	r2, [r2, #8]
  2021e8:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  2021ea:	bf8c      	ite	hi
  2021ec:	4a05      	ldrhi	r2, [pc, #20]	; (202204 <Vector64+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  2021ee:	4a06      	ldrls	r2, [pc, #24]	; (202208 <Vector64+0x68>)
  2021f0:	619a      	str	r2, [r3, #24]
  2021f2:	bd08      	pop	{r3, pc}
  2021f4:	40013c00 	.word	0x40013c00
  2021f8:	200008e8 	.word	0x200008e8
  2021fc:	e000ed00 	.word	0xe000ed00
  202200:	200009d0 	.word	0x200009d0
  202204:	00200303 	.word	0x00200303
  202208:	00200306 	.word	0x00200306
  20220c:	00000000 	.word	0x00000000

00202210 <Vector68>:
OSAL_IRQ_HANDLER(STM32_EXTI4_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1(1U << 4, pr);
  202210:	4a14      	ldr	r2, [pc, #80]	; (202264 <Vector68+0x54>)
OSAL_IRQ_HANDLER(STM32_EXTI4_HANDLER) {
  202212:	b508      	push	{r3, lr}
  extiGetAndClearGroup1(1U << 4, pr);
  202214:	6953      	ldr	r3, [r2, #20]
  202216:	f003 0310 	and.w	r3, r3, #16
  20221a:	6153      	str	r3, [r2, #20]

  exti_serve_irq(pr, 4);
  20221c:	b123      	cbz	r3, 202228 <Vector68+0x18>
  20221e:	4a12      	ldr	r2, [pc, #72]	; (202268 <Vector68+0x58>)
  202220:	6a13      	ldr	r3, [r2, #32]
  202222:	b10b      	cbz	r3, 202228 <Vector68+0x18>
  202224:	6a50      	ldr	r0, [r2, #36]	; 0x24
  202226:	4798      	blx	r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202228:	2320      	movs	r3, #32
  20222a:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  20222e:	4b0f      	ldr	r3, [pc, #60]	; (20226c <Vector68+0x5c>)
  202230:	685b      	ldr	r3, [r3, #4]
  202232:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202236:	d102      	bne.n	20223e <Vector68+0x2e>
  202238:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  20223c:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  20223e:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202242:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202246:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202248:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  20224a:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  20224e:	4a08      	ldr	r2, [pc, #32]	; (202270 <Vector68+0x60>)
  202250:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202252:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202254:	6889      	ldr	r1, [r1, #8]
  202256:	6892      	ldr	r2, [r2, #8]
  202258:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  20225a:	bf8c      	ite	hi
  20225c:	4a05      	ldrhi	r2, [pc, #20]	; (202274 <Vector68+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  20225e:	4a06      	ldrls	r2, [pc, #24]	; (202278 <Vector68+0x68>)
  202260:	619a      	str	r2, [r3, #24]
  202262:	bd08      	pop	{r3, pc}
  202264:	40013c00 	.word	0x40013c00
  202268:	200008e8 	.word	0x200008e8
  20226c:	e000ed00 	.word	0xe000ed00
  202270:	200009d0 	.word	0x200009d0
  202274:	00200303 	.word	0x00200303
  202278:	00200306 	.word	0x00200306
  20227c:	00000000 	.word	0x00000000

00202280 <Vector9C>:
OSAL_IRQ_HANDLER(STM32_EXTI5_9_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
  202280:	4b16      	ldr	r3, [pc, #88]	; (2022dc <Vector9C+0x5c>)
OSAL_IRQ_HANDLER(STM32_EXTI5_9_HANDLER) {
  202282:	b510      	push	{r4, lr}
  extiGetAndClearGroup1((1U << 5) | (1U << 6) | (1U << 7) | (1U << 8) |
  202284:	695c      	ldr	r4, [r3, #20]
  202286:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  20228a:	615a      	str	r2, [r3, #20]
                        (1U << 9), pr);

  exti_serve_irq(pr, 5);
  20228c:	06a3      	lsls	r3, r4, #26
  20228e:	d504      	bpl.n	20229a <Vector9C+0x1a>
  202290:	4a13      	ldr	r2, [pc, #76]	; (2022e0 <Vector9C+0x60>)
  202292:	6a93      	ldr	r3, [r2, #40]	; 0x28
  202294:	b10b      	cbz	r3, 20229a <Vector9C+0x1a>
  202296:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
  202298:	4798      	blx	r3
  exti_serve_irq(pr, 6);
  20229a:	0660      	lsls	r0, r4, #25
  20229c:	d504      	bpl.n	2022a8 <Vector9C+0x28>
  20229e:	4a10      	ldr	r2, [pc, #64]	; (2022e0 <Vector9C+0x60>)
  2022a0:	6b13      	ldr	r3, [r2, #48]	; 0x30
  2022a2:	b10b      	cbz	r3, 2022a8 <Vector9C+0x28>
  2022a4:	6b50      	ldr	r0, [r2, #52]	; 0x34
  2022a6:	4798      	blx	r3
  exti_serve_irq(pr, 7);
  2022a8:	0621      	lsls	r1, r4, #24
  2022aa:	d504      	bpl.n	2022b6 <Vector9C+0x36>
  2022ac:	4a0c      	ldr	r2, [pc, #48]	; (2022e0 <Vector9C+0x60>)
  2022ae:	6b93      	ldr	r3, [r2, #56]	; 0x38
  2022b0:	b10b      	cbz	r3, 2022b6 <Vector9C+0x36>
  2022b2:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
  2022b4:	4798      	blx	r3
  exti_serve_irq(pr, 8);
  2022b6:	05e2      	lsls	r2, r4, #23
  2022b8:	d504      	bpl.n	2022c4 <Vector9C+0x44>
  2022ba:	4a09      	ldr	r2, [pc, #36]	; (2022e0 <Vector9C+0x60>)
  2022bc:	6c13      	ldr	r3, [r2, #64]	; 0x40
  2022be:	b10b      	cbz	r3, 2022c4 <Vector9C+0x44>
  2022c0:	6c50      	ldr	r0, [r2, #68]	; 0x44
  2022c2:	4798      	blx	r3
  exti_serve_irq(pr, 9);
  2022c4:	05a3      	lsls	r3, r4, #22
  2022c6:	d504      	bpl.n	2022d2 <Vector9C+0x52>
  2022c8:	4a05      	ldr	r2, [pc, #20]	; (2022e0 <Vector9C+0x60>)
  2022ca:	6c93      	ldr	r3, [r2, #72]	; 0x48
  2022cc:	b10b      	cbz	r3, 2022d2 <Vector9C+0x52>
  2022ce:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
  2022d0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
  2022d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  2022d6:	f7fe b873 	b.w	2003c0 <_port_irq_epilogue>
  2022da:	bf00      	nop
  2022dc:	40013c00 	.word	0x40013c00
  2022e0:	200008e8 	.word	0x200008e8
	...

002022f0 <VectorE0>:
OSAL_IRQ_HANDLER(STM32_EXTI10_15_HANDLER) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  extiGetAndClearGroup1((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
  2022f0:	4b19      	ldr	r3, [pc, #100]	; (202358 <VectorE0+0x68>)
OSAL_IRQ_HANDLER(STM32_EXTI10_15_HANDLER) {
  2022f2:	b510      	push	{r4, lr}
  extiGetAndClearGroup1((1U << 10) | (1U << 11) | (1U << 12) | (1U << 13) |
  2022f4:	695c      	ldr	r4, [r3, #20]
  2022f6:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
  2022fa:	615a      	str	r2, [r3, #20]
                        (1U << 14) | (1U << 15), pr);

  exti_serve_irq(pr, 10);
  2022fc:	0562      	lsls	r2, r4, #21
  2022fe:	d504      	bpl.n	20230a <VectorE0+0x1a>
  202300:	4a16      	ldr	r2, [pc, #88]	; (20235c <VectorE0+0x6c>)
  202302:	6d13      	ldr	r3, [r2, #80]	; 0x50
  202304:	b10b      	cbz	r3, 20230a <VectorE0+0x1a>
  202306:	6d50      	ldr	r0, [r2, #84]	; 0x54
  202308:	4798      	blx	r3
  exti_serve_irq(pr, 11);
  20230a:	0523      	lsls	r3, r4, #20
  20230c:	d504      	bpl.n	202318 <VectorE0+0x28>
  20230e:	4a13      	ldr	r2, [pc, #76]	; (20235c <VectorE0+0x6c>)
  202310:	6d93      	ldr	r3, [r2, #88]	; 0x58
  202312:	b10b      	cbz	r3, 202318 <VectorE0+0x28>
  202314:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
  202316:	4798      	blx	r3
  exti_serve_irq(pr, 12);
  202318:	04e0      	lsls	r0, r4, #19
  20231a:	d504      	bpl.n	202326 <VectorE0+0x36>
  20231c:	4a0f      	ldr	r2, [pc, #60]	; (20235c <VectorE0+0x6c>)
  20231e:	6e13      	ldr	r3, [r2, #96]	; 0x60
  202320:	b10b      	cbz	r3, 202326 <VectorE0+0x36>
  202322:	6e50      	ldr	r0, [r2, #100]	; 0x64
  202324:	4798      	blx	r3
  exti_serve_irq(pr, 13);
  202326:	04a1      	lsls	r1, r4, #18
  202328:	d504      	bpl.n	202334 <VectorE0+0x44>
  20232a:	4a0c      	ldr	r2, [pc, #48]	; (20235c <VectorE0+0x6c>)
  20232c:	6e93      	ldr	r3, [r2, #104]	; 0x68
  20232e:	b10b      	cbz	r3, 202334 <VectorE0+0x44>
  202330:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
  202332:	4798      	blx	r3
  exti_serve_irq(pr, 14);
  202334:	0462      	lsls	r2, r4, #17
  202336:	d504      	bpl.n	202342 <VectorE0+0x52>
  202338:	4a08      	ldr	r2, [pc, #32]	; (20235c <VectorE0+0x6c>)
  20233a:	6f13      	ldr	r3, [r2, #112]	; 0x70
  20233c:	b10b      	cbz	r3, 202342 <VectorE0+0x52>
  20233e:	6f50      	ldr	r0, [r2, #116]	; 0x74
  202340:	4798      	blx	r3
  exti_serve_irq(pr, 15);
  202342:	0423      	lsls	r3, r4, #16
  202344:	d504      	bpl.n	202350 <VectorE0+0x60>
  202346:	4a05      	ldr	r2, [pc, #20]	; (20235c <VectorE0+0x6c>)
  202348:	6f93      	ldr	r3, [r2, #120]	; 0x78
  20234a:	b10b      	cbz	r3, 202350 <VectorE0+0x60>
  20234c:	6fd0      	ldr	r0, [r2, #124]	; 0x7c
  20234e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
  202350:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  OSAL_IRQ_EPILOGUE();
  202354:	f7fe b834 	b.w	2003c0 <_port_irq_epilogue>
  202358:	40013c00 	.word	0x40013c00
  20235c:	200008e8 	.word	0x200008e8

00202360 <VectorDC>:
/**
 * @brief   USART3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART3_HANDLER) {
  202360:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
void sd_lld_serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  202364:	4c7f      	ldr	r4, [pc, #508]	; (202564 <VectorDC+0x204>)
  202366:	f8d4 8054 	ldr.w	r8, [r4, #84]	; 0x54
  uint32_t cr1 = u->CR1;
  20236a:	f8d8 5000 	ldr.w	r5, [r8]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
  20236e:	f8d8 601c 	ldr.w	r6, [r8, #28]
  u->ICR = isr;

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
  202372:	0731      	lsls	r1, r6, #28
  u->ICR = isr;
  202374:	f8c8 6020 	str.w	r6, [r8, #32]
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
  202378:	f040 80ba 	bne.w	2024f0 <VectorDC+0x190>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
  20237c:	05f1      	lsls	r1, r6, #23
  20237e:	f100 80ac 	bmi.w	2024da <VectorDC+0x17a>
  /* Data available, note it is a while in order to handle two situations:
     1) Another byte arrived after removing the previous one, this would cause
        an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to empty
        the FIFO.*/
  while (isr & USART_ISR_RXNE) {
  202382:	06b2      	lsls	r2, r6, #26
  202384:	d53a      	bpl.n	2023fc <VectorDC+0x9c>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202386:	2720      	movs	r7, #32
  if (ch_queue_notempty(&tqp->queue)) {
  202388:	f8df a1dc 	ldr.w	sl, [pc, #476]	; 202568 <VectorDC+0x208>
  tp->u.rdymsg = msg;
  20238c:	f04f 0900 	mov.w	r9, #0
  202390:	f387 8811 	msr	BASEPRI, r7
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
  202394:	f8d8 2024 	ldr.w	r2, [r8, #36]	; 0x24
  202398:	f894 605c 	ldrb.w	r6, [r4, #92]	; 0x5c
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
  20239c:	6963      	ldr	r3, [r4, #20]
  20239e:	4016      	ands	r6, r2
  2023a0:	2b00      	cmp	r3, #0
  2023a2:	d072      	beq.n	20248a <VectorDC+0x12a>
  if (!iqIsFullI(iqp)) {
  2023a4:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
  2023a8:	429a      	cmp	r2, r3
  2023aa:	d075      	beq.n	202498 <VectorDC+0x138>
    iqp->q_counter++;
  2023ac:	6963      	ldr	r3, [r4, #20]
    *iqp->q_wrptr++ = b;
  2023ae:	1c51      	adds	r1, r2, #1
    iqp->q_counter++;
  2023b0:	3301      	adds	r3, #1
    *iqp->q_wrptr++ = b;
  2023b2:	6221      	str	r1, [r4, #32]
    iqp->q_counter++;
  2023b4:	6163      	str	r3, [r4, #20]
    *iqp->q_wrptr++ = b;
  2023b6:	7016      	strb	r6, [r2, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
  2023b8:	e9d4 3207 	ldrd	r3, r2, [r4, #28]
  2023bc:	429a      	cmp	r2, r3
  2023be:	d301      	bcc.n	2023c4 <VectorDC+0x64>
      iqp->q_wrptr = iqp->q_buffer;
  2023c0:	69a3      	ldr	r3, [r4, #24]
  2023c2:	6223      	str	r3, [r4, #32]
  return (bool)(qp->next != qp);
  2023c4:	68e1      	ldr	r1, [r4, #12]
  2023c6:	4551      	cmp	r1, sl
  2023c8:	d012      	beq.n	2023f0 <VectorDC+0x90>
  qp->next       = p->next;
  2023ca:	680a      	ldr	r2, [r1, #0]
  } while (pqp->prio >= p->prio);
  2023cc:	4b67      	ldr	r3, [pc, #412]	; (20256c <VectorDC+0x20c>)
  2023ce:	6888      	ldr	r0, [r1, #8]
  qp->next       = p->next;
  2023d0:	60e2      	str	r2, [r4, #12]
  qp->next->prev = qp;
  2023d2:	f8c2 a004 	str.w	sl, [r2, #4]
  2023d6:	f8c1 9024 	str.w	r9, [r1, #36]	; 0x24
  tp->state = CH_STATE_READY;
  2023da:	f881 9020 	strb.w	r9, [r1, #32]
    pqp = pqp->next;
  2023de:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  2023e0:	689a      	ldr	r2, [r3, #8]
  2023e2:	4282      	cmp	r2, r0
  2023e4:	d2fb      	bcs.n	2023de <VectorDC+0x7e>
  p->prev       = pqp->prev;
  2023e6:	685a      	ldr	r2, [r3, #4]
  2023e8:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  2023ec:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  2023ee:	6059      	str	r1, [r3, #4]
  2023f0:	f389 8811 	msr	BASEPRI, r9
    osalSysUnlockFromISR();

    isr = u->ISR;
  2023f4:	f8d8 601c 	ldr.w	r6, [r8, #28]
  while (isr & USART_ISR_RXNE) {
  2023f8:	06b3      	lsls	r3, r6, #26
  2023fa:	d4c9      	bmi.n	202390 <VectorDC+0x30>
     situations:
     1) The data registers has been emptied immediately after writing it, this
        would cause an extra interrupt to serve.
     2) FIFO mode is enabled on devices that support it, we need to fill
        the FIFO.*/
  if (cr1 & USART_CR1_TXEIE) {
  2023fc:	062f      	lsls	r7, r5, #24
  2023fe:	d534      	bpl.n	20246a <VectorDC+0x10a>
    while (isr & USART_ISR_TXE) {
  202400:	0630      	lsls	r0, r6, #24
  202402:	d532      	bpl.n	20246a <VectorDC+0x10a>
  202404:	f04f 0e20 	mov.w	lr, #32
  202408:	f8df c164 	ldr.w	ip, [pc, #356]	; 202570 <VectorDC+0x210>
  20240c:	2700      	movs	r7, #0
  20240e:	f38e 8811 	msr	BASEPRI, lr
  if (!oqIsEmptyI(oqp)) {
  202412:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
  202416:	429a      	cmp	r2, r3
  202418:	d051      	beq.n	2024be <VectorDC+0x15e>
    oqp->q_counter++;
  20241a:	6ba1      	ldr	r1, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
  20241c:	1c58      	adds	r0, r3, #1
    if (oqp->q_rdptr >= oqp->q_top) {
  20241e:	6c22      	ldr	r2, [r4, #64]	; 0x40
    oqp->q_counter++;
  202420:	3101      	adds	r1, #1
    b = *oqp->q_rdptr++;
  202422:	64a0      	str	r0, [r4, #72]	; 0x48
    if (oqp->q_rdptr >= oqp->q_top) {
  202424:	4290      	cmp	r0, r2
    oqp->q_counter++;
  202426:	63a1      	str	r1, [r4, #56]	; 0x38
    b = *oqp->q_rdptr++;
  202428:	781e      	ldrb	r6, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
  20242a:	d301      	bcc.n	202430 <VectorDC+0xd0>
      oqp->q_rdptr = oqp->q_buffer;
  20242c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
  20242e:	64a3      	str	r3, [r4, #72]	; 0x48
  return (bool)(qp->next != qp);
  202430:	6b21      	ldr	r1, [r4, #48]	; 0x30
  202432:	4561      	cmp	r1, ip
  202434:	d011      	beq.n	20245a <VectorDC+0xfa>
  qp->next       = p->next;
  202436:	680b      	ldr	r3, [r1, #0]
  } while (pqp->prio >= p->prio);
  202438:	6888      	ldr	r0, [r1, #8]
  qp->next       = p->next;
  20243a:	6323      	str	r3, [r4, #48]	; 0x30
  qp->next->prev = qp;
  20243c:	f8c3 c004 	str.w	ip, [r3, #4]
  } while (pqp->prio >= p->prio);
  202440:	4b4a      	ldr	r3, [pc, #296]	; (20256c <VectorDC+0x20c>)
  202442:	624f      	str	r7, [r1, #36]	; 0x24
  202444:	f881 7020 	strb.w	r7, [r1, #32]
    pqp = pqp->next;
  202448:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  20244a:	689a      	ldr	r2, [r3, #8]
  20244c:	4282      	cmp	r2, r0
  20244e:	d2fb      	bcs.n	202448 <VectorDC+0xe8>
  p->prev       = pqp->prev;
  202450:	685a      	ldr	r2, [r3, #4]
  202452:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  202456:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  202458:	6059      	str	r1, [r3, #4]
        chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
        osalSysUnlockFromISR();
        break;
      }
      u->TDR = b;
  20245a:	f8c8 6028 	str.w	r6, [r8, #40]	; 0x28
  20245e:	f387 8811 	msr	BASEPRI, r7
      osalSysUnlockFromISR();

      isr = u->ISR;
  202462:	f8d8 601c 	ldr.w	r6, [r8, #28]
    while (isr & USART_ISR_TXE) {
  202466:	0633      	lsls	r3, r6, #24
  202468:	d4d1      	bmi.n	20240e <VectorDC+0xae>
    }
  }

  /* Physical transmission end.*/
  if ((cr1 & USART_CR1_TCIE) && (isr & USART_ISR_TC)) {
  20246a:	0669      	lsls	r1, r5, #25
  20246c:	d501      	bpl.n	202472 <VectorDC+0x112>
  20246e:	0672      	lsls	r2, r6, #25
  202470:	d41a      	bmi.n	2024a8 <VectorDC+0x148>
  202472:	2320      	movs	r3, #32
  202474:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202478:	4b3e      	ldr	r3, [pc, #248]	; (202574 <VectorDC+0x214>)
  20247a:	685b      	ldr	r3, [r3, #4]
  20247c:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202480:	d150      	bne.n	202524 <VectorDC+0x1c4>
  202482:	f383 8811 	msr	BASEPRI, r3
  uart_lld_serve_interrupt(&UARTD3);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
  202486:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
  20248a:	2004      	movs	r0, #4
  20248c:	f7fe fc90 	bl	200db0 <chEvtBroadcastFlagsI.constprop.0>
  if (!iqIsFullI(iqp)) {
  202490:	e9d4 2308 	ldrd	r2, r3, [r4, #32]
  202494:	429a      	cmp	r2, r3
  202496:	d189      	bne.n	2023ac <VectorDC+0x4c>
  202498:	6963      	ldr	r3, [r4, #20]
  20249a:	2b00      	cmp	r3, #0
  20249c:	d086      	beq.n	2023ac <VectorDC+0x4c>
  20249e:	f44f 6080 	mov.w	r0, #1024	; 0x400
  2024a2:	f7fe fc85 	bl	200db0 <chEvtBroadcastFlagsI.constprop.0>
}
  2024a6:	e7a3      	b.n	2023f0 <VectorDC+0x90>
  2024a8:	2320      	movs	r3, #32
  2024aa:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue)) {
  2024ae:	e9d4 2311 	ldrd	r2, r3, [r4, #68]	; 0x44
  2024b2:	429a      	cmp	r2, r3
  2024b4:	d04a      	beq.n	20254c <VectorDC+0x1ec>
  2024b6:	2300      	movs	r3, #0
  2024b8:	f383 8811 	msr	BASEPRI, r3
}
  2024bc:	e7d9      	b.n	202472 <VectorDC+0x112>
  if (!oqIsEmptyI(oqp)) {
  2024be:	6ba2      	ldr	r2, [r4, #56]	; 0x38
  2024c0:	2a00      	cmp	r2, #0
  2024c2:	d0aa      	beq.n	20241a <VectorDC+0xba>
  chEvtBroadcastFlagsI(esp, flags);
  2024c4:	2008      	movs	r0, #8
  2024c6:	f7fe fc73 	bl	200db0 <chEvtBroadcastFlagsI.constprop.0>
        u->CR1 = cr1 & ~USART_CR1_TXEIE;
  2024ca:	f025 0380 	bic.w	r3, r5, #128	; 0x80
  2024ce:	f8c8 3000 	str.w	r3, [r8]
  2024d2:	2300      	movs	r3, #0
  2024d4:	f383 8811 	msr	BASEPRI, r3
}
  2024d8:	e7c7      	b.n	20246a <VectorDC+0x10a>
  2024da:	2320      	movs	r3, #32
  2024dc:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
  2024e0:	f44f 7000 	mov.w	r0, #512	; 0x200
  2024e4:	f7fe fc64 	bl	200db0 <chEvtBroadcastFlagsI.constprop.0>
  2024e8:	2300      	movs	r3, #0
  2024ea:	f383 8811 	msr	BASEPRI, r3
}
  2024ee:	e748      	b.n	202382 <VectorDC+0x22>
    sts |= SD_OVERRUN_ERROR;
  2024f0:	f016 0008 	ands.w	r0, r6, #8
  2024f4:	bf18      	it	ne
  2024f6:	2080      	movne	r0, #128	; 0x80
  if (isr & USART_ISR_PE)
  2024f8:	07f2      	lsls	r2, r6, #31
    sts |= SD_PARITY_ERROR;
  2024fa:	bf48      	it	mi
  2024fc:	f040 0020 	orrmi.w	r0, r0, #32
  if (isr & USART_ISR_FE)
  202500:	07b3      	lsls	r3, r6, #30
  202502:	f04f 0320 	mov.w	r3, #32
    sts |= SD_FRAMING_ERROR;
  202506:	bf48      	it	mi
  202508:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (isr & USART_ISR_NE)
  20250c:	0777      	lsls	r7, r6, #29
    sts |= SD_NOISE_ERROR;
  20250e:	bf48      	it	mi
  202510:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
  202514:	f383 8811 	msr	BASEPRI, r3
  chEvtBroadcastFlagsI(esp, flags);
  202518:	f7fe fc4a 	bl	200db0 <chEvtBroadcastFlagsI.constprop.0>
  20251c:	2300      	movs	r3, #0
  20251e:	f383 8811 	msr	BASEPRI, r3
}
  202522:	e72b      	b.n	20237c <VectorDC+0x1c>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202524:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202528:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  20252c:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  20252e:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202530:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202534:	4a0d      	ldr	r2, [pc, #52]	; (20256c <VectorDC+0x20c>)
  202536:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202538:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  20253a:	6889      	ldr	r1, [r1, #8]
  20253c:	6892      	ldr	r2, [r2, #8]
  20253e:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202540:	bf8c      	ite	hi
  202542:	4a0d      	ldrhi	r2, [pc, #52]	; (202578 <VectorDC+0x218>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202544:	4a0d      	ldrls	r2, [pc, #52]	; (20257c <VectorDC+0x21c>)
  202546:	619a      	str	r2, [r3, #24]
  202548:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if (oqIsEmptyI(&sdp->oqueue)) {
  20254c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
  20254e:	2b00      	cmp	r3, #0
  202550:	d0b1      	beq.n	2024b6 <VectorDC+0x156>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
      u->CR1 = cr1 & ~USART_CR1_TCIE;
  202552:	f025 0540 	bic.w	r5, r5, #64	; 0x40
  202556:	2010      	movs	r0, #16
  202558:	f7fe fc2a 	bl	200db0 <chEvtBroadcastFlagsI.constprop.0>
  20255c:	f8c8 5000 	str.w	r5, [r8]
  202560:	e7a9      	b.n	2024b6 <VectorDC+0x156>
  202562:	bf00      	nop
  202564:	20000858 	.word	0x20000858
  202568:	20000864 	.word	0x20000864
  20256c:	200009d0 	.word	0x200009d0
  202570:	20000888 	.word	0x20000888
  202574:	e000ed00 	.word	0xe000ed00
  202578:	00200303 	.word	0x00200303
  20257c:	00200306 	.word	0x00200306

00202580 <VectorA0>:
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202580:	2320      	movs	r3, #32
  202582:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202586:	4b0d      	ldr	r3, [pc, #52]	; (2025bc <VectorA0+0x3c>)
  202588:	685b      	ldr	r3, [r3, #4]
  20258a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  20258e:	d102      	bne.n	202596 <VectorA0+0x16>
  202590:	f383 8811 	msr	BASEPRI, r3
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
  202594:	4770      	bx	lr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202596:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  20259a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  20259e:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2025a0:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2025a2:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2025a6:	4a06      	ldr	r2, [pc, #24]	; (2025c0 <VectorA0+0x40>)
  2025a8:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  2025aa:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  2025ac:	6889      	ldr	r1, [r1, #8]
  2025ae:	6892      	ldr	r2, [r2, #8]
  2025b0:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  2025b2:	bf8c      	ite	hi
  2025b4:	4a03      	ldrhi	r2, [pc, #12]	; (2025c4 <VectorA0+0x44>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  2025b6:	4a04      	ldrls	r2, [pc, #16]	; (2025c8 <VectorA0+0x48>)
  2025b8:	619a      	str	r2, [r3, #24]
  2025ba:	4770      	bx	lr
  2025bc:	e000ed00 	.word	0xe000ed00
  2025c0:	200009d0 	.word	0x200009d0
  2025c4:	00200303 	.word	0x00200303
  2025c8:	00200306 	.word	0x00200306
  2025cc:	00000000 	.word	0x00000000

002025d0 <VectorA4>:
/**
 * @brief   TIM1-UP, TIM10 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_TIM10_HANDLER) {
  2025d0:	b508      	push	{r3, lr}
  icu_lld_serve_interrupt(&ICUD10);
#endif
#endif
#if HAL_USE_PWM
#if STM32_PWM_USE_TIM1
  pwm_lld_serve_interrupt(&PWMD1);
  2025d2:	f7fe fbb5 	bl	200d40 <pwm_lld_serve_interrupt.constprop.0>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2025d6:	2320      	movs	r3, #32
  2025d8:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2025dc:	4b0d      	ldr	r3, [pc, #52]	; (202614 <VectorA4+0x44>)
  2025de:	685b      	ldr	r3, [r3, #4]
  2025e0:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2025e4:	d102      	bne.n	2025ec <VectorA4+0x1c>
  2025e6:	f383 8811 	msr	BASEPRI, r3
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
  2025ea:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2025ec:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  2025f0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  2025f4:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2025f6:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2025f8:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2025fc:	4a06      	ldr	r2, [pc, #24]	; (202618 <VectorA4+0x48>)
  2025fe:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202600:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202602:	6889      	ldr	r1, [r1, #8]
  202604:	6892      	ldr	r2, [r2, #8]
  202606:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202608:	bf8c      	ite	hi
  20260a:	4a04      	ldrhi	r2, [pc, #16]	; (20261c <VectorA4+0x4c>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  20260c:	4a04      	ldrls	r2, [pc, #16]	; (202620 <VectorA4+0x50>)
  20260e:	619a      	str	r2, [r3, #24]
  202610:	bd08      	pop	{r3, pc}
  202612:	bf00      	nop
  202614:	e000ed00 	.word	0xe000ed00
  202618:	200009d0 	.word	0x200009d0
  20261c:	00200303 	.word	0x00200303
  202620:	00200306 	.word	0x00200306
	...

00202630 <VectorA8>:
  202630:	2320      	movs	r3, #32
  202632:	f383 8811 	msr	BASEPRI, r3
  202636:	4b0d      	ldr	r3, [pc, #52]	; (20266c <VectorA8+0x3c>)
  202638:	685b      	ldr	r3, [r3, #4]
  20263a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  20263e:	d102      	bne.n	202646 <VectorA8+0x16>
  202640:	f383 8811 	msr	BASEPRI, r3
  202644:	4770      	bx	lr
  202646:	f3ef 8309 	mrs	r3, PSP
  20264a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  20264e:	3b20      	subs	r3, #32
  202650:	61da      	str	r2, [r3, #28]
  202652:	f383 8809 	msr	PSP, r3
  202656:	4a06      	ldr	r2, [pc, #24]	; (202670 <VectorA8+0x40>)
  202658:	6811      	ldr	r1, [r2, #0]
  20265a:	6992      	ldr	r2, [r2, #24]
  20265c:	6889      	ldr	r1, [r1, #8]
  20265e:	6892      	ldr	r2, [r2, #8]
  202660:	4291      	cmp	r1, r2
  202662:	bf8c      	ite	hi
  202664:	4a03      	ldrhi	r2, [pc, #12]	; (202674 <VectorA8+0x44>)
  202666:	4a04      	ldrls	r2, [pc, #16]	; (202678 <VectorA8+0x48>)
  202668:	619a      	str	r2, [r3, #24]
  20266a:	4770      	bx	lr
  20266c:	e000ed00 	.word	0xe000ed00
  202670:	200009d0 	.word	0x200009d0
  202674:	00200303 	.word	0x00200303
  202678:	00200306 	.word	0x00200306
  20267c:	00000000 	.word	0x00000000

00202680 <VectorAC>:
  202680:	b508      	push	{r3, lr}
  202682:	f7fe fb5d 	bl	200d40 <pwm_lld_serve_interrupt.constprop.0>
  202686:	2320      	movs	r3, #32
  202688:	f383 8811 	msr	BASEPRI, r3
  20268c:	4b0d      	ldr	r3, [pc, #52]	; (2026c4 <VectorAC+0x44>)
  20268e:	685b      	ldr	r3, [r3, #4]
  202690:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202694:	d102      	bne.n	20269c <VectorAC+0x1c>
  202696:	f383 8811 	msr	BASEPRI, r3
  20269a:	bd08      	pop	{r3, pc}
  20269c:	f3ef 8309 	mrs	r3, PSP
  2026a0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  2026a4:	3b20      	subs	r3, #32
  2026a6:	61da      	str	r2, [r3, #28]
  2026a8:	f383 8809 	msr	PSP, r3
  2026ac:	4a06      	ldr	r2, [pc, #24]	; (2026c8 <VectorAC+0x48>)
  2026ae:	6811      	ldr	r1, [r2, #0]
  2026b0:	6992      	ldr	r2, [r2, #24]
  2026b2:	6889      	ldr	r1, [r1, #8]
  2026b4:	6892      	ldr	r2, [r2, #8]
  2026b6:	4291      	cmp	r1, r2
  2026b8:	bf8c      	ite	hi
  2026ba:	4a04      	ldrhi	r2, [pc, #16]	; (2026cc <VectorAC+0x4c>)
  2026bc:	4a04      	ldrls	r2, [pc, #16]	; (2026d0 <VectorAC+0x50>)
  2026be:	619a      	str	r2, [r3, #24]
  2026c0:	bd08      	pop	{r3, pc}
  2026c2:	bf00      	nop
  2026c4:	e000ed00 	.word	0xe000ed00
  2026c8:	200009d0 	.word	0x200009d0
  2026cc:	00200303 	.word	0x00200303
  2026d0:	00200306 	.word	0x00200306
	...

002026e0 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
  2026e0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
void st_lld_serve_interrupt(void) {
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;

  sr  = timp->SR;
  2026e4:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
  2026e8:	6933      	ldr	r3, [r6, #16]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
  2026ea:	68f2      	ldr	r2, [r6, #12]
  2026ec:	4013      	ands	r3, r2
  2026ee:	b2da      	uxtb	r2, r3
  timp->SR = ~sr;

  if ((sr & TIM_SR_CC1IF) != 0U)
  2026f0:	079b      	lsls	r3, r3, #30
  timp->SR = ~sr;
  2026f2:	ea6f 0202 	mvn.w	r2, r2
  2026f6:	6132      	str	r2, [r6, #16]
  if ((sr & TIM_SR_CC1IF) != 0U)
  2026f8:	d40b      	bmi.n	202712 <VectorB0+0x32>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2026fa:	2320      	movs	r3, #32
  2026fc:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202700:	4b2f      	ldr	r3, [pc, #188]	; (2027c0 <VectorB0+0xe0>)
  202702:	685b      	ldr	r3, [r3, #4]
  202704:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202708:	d146      	bne.n	202798 <VectorB0+0xb8>
  20270a:	f383 8811 	msr	BASEPRI, r3
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
  20270e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  202712:	2320      	movs	r3, #32
  202714:	f383 8811 	msr	BASEPRI, r3
  delta_list_t *dlp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  dlp = vtlp->dlist.next;
  202718:	4c2a      	ldr	r4, [pc, #168]	; (2027c4 <VectorB0+0xe4>)
  return (systime_t)STM32_ST_TIM->CNT;
  20271a:	6a70      	ldr	r0, [r6, #36]	; 0x24
  20271c:	69e3      	ldr	r3, [r4, #28]
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
  20271e:	f104 091c 	add.w	r9, r4, #28
  202722:	6aa2      	ldr	r2, [r4, #40]	; 0x28

    /* The list scan is limited by the timers header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < dlp->delta) {
  202724:	6899      	ldr	r1, [r3, #8]
  return (sysinterval_t)((systime_t)(end - start));
  202726:	1a87      	subs	r7, r0, r2
  202728:	42b9      	cmp	r1, r7
  20272a:	d823      	bhi.n	202774 <VectorB0+0x94>
      vtlp->dlist.next = dlp->next;

      /* Calling the associated function and then marking the timer as
         non active.*/
      fn = vtp->func;
      vtp->func = NULL;
  20272c:	f04f 0800 	mov.w	r8, #0
  202730:	2520      	movs	r5, #32
  202732:	e00a      	b.n	20274a <VectorB0+0x6a>
  202734:	f388 8811 	msr	BASEPRI, r8
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
  202738:	6918      	ldr	r0, [r3, #16]
  20273a:	47d0      	blx	sl
  20273c:	f385 8811 	msr	BASEPRI, r5
      chSysLockFromISR();

      /* Next element in the list.*/
      dlp = vtlp->dlist.next;
  202740:	69e3      	ldr	r3, [r4, #28]
    }
    while (dlp->delta <= nowdelta);
  202742:	6899      	ldr	r1, [r3, #8]
  202744:	428f      	cmp	r7, r1
  202746:	d310      	bcc.n	20276a <VectorB0+0x8a>
      vtlp->lasttime += dlp->delta;
  202748:	6aa2      	ldr	r2, [r4, #40]	; 0x28
      dlp->next->prev = &vtlp->dlist;
  20274a:	6818      	ldr	r0, [r3, #0]
      vtlp->lasttime += dlp->delta;
  20274c:	440a      	add	r2, r1
      fn = vtp->func;
  20274e:	f8d3 a00c 	ldr.w	sl, [r3, #12]
      nowdelta -= dlp->delta;
  202752:	1a7f      	subs	r7, r7, r1
      if (is_vtlist_empty(&vtlp->dlist)) {
  202754:	4548      	cmp	r0, r9
      vtlp->lasttime += dlp->delta;
  202756:	62a2      	str	r2, [r4, #40]	; 0x28
      dlp->next->prev = &vtlp->dlist;
  202758:	f8c0 9004 	str.w	r9, [r0, #4]
      vtlp->dlist.next = dlp->next;
  20275c:	61e0      	str	r0, [r4, #28]
      vtp->func = NULL;
  20275e:	f8c3 800c 	str.w	r8, [r3, #12]
      if (is_vtlist_empty(&vtlp->dlist)) {
  202762:	d1e7      	bne.n	202734 <VectorB0+0x54>
  STM32_ST_TIM->DIER = 0U;
  202764:	f8c6 800c 	str.w	r8, [r6, #12]
}
  202768:	e7e4      	b.n	202734 <VectorB0+0x54>
  return (systime_t)STM32_ST_TIM->CNT;
  20276a:	6a70      	ldr	r0, [r6, #36]	; 0x24
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
  20276c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
  20276e:	1a87      	subs	r7, r0, r2
    if (nowdelta < dlp->delta) {
  202770:	428f      	cmp	r7, r1
  202772:	d2dd      	bcs.n	202730 <VectorB0+0x50>
  }

  /* If the list is empty, nothing else to do.*/
  if (is_vtlist_empty(&vtlp->dlist)) {
  202774:	454b      	cmp	r3, r9
  202776:	d00b      	beq.n	202790 <VectorB0+0xb0>
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
  vtlp->dlist.next->delta -= nowdelta;
  202778:	6899      	ldr	r1, [r3, #8]
  vtlp->lasttime += nowdelta;
  20277a:	62a0      	str	r0, [r4, #40]	; 0x28
  vtlp->dlist.next->delta -= nowdelta;
  20277c:	1a09      	subs	r1, r1, r0
  20277e:	440a      	add	r2, r1
  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
  202780:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  return systime + (systime_t)interval;
  202784:	2a02      	cmp	r2, #2
  202786:	bf2c      	ite	cs
  202788:	1880      	addcs	r0, r0, r2
  20278a:	3002      	addcc	r0, #2
  20278c:	609a      	str	r2, [r3, #8]
  20278e:	6348      	str	r0, [r1, #52]	; 0x34
  202790:	2300      	movs	r3, #0
  202792:	f383 8811 	msr	BASEPRI, r3
}
  202796:	e7b0      	b.n	2026fa <VectorB0+0x1a>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202798:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  20279c:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  2027a0:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2027a2:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2027a4:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2027a8:	4a06      	ldr	r2, [pc, #24]	; (2027c4 <VectorB0+0xe4>)
  2027aa:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  2027ac:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  2027ae:	6889      	ldr	r1, [r1, #8]
  2027b0:	6892      	ldr	r2, [r2, #8]
  2027b2:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  2027b4:	bf8c      	ite	hi
  2027b6:	4a04      	ldrhi	r2, [pc, #16]	; (2027c8 <VectorB0+0xe8>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  2027b8:	4a04      	ldrls	r2, [pc, #16]	; (2027cc <VectorB0+0xec>)
  2027ba:	619a      	str	r2, [r3, #24]
  2027bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  2027c0:	e000ed00 	.word	0xe000ed00
  2027c4:	200009d0 	.word	0x200009d0
  2027c8:	00200303 	.word	0x00200303
  2027cc:	00200306 	.word	0x00200306

002027d0 <VectorB4>:
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
  uint32_t sr;

  sr  = gptp->tim->SR;
  2027d0:	481f      	ldr	r0, [pc, #124]	; (202850 <VectorB4+0x80>)
  2027d2:	68c2      	ldr	r2, [r0, #12]
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
  2027d4:	b508      	push	{r3, lr}
  2027d6:	6913      	ldr	r3, [r2, #16]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  2027d8:	68d1      	ldr	r1, [r2, #12]
  2027da:	400b      	ands	r3, r1
  2027dc:	b2d9      	uxtb	r1, r3
  gptp->tim->SR = ~sr;
  if ((sr & STM32_TIM_SR_UIF) != 0) {
  2027de:	07db      	lsls	r3, r3, #31
  gptp->tim->SR = ~sr;
  2027e0:	ea6f 0101 	mvn.w	r1, r1
  2027e4:	6111      	str	r1, [r2, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
  2027e6:	d507      	bpl.n	2027f8 <VectorB4+0x28>
    _gpt_isr_invoke_cb(gptp);
  2027e8:	7803      	ldrb	r3, [r0, #0]
  2027ea:	2b04      	cmp	r3, #4
  2027ec:	d022      	beq.n	202834 <VectorB4+0x64>
  2027ee:	6843      	ldr	r3, [r0, #4]
  2027f0:	685b      	ldr	r3, [r3, #4]
  2027f2:	b10b      	cbz	r3, 2027f8 <VectorB4+0x28>
  2027f4:	4816      	ldr	r0, [pc, #88]	; (202850 <VectorB4+0x80>)
  2027f6:	4798      	blx	r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2027f8:	2320      	movs	r3, #32
  2027fa:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2027fe:	4b15      	ldr	r3, [pc, #84]	; (202854 <VectorB4+0x84>)
  202800:	685b      	ldr	r3, [r3, #4]
  202802:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202806:	d102      	bne.n	20280e <VectorB4+0x3e>
  202808:	f383 8811 	msr	BASEPRI, r3
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
  20280c:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  20280e:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202812:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202816:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202818:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  20281a:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  20281e:	4a0e      	ldr	r2, [pc, #56]	; (202858 <VectorB4+0x88>)
  202820:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202822:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202824:	6889      	ldr	r1, [r1, #8]
  202826:	6892      	ldr	r2, [r2, #8]
  202828:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  20282a:	bf8c      	ite	hi
  20282c:	4a0b      	ldrhi	r2, [pc, #44]	; (20285c <VectorB4+0x8c>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  20282e:	4a0c      	ldrls	r2, [pc, #48]	; (202860 <VectorB4+0x90>)
  202830:	619a      	str	r2, [r3, #24]
  202832:	bd08      	pop	{r3, pc}
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  202834:	2300      	movs	r3, #0
    _gpt_isr_invoke_cb(gptp);
  202836:	2102      	movs	r1, #2
  202838:	7001      	strb	r1, [r0, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  20283a:	6013      	str	r3, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  20283c:	6113      	str	r3, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  20283e:	68d3      	ldr	r3, [r2, #12]
  202840:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  202844:	60d3      	str	r3, [r2, #12]
    _gpt_isr_invoke_cb(gptp);
  202846:	6843      	ldr	r3, [r0, #4]
  202848:	685b      	ldr	r3, [r3, #4]
  20284a:	2b00      	cmp	r3, #0
  20284c:	d1d2      	bne.n	2027f4 <VectorB4+0x24>
  20284e:	e7d3      	b.n	2027f8 <VectorB4+0x28>
  202850:	20000800 	.word	0x20000800
  202854:	e000ed00 	.word	0xe000ed00
  202858:	200009d0 	.word	0x200009d0
  20285c:	00200303 	.word	0x00200303
  202860:	00200306 	.word	0x00200306
	...

00202870 <VectorB8>:
  sr  = gptp->tim->SR;
  202870:	481f      	ldr	r0, [pc, #124]	; (2028f0 <VectorB8+0x80>)
  202872:	68c2      	ldr	r2, [r0, #12]
/**
 * @brief   TIM4 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM4_HANDLER) {
  202874:	b508      	push	{r3, lr}
  202876:	6913      	ldr	r3, [r2, #16]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  202878:	68d1      	ldr	r1, [r2, #12]
  20287a:	400b      	ands	r3, r1
  20287c:	b2d9      	uxtb	r1, r3
  if ((sr & STM32_TIM_SR_UIF) != 0) {
  20287e:	07db      	lsls	r3, r3, #31
  gptp->tim->SR = ~sr;
  202880:	ea6f 0101 	mvn.w	r1, r1
  202884:	6111      	str	r1, [r2, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
  202886:	d507      	bpl.n	202898 <VectorB8+0x28>
    _gpt_isr_invoke_cb(gptp);
  202888:	7803      	ldrb	r3, [r0, #0]
  20288a:	2b04      	cmp	r3, #4
  20288c:	d022      	beq.n	2028d4 <VectorB8+0x64>
  20288e:	6843      	ldr	r3, [r0, #4]
  202890:	685b      	ldr	r3, [r3, #4]
  202892:	b10b      	cbz	r3, 202898 <VectorB8+0x28>
  202894:	4816      	ldr	r0, [pc, #88]	; (2028f0 <VectorB8+0x80>)
  202896:	4798      	blx	r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202898:	2320      	movs	r3, #32
  20289a:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  20289e:	4b15      	ldr	r3, [pc, #84]	; (2028f4 <VectorB8+0x84>)
  2028a0:	685b      	ldr	r3, [r3, #4]
  2028a2:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2028a6:	d102      	bne.n	2028ae <VectorB8+0x3e>
  2028a8:	f383 8811 	msr	BASEPRI, r3
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
}
  2028ac:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2028ae:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  2028b2:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  2028b6:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2028b8:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2028ba:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2028be:	4a0e      	ldr	r2, [pc, #56]	; (2028f8 <VectorB8+0x88>)
  2028c0:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  2028c2:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  2028c4:	6889      	ldr	r1, [r1, #8]
  2028c6:	6892      	ldr	r2, [r2, #8]
  2028c8:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  2028ca:	bf8c      	ite	hi
  2028cc:	4a0b      	ldrhi	r2, [pc, #44]	; (2028fc <VectorB8+0x8c>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  2028ce:	4a0c      	ldrls	r2, [pc, #48]	; (202900 <VectorB8+0x90>)
  2028d0:	619a      	str	r2, [r3, #24]
  2028d2:	bd08      	pop	{r3, pc}
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  2028d4:	2300      	movs	r3, #0
    _gpt_isr_invoke_cb(gptp);
  2028d6:	2102      	movs	r1, #2
  2028d8:	7001      	strb	r1, [r0, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  2028da:	6013      	str	r3, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  2028dc:	6113      	str	r3, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  2028de:	68d3      	ldr	r3, [r2, #12]
  2028e0:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
  2028e4:	60d3      	str	r3, [r2, #12]
    _gpt_isr_invoke_cb(gptp);
  2028e6:	6843      	ldr	r3, [r0, #4]
  2028e8:	685b      	ldr	r3, [r3, #4]
  2028ea:	2b00      	cmp	r3, #0
  2028ec:	d1d2      	bne.n	202894 <VectorB8+0x24>
  2028ee:	e7d3      	b.n	202898 <VectorB8+0x28>
  2028f0:	20000810 	.word	0x20000810
  2028f4:	e000ed00 	.word	0xe000ed00
  2028f8:	200009d0 	.word	0x200009d0
  2028fc:	00200303 	.word	0x00200303
  202900:	00200306 	.word	0x00200306
	...

00202910 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
  202910:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  202912:	4b14      	ldr	r3, [pc, #80]	; (202964 <Vector6C+0x54>)
  DMA1->LIFCR = flags << 0U;
  if (dma.streams[0].func)
  202914:	4814      	ldr	r0, [pc, #80]	; (202968 <Vector6C+0x58>)
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  202916:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[0].func)
  202918:	6842      	ldr	r2, [r0, #4]
  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
  20291a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->LIFCR = flags << 0U;
  20291e:	6099      	str	r1, [r3, #8]
  if (dma.streams[0].func)
  202920:	b10a      	cbz	r2, 202926 <Vector6C+0x16>
    dma.streams[0].func(dma.streams[0].param, flags);
  202922:	6880      	ldr	r0, [r0, #8]
  202924:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202926:	2320      	movs	r3, #32
  202928:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  20292c:	4b0f      	ldr	r3, [pc, #60]	; (20296c <Vector6C+0x5c>)
  20292e:	685b      	ldr	r3, [r3, #4]
  202930:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202934:	d102      	bne.n	20293c <Vector6C+0x2c>
  202936:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  20293a:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  20293c:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202940:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202944:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202946:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202948:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  20294c:	4a08      	ldr	r2, [pc, #32]	; (202970 <Vector6C+0x60>)
  20294e:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202950:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202952:	6889      	ldr	r1, [r1, #8]
  202954:	6892      	ldr	r2, [r2, #8]
  202956:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202958:	bf8c      	ite	hi
  20295a:	4a06      	ldrhi	r2, [pc, #24]	; (202974 <Vector6C+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  20295c:	4a06      	ldrls	r2, [pc, #24]	; (202978 <Vector6C+0x68>)
  20295e:	619a      	str	r2, [r3, #24]
  202960:	bd08      	pop	{r3, pc}
  202962:	bf00      	nop
  202964:	40026000 	.word	0x40026000
  202968:	20000f10 	.word	0x20000f10
  20296c:	e000ed00 	.word	0xe000ed00
  202970:	200009d0 	.word	0x200009d0
  202974:	00200303 	.word	0x00200303
  202978:	00200306 	.word	0x00200306
  20297c:	00000000 	.word	0x00000000

00202980 <Vector70>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  202980:	4b15      	ldr	r3, [pc, #84]	; (2029d8 <Vector70+0x58>)
  DMA1->LIFCR = flags << 6U;
  if (dma.streams[1].func)
  202982:	4816      	ldr	r0, [pc, #88]	; (2029dc <Vector70+0x5c>)
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  202984:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[1].func)
  202986:	68c2      	ldr	r2, [r0, #12]
  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
  202988:	0989      	lsrs	r1, r1, #6
  20298a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
  20298e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 6U;
  202990:	018c      	lsls	r4, r1, #6
  202992:	609c      	str	r4, [r3, #8]
  if (dma.streams[1].func)
  202994:	b10a      	cbz	r2, 20299a <Vector70+0x1a>
    dma.streams[1].func(dma.streams[1].param, flags);
  202996:	6900      	ldr	r0, [r0, #16]
  202998:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20299a:	2320      	movs	r3, #32
  20299c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  2029a0:	4b0f      	ldr	r3, [pc, #60]	; (2029e0 <Vector70+0x60>)
  2029a2:	685b      	ldr	r3, [r3, #4]
  2029a4:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  2029a8:	d102      	bne.n	2029b0 <Vector70+0x30>
  2029aa:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  2029ae:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2029b0:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  2029b4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  2029b8:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  2029ba:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2029bc:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  2029c0:	4a08      	ldr	r2, [pc, #32]	; (2029e4 <Vector70+0x64>)
  2029c2:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  2029c4:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  2029c6:	6889      	ldr	r1, [r1, #8]
  2029c8:	6892      	ldr	r2, [r2, #8]
  2029ca:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  2029cc:	bf8c      	ite	hi
  2029ce:	4a06      	ldrhi	r2, [pc, #24]	; (2029e8 <Vector70+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  2029d0:	4a06      	ldrls	r2, [pc, #24]	; (2029ec <Vector70+0x6c>)
  2029d2:	619a      	str	r2, [r3, #24]
  2029d4:	bd10      	pop	{r4, pc}
  2029d6:	bf00      	nop
  2029d8:	40026000 	.word	0x40026000
  2029dc:	20000f10 	.word	0x20000f10
  2029e0:	e000ed00 	.word	0xe000ed00
  2029e4:	200009d0 	.word	0x200009d0
  2029e8:	00200303 	.word	0x00200303
  2029ec:	00200306 	.word	0x00200306

002029f0 <Vector74>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  2029f0:	4b15      	ldr	r3, [pc, #84]	; (202a48 <Vector74+0x58>)
  DMA1->LIFCR = flags << 16U;
  if (dma.streams[2].func)
  2029f2:	4816      	ldr	r0, [pc, #88]	; (202a4c <Vector74+0x5c>)
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  2029f4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[2].func)
  2029f6:	6942      	ldr	r2, [r0, #20]
  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
  2029f8:	0c09      	lsrs	r1, r1, #16
  2029fa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
  2029fe:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 16U;
  202a00:	040c      	lsls	r4, r1, #16
  202a02:	609c      	str	r4, [r3, #8]
  if (dma.streams[2].func)
  202a04:	b10a      	cbz	r2, 202a0a <Vector74+0x1a>
    dma.streams[2].func(dma.streams[2].param, flags);
  202a06:	6980      	ldr	r0, [r0, #24]
  202a08:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202a0a:	2320      	movs	r3, #32
  202a0c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202a10:	4b0f      	ldr	r3, [pc, #60]	; (202a50 <Vector74+0x60>)
  202a12:	685b      	ldr	r3, [r3, #4]
  202a14:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202a18:	d102      	bne.n	202a20 <Vector74+0x30>
  202a1a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202a1e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202a20:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202a24:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202a28:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202a2a:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202a2c:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202a30:	4a08      	ldr	r2, [pc, #32]	; (202a54 <Vector74+0x64>)
  202a32:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202a34:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202a36:	6889      	ldr	r1, [r1, #8]
  202a38:	6892      	ldr	r2, [r2, #8]
  202a3a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202a3c:	bf8c      	ite	hi
  202a3e:	4a06      	ldrhi	r2, [pc, #24]	; (202a58 <Vector74+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202a40:	4a06      	ldrls	r2, [pc, #24]	; (202a5c <Vector74+0x6c>)
  202a42:	619a      	str	r2, [r3, #24]
  202a44:	bd10      	pop	{r4, pc}
  202a46:	bf00      	nop
  202a48:	40026000 	.word	0x40026000
  202a4c:	20000f10 	.word	0x20000f10
  202a50:	e000ed00 	.word	0xe000ed00
  202a54:	200009d0 	.word	0x200009d0
  202a58:	00200303 	.word	0x00200303
  202a5c:	00200306 	.word	0x00200306

00202a60 <Vector78>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  202a60:	4b15      	ldr	r3, [pc, #84]	; (202ab8 <Vector78+0x58>)
  DMA1->LIFCR = flags << 22U;
  if (dma.streams[3].func)
  202a62:	4816      	ldr	r0, [pc, #88]	; (202abc <Vector78+0x5c>)
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  202a64:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[3].func)
  202a66:	69c2      	ldr	r2, [r0, #28]
  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
  202a68:	0d89      	lsrs	r1, r1, #22
  202a6a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
  202a6e:	b510      	push	{r4, lr}
  DMA1->LIFCR = flags << 22U;
  202a70:	058c      	lsls	r4, r1, #22
  202a72:	609c      	str	r4, [r3, #8]
  if (dma.streams[3].func)
  202a74:	b10a      	cbz	r2, 202a7a <Vector78+0x1a>
    dma.streams[3].func(dma.streams[3].param, flags);
  202a76:	6a00      	ldr	r0, [r0, #32]
  202a78:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202a7a:	2320      	movs	r3, #32
  202a7c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202a80:	4b0f      	ldr	r3, [pc, #60]	; (202ac0 <Vector78+0x60>)
  202a82:	685b      	ldr	r3, [r3, #4]
  202a84:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202a88:	d102      	bne.n	202a90 <Vector78+0x30>
  202a8a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202a8e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202a90:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202a94:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202a98:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202a9a:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202a9c:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202aa0:	4a08      	ldr	r2, [pc, #32]	; (202ac4 <Vector78+0x64>)
  202aa2:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202aa4:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202aa6:	6889      	ldr	r1, [r1, #8]
  202aa8:	6892      	ldr	r2, [r2, #8]
  202aaa:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202aac:	bf8c      	ite	hi
  202aae:	4a06      	ldrhi	r2, [pc, #24]	; (202ac8 <Vector78+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202ab0:	4a06      	ldrls	r2, [pc, #24]	; (202acc <Vector78+0x6c>)
  202ab2:	619a      	str	r2, [r3, #24]
  202ab4:	bd10      	pop	{r4, pc}
  202ab6:	bf00      	nop
  202ab8:	40026000 	.word	0x40026000
  202abc:	20000f10 	.word	0x20000f10
  202ac0:	e000ed00 	.word	0xe000ed00
  202ac4:	200009d0 	.word	0x200009d0
  202ac8:	00200303 	.word	0x00200303
  202acc:	00200306 	.word	0x00200306

00202ad0 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
  202ad0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  202ad2:	4b14      	ldr	r3, [pc, #80]	; (202b24 <Vector7C+0x54>)
  DMA1->HIFCR = flags << 0U;
  if (dma.streams[4].func)
  202ad4:	4814      	ldr	r0, [pc, #80]	; (202b28 <Vector7C+0x58>)
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  202ad6:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[4].func)
  202ad8:	6a42      	ldr	r2, [r0, #36]	; 0x24
  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
  202ada:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA1->HIFCR = flags << 0U;
  202ade:	60d9      	str	r1, [r3, #12]
  if (dma.streams[4].func)
  202ae0:	b10a      	cbz	r2, 202ae6 <Vector7C+0x16>
    dma.streams[4].func(dma.streams[4].param, flags);
  202ae2:	6a80      	ldr	r0, [r0, #40]	; 0x28
  202ae4:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202ae6:	2320      	movs	r3, #32
  202ae8:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202aec:	4b0f      	ldr	r3, [pc, #60]	; (202b2c <Vector7C+0x5c>)
  202aee:	685b      	ldr	r3, [r3, #4]
  202af0:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202af4:	d102      	bne.n	202afc <Vector7C+0x2c>
  202af6:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202afa:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202afc:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202b00:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202b04:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202b06:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202b08:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202b0c:	4a08      	ldr	r2, [pc, #32]	; (202b30 <Vector7C+0x60>)
  202b0e:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202b10:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202b12:	6889      	ldr	r1, [r1, #8]
  202b14:	6892      	ldr	r2, [r2, #8]
  202b16:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202b18:	bf8c      	ite	hi
  202b1a:	4a06      	ldrhi	r2, [pc, #24]	; (202b34 <Vector7C+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202b1c:	4a06      	ldrls	r2, [pc, #24]	; (202b38 <Vector7C+0x68>)
  202b1e:	619a      	str	r2, [r3, #24]
  202b20:	bd08      	pop	{r3, pc}
  202b22:	bf00      	nop
  202b24:	40026000 	.word	0x40026000
  202b28:	20000f10 	.word	0x20000f10
  202b2c:	e000ed00 	.word	0xe000ed00
  202b30:	200009d0 	.word	0x200009d0
  202b34:	00200303 	.word	0x00200303
  202b38:	00200306 	.word	0x00200306
  202b3c:	00000000 	.word	0x00000000

00202b40 <Vector80>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  202b40:	4b15      	ldr	r3, [pc, #84]	; (202b98 <Vector80+0x58>)
  DMA1->HIFCR = flags << 6U;
  if (dma.streams[5].func)
  202b42:	4816      	ldr	r0, [pc, #88]	; (202b9c <Vector80+0x5c>)
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  202b44:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[5].func)
  202b46:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
  202b48:	0989      	lsrs	r1, r1, #6
  202b4a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
  202b4e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 6U;
  202b50:	018c      	lsls	r4, r1, #6
  202b52:	60dc      	str	r4, [r3, #12]
  if (dma.streams[5].func)
  202b54:	b10a      	cbz	r2, 202b5a <Vector80+0x1a>
    dma.streams[5].func(dma.streams[5].param, flags);
  202b56:	6b00      	ldr	r0, [r0, #48]	; 0x30
  202b58:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202b5a:	2320      	movs	r3, #32
  202b5c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202b60:	4b0f      	ldr	r3, [pc, #60]	; (202ba0 <Vector80+0x60>)
  202b62:	685b      	ldr	r3, [r3, #4]
  202b64:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202b68:	d102      	bne.n	202b70 <Vector80+0x30>
  202b6a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202b6e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202b70:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202b74:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202b78:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202b7a:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202b7c:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202b80:	4a08      	ldr	r2, [pc, #32]	; (202ba4 <Vector80+0x64>)
  202b82:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202b84:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202b86:	6889      	ldr	r1, [r1, #8]
  202b88:	6892      	ldr	r2, [r2, #8]
  202b8a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202b8c:	bf8c      	ite	hi
  202b8e:	4a06      	ldrhi	r2, [pc, #24]	; (202ba8 <Vector80+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202b90:	4a06      	ldrls	r2, [pc, #24]	; (202bac <Vector80+0x6c>)
  202b92:	619a      	str	r2, [r3, #24]
  202b94:	bd10      	pop	{r4, pc}
  202b96:	bf00      	nop
  202b98:	40026000 	.word	0x40026000
  202b9c:	20000f10 	.word	0x20000f10
  202ba0:	e000ed00 	.word	0xe000ed00
  202ba4:	200009d0 	.word	0x200009d0
  202ba8:	00200303 	.word	0x00200303
  202bac:	00200306 	.word	0x00200306

00202bb0 <Vector84>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  202bb0:	4b15      	ldr	r3, [pc, #84]	; (202c08 <Vector84+0x58>)
  DMA1->HIFCR = flags << 16U;
  if (dma.streams[6].func)
  202bb2:	4816      	ldr	r0, [pc, #88]	; (202c0c <Vector84+0x5c>)
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  202bb4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[6].func)
  202bb6:	6b42      	ldr	r2, [r0, #52]	; 0x34
  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
  202bb8:	0c09      	lsrs	r1, r1, #16
  202bba:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
  202bbe:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 16U;
  202bc0:	040c      	lsls	r4, r1, #16
  202bc2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[6].func)
  202bc4:	b10a      	cbz	r2, 202bca <Vector84+0x1a>
    dma.streams[6].func(dma.streams[6].param, flags);
  202bc6:	6b80      	ldr	r0, [r0, #56]	; 0x38
  202bc8:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202bca:	2320      	movs	r3, #32
  202bcc:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202bd0:	4b0f      	ldr	r3, [pc, #60]	; (202c10 <Vector84+0x60>)
  202bd2:	685b      	ldr	r3, [r3, #4]
  202bd4:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202bd8:	d102      	bne.n	202be0 <Vector84+0x30>
  202bda:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202bde:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202be0:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202be4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202be8:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202bea:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202bec:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202bf0:	4a08      	ldr	r2, [pc, #32]	; (202c14 <Vector84+0x64>)
  202bf2:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202bf4:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202bf6:	6889      	ldr	r1, [r1, #8]
  202bf8:	6892      	ldr	r2, [r2, #8]
  202bfa:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202bfc:	bf8c      	ite	hi
  202bfe:	4a06      	ldrhi	r2, [pc, #24]	; (202c18 <Vector84+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202c00:	4a06      	ldrls	r2, [pc, #24]	; (202c1c <Vector84+0x6c>)
  202c02:	619a      	str	r2, [r3, #24]
  202c04:	bd10      	pop	{r4, pc}
  202c06:	bf00      	nop
  202c08:	40026000 	.word	0x40026000
  202c0c:	20000f10 	.word	0x20000f10
  202c10:	e000ed00 	.word	0xe000ed00
  202c14:	200009d0 	.word	0x200009d0
  202c18:	00200303 	.word	0x00200303
  202c1c:	00200306 	.word	0x00200306

00202c20 <VectorFC>:
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  202c20:	4b15      	ldr	r3, [pc, #84]	; (202c78 <VectorFC+0x58>)
  DMA1->HIFCR = flags << 22U;
  if (dma.streams[7].func)
  202c22:	4816      	ldr	r0, [pc, #88]	; (202c7c <VectorFC+0x5c>)
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  202c24:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[7].func)
  202c26:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
  202c28:	0d89      	lsrs	r1, r1, #22
  202c2a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
  202c2e:	b510      	push	{r4, lr}
  DMA1->HIFCR = flags << 22U;
  202c30:	058c      	lsls	r4, r1, #22
  202c32:	60dc      	str	r4, [r3, #12]
  if (dma.streams[7].func)
  202c34:	b10a      	cbz	r2, 202c3a <VectorFC+0x1a>
    dma.streams[7].func(dma.streams[7].param, flags);
  202c36:	6c00      	ldr	r0, [r0, #64]	; 0x40
  202c38:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202c3a:	2320      	movs	r3, #32
  202c3c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202c40:	4b0f      	ldr	r3, [pc, #60]	; (202c80 <VectorFC+0x60>)
  202c42:	685b      	ldr	r3, [r3, #4]
  202c44:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202c48:	d102      	bne.n	202c50 <VectorFC+0x30>
  202c4a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202c4e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202c50:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202c54:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202c58:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202c5a:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202c5c:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202c60:	4a08      	ldr	r2, [pc, #32]	; (202c84 <VectorFC+0x64>)
  202c62:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202c64:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202c66:	6889      	ldr	r1, [r1, #8]
  202c68:	6892      	ldr	r2, [r2, #8]
  202c6a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202c6c:	bf8c      	ite	hi
  202c6e:	4a06      	ldrhi	r2, [pc, #24]	; (202c88 <VectorFC+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202c70:	4a06      	ldrls	r2, [pc, #24]	; (202c8c <VectorFC+0x6c>)
  202c72:	619a      	str	r2, [r3, #24]
  202c74:	bd10      	pop	{r4, pc}
  202c76:	bf00      	nop
  202c78:	40026000 	.word	0x40026000
  202c7c:	20000f10 	.word	0x20000f10
  202c80:	e000ed00 	.word	0xe000ed00
  202c84:	200009d0 	.word	0x200009d0
  202c88:	00200303 	.word	0x00200303
  202c8c:	00200306 	.word	0x00200306

00202c90 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
  202c90:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  202c92:	4b14      	ldr	r3, [pc, #80]	; (202ce4 <Vector120+0x54>)
  DMA2->LIFCR = flags << 0U;
  if (dma.streams[8].func)
  202c94:	4814      	ldr	r0, [pc, #80]	; (202ce8 <Vector120+0x58>)
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  202c96:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[8].func)
  202c98:	6c42      	ldr	r2, [r0, #68]	; 0x44
  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
  202c9a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->LIFCR = flags << 0U;
  202c9e:	6099      	str	r1, [r3, #8]
  if (dma.streams[8].func)
  202ca0:	b10a      	cbz	r2, 202ca6 <Vector120+0x16>
    dma.streams[8].func(dma.streams[8].param, flags);
  202ca2:	6c80      	ldr	r0, [r0, #72]	; 0x48
  202ca4:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202ca6:	2320      	movs	r3, #32
  202ca8:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202cac:	4b0f      	ldr	r3, [pc, #60]	; (202cec <Vector120+0x5c>)
  202cae:	685b      	ldr	r3, [r3, #4]
  202cb0:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202cb4:	d102      	bne.n	202cbc <Vector120+0x2c>
  202cb6:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202cba:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202cbc:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202cc0:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202cc4:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202cc6:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202cc8:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202ccc:	4a08      	ldr	r2, [pc, #32]	; (202cf0 <Vector120+0x60>)
  202cce:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202cd0:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202cd2:	6889      	ldr	r1, [r1, #8]
  202cd4:	6892      	ldr	r2, [r2, #8]
  202cd6:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202cd8:	bf8c      	ite	hi
  202cda:	4a06      	ldrhi	r2, [pc, #24]	; (202cf4 <Vector120+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202cdc:	4a06      	ldrls	r2, [pc, #24]	; (202cf8 <Vector120+0x68>)
  202cde:	619a      	str	r2, [r3, #24]
  202ce0:	bd08      	pop	{r3, pc}
  202ce2:	bf00      	nop
  202ce4:	40026400 	.word	0x40026400
  202ce8:	20000f10 	.word	0x20000f10
  202cec:	e000ed00 	.word	0xe000ed00
  202cf0:	200009d0 	.word	0x200009d0
  202cf4:	00200303 	.word	0x00200303
  202cf8:	00200306 	.word	0x00200306
  202cfc:	00000000 	.word	0x00000000

00202d00 <Vector124>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  202d00:	4b15      	ldr	r3, [pc, #84]	; (202d58 <Vector124+0x58>)
  DMA2->LIFCR = flags << 6U;
  if (dma.streams[9].func)
  202d02:	4816      	ldr	r0, [pc, #88]	; (202d5c <Vector124+0x5c>)
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  202d04:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[9].func)
  202d06:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
  202d08:	0989      	lsrs	r1, r1, #6
  202d0a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
  202d0e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 6U;
  202d10:	018c      	lsls	r4, r1, #6
  202d12:	609c      	str	r4, [r3, #8]
  if (dma.streams[9].func)
  202d14:	b10a      	cbz	r2, 202d1a <Vector124+0x1a>
    dma.streams[9].func(dma.streams[9].param, flags);
  202d16:	6d00      	ldr	r0, [r0, #80]	; 0x50
  202d18:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202d1a:	2320      	movs	r3, #32
  202d1c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202d20:	4b0f      	ldr	r3, [pc, #60]	; (202d60 <Vector124+0x60>)
  202d22:	685b      	ldr	r3, [r3, #4]
  202d24:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202d28:	d102      	bne.n	202d30 <Vector124+0x30>
  202d2a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202d2e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202d30:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202d34:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202d38:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202d3a:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202d3c:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202d40:	4a08      	ldr	r2, [pc, #32]	; (202d64 <Vector124+0x64>)
  202d42:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202d44:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202d46:	6889      	ldr	r1, [r1, #8]
  202d48:	6892      	ldr	r2, [r2, #8]
  202d4a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202d4c:	bf8c      	ite	hi
  202d4e:	4a06      	ldrhi	r2, [pc, #24]	; (202d68 <Vector124+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202d50:	4a06      	ldrls	r2, [pc, #24]	; (202d6c <Vector124+0x6c>)
  202d52:	619a      	str	r2, [r3, #24]
  202d54:	bd10      	pop	{r4, pc}
  202d56:	bf00      	nop
  202d58:	40026400 	.word	0x40026400
  202d5c:	20000f10 	.word	0x20000f10
  202d60:	e000ed00 	.word	0xe000ed00
  202d64:	200009d0 	.word	0x200009d0
  202d68:	00200303 	.word	0x00200303
  202d6c:	00200306 	.word	0x00200306

00202d70 <Vector128>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  202d70:	4b15      	ldr	r3, [pc, #84]	; (202dc8 <Vector128+0x58>)
  DMA2->LIFCR = flags << 16U;
  if (dma.streams[10].func)
  202d72:	4816      	ldr	r0, [pc, #88]	; (202dcc <Vector128+0x5c>)
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  202d74:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[10].func)
  202d76:	6d42      	ldr	r2, [r0, #84]	; 0x54
  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
  202d78:	0c09      	lsrs	r1, r1, #16
  202d7a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
  202d7e:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 16U;
  202d80:	040c      	lsls	r4, r1, #16
  202d82:	609c      	str	r4, [r3, #8]
  if (dma.streams[10].func)
  202d84:	b10a      	cbz	r2, 202d8a <Vector128+0x1a>
    dma.streams[10].func(dma.streams[10].param, flags);
  202d86:	6d80      	ldr	r0, [r0, #88]	; 0x58
  202d88:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202d8a:	2320      	movs	r3, #32
  202d8c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202d90:	4b0f      	ldr	r3, [pc, #60]	; (202dd0 <Vector128+0x60>)
  202d92:	685b      	ldr	r3, [r3, #4]
  202d94:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202d98:	d102      	bne.n	202da0 <Vector128+0x30>
  202d9a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202d9e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202da0:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202da4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202da8:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202daa:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202dac:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202db0:	4a08      	ldr	r2, [pc, #32]	; (202dd4 <Vector128+0x64>)
  202db2:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202db4:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202db6:	6889      	ldr	r1, [r1, #8]
  202db8:	6892      	ldr	r2, [r2, #8]
  202dba:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202dbc:	bf8c      	ite	hi
  202dbe:	4a06      	ldrhi	r2, [pc, #24]	; (202dd8 <Vector128+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202dc0:	4a06      	ldrls	r2, [pc, #24]	; (202ddc <Vector128+0x6c>)
  202dc2:	619a      	str	r2, [r3, #24]
  202dc4:	bd10      	pop	{r4, pc}
  202dc6:	bf00      	nop
  202dc8:	40026400 	.word	0x40026400
  202dcc:	20000f10 	.word	0x20000f10
  202dd0:	e000ed00 	.word	0xe000ed00
  202dd4:	200009d0 	.word	0x200009d0
  202dd8:	00200303 	.word	0x00200303
  202ddc:	00200306 	.word	0x00200306

00202de0 <Vector12C>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  202de0:	4b15      	ldr	r3, [pc, #84]	; (202e38 <Vector12C+0x58>)
  DMA2->LIFCR = flags << 22U;
  if (dma.streams[11].func)
  202de2:	4816      	ldr	r0, [pc, #88]	; (202e3c <Vector12C+0x5c>)
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  202de4:	6819      	ldr	r1, [r3, #0]
  if (dma.streams[11].func)
  202de6:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
  202de8:	0d89      	lsrs	r1, r1, #22
  202dea:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
  202dee:	b510      	push	{r4, lr}
  DMA2->LIFCR = flags << 22U;
  202df0:	058c      	lsls	r4, r1, #22
  202df2:	609c      	str	r4, [r3, #8]
  if (dma.streams[11].func)
  202df4:	b10a      	cbz	r2, 202dfa <Vector12C+0x1a>
    dma.streams[11].func(dma.streams[11].param, flags);
  202df6:	6e00      	ldr	r0, [r0, #96]	; 0x60
  202df8:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202dfa:	2320      	movs	r3, #32
  202dfc:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202e00:	4b0f      	ldr	r3, [pc, #60]	; (202e40 <Vector12C+0x60>)
  202e02:	685b      	ldr	r3, [r3, #4]
  202e04:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202e08:	d102      	bne.n	202e10 <Vector12C+0x30>
  202e0a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202e0e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202e10:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202e14:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202e18:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202e1a:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202e1c:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202e20:	4a08      	ldr	r2, [pc, #32]	; (202e44 <Vector12C+0x64>)
  202e22:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202e24:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202e26:	6889      	ldr	r1, [r1, #8]
  202e28:	6892      	ldr	r2, [r2, #8]
  202e2a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202e2c:	bf8c      	ite	hi
  202e2e:	4a06      	ldrhi	r2, [pc, #24]	; (202e48 <Vector12C+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202e30:	4a06      	ldrls	r2, [pc, #24]	; (202e4c <Vector12C+0x6c>)
  202e32:	619a      	str	r2, [r3, #24]
  202e34:	bd10      	pop	{r4, pc}
  202e36:	bf00      	nop
  202e38:	40026400 	.word	0x40026400
  202e3c:	20000f10 	.word	0x20000f10
  202e40:	e000ed00 	.word	0xe000ed00
  202e44:	200009d0 	.word	0x200009d0
  202e48:	00200303 	.word	0x00200303
  202e4c:	00200306 	.word	0x00200306

00202e50 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
  202e50:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  202e52:	4b14      	ldr	r3, [pc, #80]	; (202ea4 <Vector130+0x54>)
  DMA2->HIFCR = flags << 0U;
  if (dma.streams[12].func)
  202e54:	4814      	ldr	r0, [pc, #80]	; (202ea8 <Vector130+0x58>)
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  202e56:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[12].func)
  202e58:	6e42      	ldr	r2, [r0, #100]	; 0x64
  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
  202e5a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
  DMA2->HIFCR = flags << 0U;
  202e5e:	60d9      	str	r1, [r3, #12]
  if (dma.streams[12].func)
  202e60:	b10a      	cbz	r2, 202e66 <Vector130+0x16>
    dma.streams[12].func(dma.streams[12].param, flags);
  202e62:	6e80      	ldr	r0, [r0, #104]	; 0x68
  202e64:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202e66:	2320      	movs	r3, #32
  202e68:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202e6c:	4b0f      	ldr	r3, [pc, #60]	; (202eac <Vector130+0x5c>)
  202e6e:	685b      	ldr	r3, [r3, #4]
  202e70:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202e74:	d102      	bne.n	202e7c <Vector130+0x2c>
  202e76:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202e7a:	bd08      	pop	{r3, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202e7c:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202e80:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202e84:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202e86:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202e88:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202e8c:	4a08      	ldr	r2, [pc, #32]	; (202eb0 <Vector130+0x60>)
  202e8e:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202e90:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202e92:	6889      	ldr	r1, [r1, #8]
  202e94:	6892      	ldr	r2, [r2, #8]
  202e96:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202e98:	bf8c      	ite	hi
  202e9a:	4a06      	ldrhi	r2, [pc, #24]	; (202eb4 <Vector130+0x64>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202e9c:	4a06      	ldrls	r2, [pc, #24]	; (202eb8 <Vector130+0x68>)
  202e9e:	619a      	str	r2, [r3, #24]
  202ea0:	bd08      	pop	{r3, pc}
  202ea2:	bf00      	nop
  202ea4:	40026400 	.word	0x40026400
  202ea8:	20000f10 	.word	0x20000f10
  202eac:	e000ed00 	.word	0xe000ed00
  202eb0:	200009d0 	.word	0x200009d0
  202eb4:	00200303 	.word	0x00200303
  202eb8:	00200306 	.word	0x00200306
  202ebc:	00000000 	.word	0x00000000

00202ec0 <Vector150>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  202ec0:	4b15      	ldr	r3, [pc, #84]	; (202f18 <Vector150+0x58>)
  DMA2->HIFCR = flags << 6U;
  if (dma.streams[13].func)
  202ec2:	4816      	ldr	r0, [pc, #88]	; (202f1c <Vector150+0x5c>)
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  202ec4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[13].func)
  202ec6:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
  202ec8:	0989      	lsrs	r1, r1, #6
  202eca:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
  202ece:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 6U;
  202ed0:	018c      	lsls	r4, r1, #6
  202ed2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[13].func)
  202ed4:	b10a      	cbz	r2, 202eda <Vector150+0x1a>
    dma.streams[13].func(dma.streams[13].param, flags);
  202ed6:	6f00      	ldr	r0, [r0, #112]	; 0x70
  202ed8:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202eda:	2320      	movs	r3, #32
  202edc:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202ee0:	4b0f      	ldr	r3, [pc, #60]	; (202f20 <Vector150+0x60>)
  202ee2:	685b      	ldr	r3, [r3, #4]
  202ee4:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202ee8:	d102      	bne.n	202ef0 <Vector150+0x30>
  202eea:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202eee:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202ef0:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202ef4:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202ef8:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202efa:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202efc:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202f00:	4a08      	ldr	r2, [pc, #32]	; (202f24 <Vector150+0x64>)
  202f02:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202f04:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202f06:	6889      	ldr	r1, [r1, #8]
  202f08:	6892      	ldr	r2, [r2, #8]
  202f0a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202f0c:	bf8c      	ite	hi
  202f0e:	4a06      	ldrhi	r2, [pc, #24]	; (202f28 <Vector150+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202f10:	4a06      	ldrls	r2, [pc, #24]	; (202f2c <Vector150+0x6c>)
  202f12:	619a      	str	r2, [r3, #24]
  202f14:	bd10      	pop	{r4, pc}
  202f16:	bf00      	nop
  202f18:	40026400 	.word	0x40026400
  202f1c:	20000f10 	.word	0x20000f10
  202f20:	e000ed00 	.word	0xe000ed00
  202f24:	200009d0 	.word	0x200009d0
  202f28:	00200303 	.word	0x00200303
  202f2c:	00200306 	.word	0x00200306

00202f30 <Vector154>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  202f30:	4b15      	ldr	r3, [pc, #84]	; (202f88 <Vector154+0x58>)
  DMA2->HIFCR = flags << 16U;
  if (dma.streams[14].func)
  202f32:	4816      	ldr	r0, [pc, #88]	; (202f8c <Vector154+0x5c>)
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  202f34:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[14].func)
  202f36:	6f42      	ldr	r2, [r0, #116]	; 0x74
  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
  202f38:	0c09      	lsrs	r1, r1, #16
  202f3a:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
  202f3e:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 16U;
  202f40:	040c      	lsls	r4, r1, #16
  202f42:	60dc      	str	r4, [r3, #12]
  if (dma.streams[14].func)
  202f44:	b10a      	cbz	r2, 202f4a <Vector154+0x1a>
    dma.streams[14].func(dma.streams[14].param, flags);
  202f46:	6f80      	ldr	r0, [r0, #120]	; 0x78
  202f48:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202f4a:	2320      	movs	r3, #32
  202f4c:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202f50:	4b0f      	ldr	r3, [pc, #60]	; (202f90 <Vector154+0x60>)
  202f52:	685b      	ldr	r3, [r3, #4]
  202f54:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202f58:	d102      	bne.n	202f60 <Vector154+0x30>
  202f5a:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202f5e:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202f60:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202f64:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202f68:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202f6a:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202f6c:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202f70:	4a08      	ldr	r2, [pc, #32]	; (202f94 <Vector154+0x64>)
  202f72:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202f74:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202f76:	6889      	ldr	r1, [r1, #8]
  202f78:	6892      	ldr	r2, [r2, #8]
  202f7a:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202f7c:	bf8c      	ite	hi
  202f7e:	4a06      	ldrhi	r2, [pc, #24]	; (202f98 <Vector154+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202f80:	4a06      	ldrls	r2, [pc, #24]	; (202f9c <Vector154+0x6c>)
  202f82:	619a      	str	r2, [r3, #24]
  202f84:	bd10      	pop	{r4, pc}
  202f86:	bf00      	nop
  202f88:	40026400 	.word	0x40026400
  202f8c:	20000f10 	.word	0x20000f10
  202f90:	e000ed00 	.word	0xe000ed00
  202f94:	200009d0 	.word	0x200009d0
  202f98:	00200303 	.word	0x00200303
  202f9c:	00200306 	.word	0x00200306

00202fa0 <Vector158>:
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  202fa0:	4b15      	ldr	r3, [pc, #84]	; (202ff8 <Vector158+0x58>)
  DMA2->HIFCR = flags << 22U;
  if (dma.streams[15].func)
  202fa2:	4816      	ldr	r0, [pc, #88]	; (202ffc <Vector158+0x5c>)
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  202fa4:	6859      	ldr	r1, [r3, #4]
  if (dma.streams[15].func)
  202fa6:	6fc2      	ldr	r2, [r0, #124]	; 0x7c
  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
  202fa8:	0d89      	lsrs	r1, r1, #22
  202faa:	f001 013d 	and.w	r1, r1, #61	; 0x3d
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
  202fae:	b510      	push	{r4, lr}
  DMA2->HIFCR = flags << 22U;
  202fb0:	058c      	lsls	r4, r1, #22
  202fb2:	60dc      	str	r4, [r3, #12]
  if (dma.streams[15].func)
  202fb4:	b112      	cbz	r2, 202fbc <Vector158+0x1c>
    dma.streams[15].func(dma.streams[15].param, flags);
  202fb6:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
  202fba:	4790      	blx	r2
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  202fbc:	2320      	movs	r3, #32
  202fbe:	f383 8811 	msr	BASEPRI, r3
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  202fc2:	4b0f      	ldr	r3, [pc, #60]	; (203000 <Vector158+0x60>)
  202fc4:	685b      	ldr	r3, [r3, #4]
  202fc6:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  202fca:	d102      	bne.n	202fd2 <Vector158+0x32>
  202fcc:	f383 8811 	msr	BASEPRI, r3

  OSAL_IRQ_EPILOGUE();
}
  202fd0:	bd10      	pop	{r4, pc}
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  202fd2:	f3ef 8309 	mrs	r3, PSP
    ectxp->xpsr = 0x01000000U;
  202fd6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
    s_psp -= sizeof (struct port_extctx);
  202fda:	3b20      	subs	r3, #32
    ectxp->xpsr = 0x01000000U;
  202fdc:	61da      	str	r2, [r3, #28]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  202fde:	f383 8809 	msr	PSP, r3
  tprio_t p1 = firstprio(&ch.rlist.pqueue);
  202fe2:	4a08      	ldr	r2, [pc, #32]	; (203004 <Vector158+0x64>)
  202fe4:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->hdr.pqueue.prio;
  202fe6:	6992      	ldr	r2, [r2, #24]
    if (chSchIsPreemptionRequired()) {
  202fe8:	6889      	ldr	r1, [r1, #8]
  202fea:	6892      	ldr	r2, [r2, #8]
  202fec:	4291      	cmp	r1, r2
      ectxp->pc = (uint32_t)_port_switch_from_isr;
  202fee:	bf8c      	ite	hi
  202ff0:	4a05      	ldrhi	r2, [pc, #20]	; (203008 <Vector158+0x68>)
      ectxp->pc = (uint32_t)_port_exit_from_isr;
  202ff2:	4a06      	ldrls	r2, [pc, #24]	; (20300c <Vector158+0x6c>)
  202ff4:	619a      	str	r2, [r3, #24]
  202ff6:	bd10      	pop	{r4, pc}
  202ff8:	40026400 	.word	0x40026400
  202ffc:	20000f10 	.word	0x20000f10
  203000:	e000ed00 	.word	0xe000ed00
  203004:	200009d0 	.word	0x200009d0
  203008:	00200303 	.word	0x00200303
  20300c:	00200306 	.word	0x00200306

00203010 <__early_init>:

static void stm32_gpio_init(void) {

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
  203010:	4a9d      	ldr	r2, [pc, #628]	; (203288 <__early_init+0x278>)
  203012:	f240 70ff 	movw	r0, #2047	; 0x7ff
  203016:	499d      	ldr	r1, [pc, #628]	; (20328c <__early_init+0x27c>)
  gpiop->OTYPER  = config->otyper;
  203018:	2300      	movs	r3, #0
  20301a:	f8df c274 	ldr.w	ip, [pc, #628]	; 203290 <__early_init+0x280>
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
  20301e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  rccResetAHB1(STM32_GPIO_EN_MASK);
  203022:	6914      	ldr	r4, [r2, #16]
  gpiop->OTYPER  = config->otyper;
  203024:	f8df a26c 	ldr.w	sl, [pc, #620]	; 203294 <__early_init+0x284>
  rccResetAHB1(STM32_GPIO_EN_MASK);
  203028:	4304      	orrs	r4, r0
  gpiop->OTYPER  = config->otyper;
  20302a:	f8df 926c 	ldr.w	r9, [pc, #620]	; 203298 <__early_init+0x288>
  20302e:	f8df 826c 	ldr.w	r8, [pc, #620]	; 20329c <__early_init+0x28c>
  rccResetAHB1(STM32_GPIO_EN_MASK);
  203032:	6114      	str	r4, [r2, #16]
  203034:	6914      	ldr	r4, [r2, #16]
  gpiop->OTYPER  = config->otyper;
  203036:	f8df e268 	ldr.w	lr, [pc, #616]	; 2032a0 <__early_init+0x290>
  rccResetAHB1(STM32_GPIO_EN_MASK);
  20303a:	4021      	ands	r1, r4
  gpiop->OTYPER  = config->otyper;
  20303c:	4f99      	ldr	r7, [pc, #612]	; (2032a4 <__early_init+0x294>)
  20303e:	4e9a      	ldr	r6, [pc, #616]	; (2032a8 <__early_init+0x298>)
  rccResetAHB1(STM32_GPIO_EN_MASK);
  203040:	6111      	str	r1, [r2, #16]
  203042:	6911      	ldr	r1, [r2, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  203044:	6b11      	ldr	r1, [r2, #48]	; 0x30
  gpiop->OTYPER  = config->otyper;
  203046:	4d99      	ldr	r5, [pc, #612]	; (2032ac <__early_init+0x29c>)
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  203048:	4301      	orrs	r1, r0
  gpiop->OTYPER  = config->otyper;
  20304a:	4c99      	ldr	r4, [pc, #612]	; (2032b0 <__early_init+0x2a0>)
  20304c:	f8df b264 	ldr.w	fp, [pc, #612]	; 2032b4 <__early_init+0x2a4>
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  203050:	6311      	str	r1, [r2, #48]	; 0x30
  203052:	6d11      	ldr	r1, [r2, #80]	; 0x50
  203054:	4301      	orrs	r1, r0
  gpiop->PUPDR   = config->pupdr;
  203056:	4898      	ldr	r0, [pc, #608]	; (2032b8 <__early_init+0x2a8>)
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
  203058:	6511      	str	r1, [r2, #80]	; 0x50
  20305a:	6d11      	ldr	r1, [r2, #80]	; 0x50
  gpiop->OSPEEDR = config->ospeedr;
  20305c:	f04f 31ff 	mov.w	r1, #4294967295
  gpiop->OTYPER  = config->otyper;
  203060:	f8ca 3004 	str.w	r3, [sl, #4]
  gpiop->OSPEEDR = config->ospeedr;
  203064:	f8ca 1008 	str.w	r1, [sl, #8]
  gpiop->ODR     = config->odr;
  203068:	f64f 71ff 	movw	r1, #65535	; 0xffff
  gpiop->PUPDR   = config->pupdr;
  20306c:	f8ca 000c 	str.w	r0, [sl, #12]
  gpiop->AFRL    = config->afrl;
  203070:	4892      	ldr	r0, [pc, #584]	; (2032bc <__early_init+0x2ac>)
  gpiop->ODR     = config->odr;
  203072:	f8ca 1014 	str.w	r1, [sl, #20]
  gpiop->AFRL    = config->afrl;
  203076:	f8ca 0020 	str.w	r0, [sl, #32]
  gpiop->AFRH    = config->afrh;
  20307a:	4891      	ldr	r0, [pc, #580]	; (2032c0 <__early_init+0x2b0>)
  20307c:	f8ca 0024 	str.w	r0, [sl, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203080:	4890      	ldr	r0, [pc, #576]	; (2032c4 <__early_init+0x2b4>)
  203082:	f8ca 0000 	str.w	r0, [sl]
  gpiop->OSPEEDR = config->ospeedr;
  203086:	f04f 3aff 	mov.w	sl, #4294967295
  gpiop->OTYPER  = config->otyper;
  20308a:	f8c9 3004 	str.w	r3, [r9, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20308e:	f8c9 a008 	str.w	sl, [r9, #8]
  gpiop->PUPDR   = config->pupdr;
  203092:	f10a 4a8a 	add.w	sl, sl, #1157627904	; 0x45000000
  gpiop->OTYPER  = config->otyper;
  203096:	488c      	ldr	r0, [pc, #560]	; (2032c8 <__early_init+0x2b8>)
  gpiop->PUPDR   = config->pupdr;
  203098:	f10a 1a55 	add.w	sl, sl, #5570645	; 0x550055
  20309c:	f50a 5aa8 	add.w	sl, sl, #5376	; 0x1500
  2030a0:	f8c9 a00c 	str.w	sl, [r9, #12]
  gpiop->ODR     = config->odr;
  2030a4:	f64b 7a7e 	movw	sl, #49022	; 0xbf7e
  2030a8:	f8c9 a014 	str.w	sl, [r9, #20]
  gpiop->AFRH    = config->afrh;
  2030ac:	f44f 0a30 	mov.w	sl, #11534336	; 0xb00000
  gpiop->AFRL    = config->afrl;
  2030b0:	f8c9 3020 	str.w	r3, [r9, #32]
  gpiop->AFRH    = config->afrh;
  2030b4:	f8c9 a024 	str.w	sl, [r9, #36]	; 0x24
  gpiop->MODER   = config->moder;
  2030b8:	f8df a210 	ldr.w	sl, [pc, #528]	; 2032cc <__early_init+0x2bc>
  2030bc:	f8c9 a000 	str.w	sl, [r9]
  gpiop->OSPEEDR = config->ospeedr;
  2030c0:	f06f 4970 	mvn.w	r9, #4026531840	; 0xf0000000
  gpiop->OTYPER  = config->otyper;
  2030c4:	f8c8 3004 	str.w	r3, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
  2030c8:	f8c8 9008 	str.w	r9, [r8, #8]
  gpiop->PUPDR   = config->pupdr;
  2030cc:	f8df 9200 	ldr.w	r9, [pc, #512]	; 2032d0 <__early_init+0x2c0>
  2030d0:	f8c8 900c 	str.w	r9, [r8, #12]
  gpiop->AFRL    = config->afrl;
  2030d4:	f8df 91fc 	ldr.w	r9, [pc, #508]	; 2032d4 <__early_init+0x2c4>
  gpiop->ODR     = config->odr;
  2030d8:	f8c8 1014 	str.w	r1, [r8, #20]
  gpiop->AFRL    = config->afrl;
  2030dc:	f8c8 9020 	str.w	r9, [r8, #32]
  gpiop->MODER   = config->moder;
  2030e0:	f640 2908 	movw	r9, #2568	; 0xa08
  gpiop->AFRH    = config->afrh;
  2030e4:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
  2030e8:	f8c8 9000 	str.w	r9, [r8]
  gpiop->OSPEEDR = config->ospeedr;
  2030ec:	f46f 1840 	mvn.w	r8, #3145728	; 0x300000
  gpiop->OTYPER  = config->otyper;
  2030f0:	f8ce 3004 	str.w	r3, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
  2030f4:	f8ce 8008 	str.w	r8, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
  2030f8:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 2032d8 <__early_init+0x2c8>
  2030fc:	f8ce 800c 	str.w	r8, [lr, #12]
  gpiop->AFRH    = config->afrh;
  203100:	f04f 0877 	mov.w	r8, #119	; 0x77
  gpiop->ODR     = config->odr;
  203104:	f8ce 1014 	str.w	r1, [lr, #20]
  gpiop->AFRL    = config->afrl;
  203108:	f8ce 3020 	str.w	r3, [lr, #32]
  gpiop->AFRH    = config->afrh;
  20310c:	f8ce 8024 	str.w	r8, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203110:	f44f 2820 	mov.w	r8, #655360	; 0xa0000
  203114:	f8ce 8000 	str.w	r8, [lr]
  gpiop->OSPEEDR = config->ospeedr;
  203118:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 2032dc <__early_init+0x2cc>
  gpiop->OTYPER  = config->otyper;
  20311c:	f8cc 3004 	str.w	r3, [ip, #4]
  gpiop->OSPEEDR = config->ospeedr;
  203120:	f8cc e008 	str.w	lr, [ip, #8]
  gpiop->PUPDR   = config->pupdr;
  203124:	f04f 3e55 	mov.w	lr, #1431655765	; 0x55555555
  203128:	f8cc e00c 	str.w	lr, [ip, #12]
  gpiop->ODR     = config->odr;
  20312c:	f8cc 1014 	str.w	r1, [ip, #20]
  gpiop->AFRL    = config->afrl;
  203130:	f8cc 3020 	str.w	r3, [ip, #32]
  gpiop->AFRH    = config->afrh;
  203134:	f8cc 3024 	str.w	r3, [ip, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203138:	f8cc 3000 	str.w	r3, [ip]
  gpiop->OSPEEDR = config->ospeedr;
  20313c:	f8df c1a0 	ldr.w	ip, [pc, #416]	; 2032e0 <__early_init+0x2d0>
  gpiop->OTYPER  = config->otyper;
  203140:	607b      	str	r3, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
  203142:	f8c7 c008 	str.w	ip, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
  203146:	f8c7 e00c 	str.w	lr, [r7, #12]
  gpiop->ODR     = config->odr;
  20314a:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
  20314c:	623b      	str	r3, [r7, #32]
  gpiop->AFRH    = config->afrh;
  20314e:	627b      	str	r3, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203150:	603b      	str	r3, [r7, #0]
  gpiop->OSPEEDR = config->ospeedr;
  203152:	4f64      	ldr	r7, [pc, #400]	; (2032e4 <__early_init+0x2d4>)
  gpiop->OTYPER  = config->otyper;
  203154:	6073      	str	r3, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
  203156:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
  203158:	4f63      	ldr	r7, [pc, #396]	; (2032e8 <__early_init+0x2d8>)
  20315a:	60f7      	str	r7, [r6, #12]
  gpiop->AFRH    = config->afrh;
  20315c:	4f63      	ldr	r7, [pc, #396]	; (2032ec <__early_init+0x2dc>)
  gpiop->ODR     = config->odr;
  20315e:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
  203160:	6233      	str	r3, [r6, #32]
  gpiop->AFRH    = config->afrh;
  203162:	6277      	str	r7, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
  203164:	f04f 6708 	mov.w	r7, #142606336	; 0x8800000
  203168:	6037      	str	r7, [r6, #0]
  gpiop->OSPEEDR = config->ospeedr;
  20316a:	260f      	movs	r6, #15
  gpiop->OTYPER  = config->otyper;
  20316c:	606b      	str	r3, [r5, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20316e:	60ae      	str	r6, [r5, #8]
  gpiop->PUPDR   = config->pupdr;
  203170:	4e5f      	ldr	r6, [pc, #380]	; (2032f0 <__early_init+0x2e0>)
  203172:	60ee      	str	r6, [r5, #12]
  gpiop->ODR     = config->odr;
  203174:	6169      	str	r1, [r5, #20]
  gpiop->AFRL    = config->afrl;
  203176:	622b      	str	r3, [r5, #32]
  gpiop->AFRH    = config->afrh;
  203178:	626b      	str	r3, [r5, #36]	; 0x24
  gpiop->MODER   = config->moder;
  20317a:	602b      	str	r3, [r5, #0]
  gpiop->OTYPER  = config->otyper;
  20317c:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20317e:	60a3      	str	r3, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
  203180:	f8c4 e00c 	str.w	lr, [r4, #12]
  gpiop->ODR     = config->odr;
  203184:	6161      	str	r1, [r4, #20]
  gpiop->AFRL    = config->afrl;
  203186:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
  203188:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
  20318a:	6023      	str	r3, [r4, #0]
  gpiop->OTYPER  = config->otyper;
  20318c:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
  20318e:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  203190:	f8c0 e00c 	str.w	lr, [r0, #12]
  gpiop->ODR     = config->odr;
  203194:	6141      	str	r1, [r0, #20]
  gpiop->AFRL    = config->afrl;
  203196:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
  203198:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  20319a:	6003      	str	r3, [r0, #0]
  gpiop->OTYPER  = config->otyper;
  20319c:	f8cb 3004 	str.w	r3, [fp, #4]
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enabled.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  2031a0:	4854      	ldr	r0, [pc, #336]	; (2032f4 <__early_init+0x2e4>)
  gpiop->OSPEEDR = config->ospeedr;
  2031a2:	f8cb 3008 	str.w	r3, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
  2031a6:	f8cb e00c 	str.w	lr, [fp, #12]
  gpiop->ODR     = config->odr;
  2031aa:	f8cb 1014 	str.w	r1, [fp, #20]
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
  PWR->CR1 = STM32_VOS;
  2031ae:	f44f 4140 	mov.w	r1, #49152	; 0xc000
  gpiop->AFRL    = config->afrl;
  2031b2:	f8cb 3020 	str.w	r3, [fp, #32]
  gpiop->AFRH    = config->afrh;
  2031b6:	f8cb 3024 	str.w	r3, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
  2031ba:	f8cb 3000 	str.w	r3, [fp]
  2031be:	4b4e      	ldr	r3, [pc, #312]	; (2032f8 <__early_init+0x2e8>)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  2031c0:	6410      	str	r0, [r2, #64]	; 0x40
  PWR->CR1 = STM32_VOS;
  2031c2:	6019      	str	r1, [r3, #0]

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  2031c4:	6813      	ldr	r3, [r2, #0]
  2031c6:	f043 0301 	orr.w	r3, r3, #1
  2031ca:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
  2031cc:	6813      	ldr	r3, [r2, #0]
  2031ce:	079d      	lsls	r5, r3, #30
  2031d0:	d5fc      	bpl.n	2031cc <__early_init+0x1bc>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
  2031d2:	6893      	ldr	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  2031d4:	492c      	ldr	r1, [pc, #176]	; (203288 <__early_init+0x278>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
  2031d6:	f023 0303 	bic.w	r3, r3, #3
  2031da:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  2031dc:	688b      	ldr	r3, [r1, #8]
  2031de:	f013 030c 	ands.w	r3, r3, #12
  2031e2:	d1fb      	bne.n	2031dc <__early_init+0x1cc>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  2031e4:	6808      	ldr	r0, [r1, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  2031e6:	4a28      	ldr	r2, [pc, #160]	; (203288 <__early_init+0x278>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  2031e8:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
  2031ec:	6008      	str	r0, [r1, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  2031ee:	608b      	str	r3, [r1, #8]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
  2031f0:	680b      	ldr	r3, [r1, #0]
  2031f2:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
  2031f6:	600b      	str	r3, [r1, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  2031f8:	6813      	ldr	r3, [r2, #0]
  2031fa:	039c      	lsls	r4, r3, #14
  2031fc:	d5fc      	bpl.n	2031f8 <__early_init+0x1e8>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  2031fe:	4b3f      	ldr	r3, [pc, #252]	; (2032fc <__early_init+0x2ec>)
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;

  /* Synchronization with voltage regulator stabilization.*/
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  203200:	493d      	ldr	r1, [pc, #244]	; (2032f8 <__early_init+0x2e8>)
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  203202:	6053      	str	r3, [r2, #4]
  RCC->CR |= RCC_CR_PLLON;
  203204:	6813      	ldr	r3, [r2, #0]
  203206:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  20320a:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  20320c:	684b      	ldr	r3, [r1, #4]
  20320e:	0458      	lsls	r0, r3, #17
  203210:	d5fc      	bpl.n	20320c <__early_init+0x1fc>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR1 |= PWR_CR1_ODEN;
  203212:	680b      	ldr	r3, [r1, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  203214:	4a38      	ldr	r2, [pc, #224]	; (2032f8 <__early_init+0x2e8>)
  PWR->CR1 |= PWR_CR1_ODEN;
  203216:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  20321a:	600b      	str	r3, [r1, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  20321c:	6853      	ldr	r3, [r2, #4]
  20321e:	03d9      	lsls	r1, r3, #15
  203220:	d5fc      	bpl.n	20321c <__early_init+0x20c>
      ;
  PWR->CR1 |= PWR_CR1_ODSWEN;
  203222:	6813      	ldr	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  203224:	4934      	ldr	r1, [pc, #208]	; (2032f8 <__early_init+0x2e8>)
  PWR->CR1 |= PWR_CR1_ODSWEN;
  203226:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  20322a:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  20322c:	684b      	ldr	r3, [r1, #4]
  20322e:	039a      	lsls	r2, r3, #14
  203230:	d5fc      	bpl.n	20322c <__early_init+0x21c>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
  203232:	4a15      	ldr	r2, [pc, #84]	; (203288 <__early_init+0x278>)
  203234:	6813      	ldr	r3, [r2, #0]
  203236:	019b      	lsls	r3, r3, #6
  203238:	d5fc      	bpl.n	203234 <__early_init+0x224>
    dckcfgr1 |= STM32_SAI1SEL;
#endif
#if STM32_TIMPRE_ENABLE == TRUE
    dckcfgr1 |= RCC_DCKCFGR1_TIMPRE;
#endif
    RCC->DCKCFGR1 = dckcfgr1;
  20323a:	f240 1301 	movw	r3, #257	; 0x101
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  20323e:	4c30      	ldr	r4, [pc, #192]	; (203300 <__early_init+0x2f0>)
  }

  /* Peripheral clock sources.*/
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  203240:	2000      	movs	r0, #0
                  STM32_UART8SEL  | STM32_UART7SEL  | STM32_USART6SEL |
                  STM32_UART5SEL  | STM32_UART4SEL  | STM32_USART3SEL |
                  STM32_USART2SEL | STM32_USART1SEL;

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  203242:	4930      	ldr	r1, [pc, #192]	; (203304 <__early_init+0x2f4>)
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  203244:	6094      	str	r4, [r2, #8]
    RCC->DCKCFGR1 = dckcfgr1;
  203246:	f8c2 308c 	str.w	r3, [r2, #140]	; 0x8c
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  20324a:	f240 3307 	movw	r3, #775	; 0x307
  RCC->DCKCFGR2 = STM32_SDMMC2SEL | STM32_SDMMC1SEL | STM32_CK48MSEL  |
  20324e:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  203252:	600b      	str	r3, [r1, #0]
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
  203254:	680b      	ldr	r3, [r1, #0]
  203256:	f003 030f 	and.w	r3, r3, #15
  20325a:	2b07      	cmp	r3, #7
  20325c:	d1fa      	bne.n	203254 <__early_init+0x244>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  20325e:	4a0a      	ldr	r2, [pc, #40]	; (203288 <__early_init+0x278>)
  203260:	6893      	ldr	r3, [r2, #8]
  203262:	f043 0302 	orr.w	r3, r3, #2
  203266:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  203268:	6893      	ldr	r3, [r2, #8]
  20326a:	f003 030c 	and.w	r3, r3, #12
  20326e:	2b08      	cmp	r3, #8
  203270:	d1fa      	bne.n	203268 <__early_init+0x258>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
  203272:	6c53      	ldr	r3, [r2, #68]	; 0x44
  203274:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  203278:	6453      	str	r3, [r2, #68]	; 0x44
  20327a:	6e53      	ldr	r3, [r2, #100]	; 0x64
  20327c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  203280:	6653      	str	r3, [r2, #100]	; 0x64
  203282:	6e53      	ldr	r3, [r2, #100]	; 0x64

  stm32_gpio_init();
  stm32_clock_init();
}
  203284:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  203288:	40023800 	.word	0x40023800
  20328c:	fffff800 	.word	0xfffff800
  203290:	40021000 	.word	0x40021000
  203294:	40020000 	.word	0x40020000
  203298:	40020400 	.word	0x40020400
  20329c:	40020800 	.word	0x40020800
  2032a0:	40020c00 	.word	0x40020c00
  2032a4:	40021400 	.word	0x40021400
  2032a8:	40021800 	.word	0x40021800
  2032ac:	40021c00 	.word	0x40021c00
  2032b0:	40022000 	.word	0x40022000
  2032b4:	40022800 	.word	0x40022800
  2032b8:	40005551 	.word	0x40005551
  2032bc:	b0000bb0 	.word	0xb0000bb0
  2032c0:	000aaa0a 	.word	0x000aaa0a
  2032c4:	2aae8028 	.word	0x2aae8028
  2032c8:	40022400 	.word	0x40022400
  2032cc:	18004001 	.word	0x18004001
  2032d0:	01555051 	.word	0x01555051
  2032d4:	00bb00b0 	.word	0x00bb00b0
  2032d8:	55505555 	.word	0x55505555
  2032dc:	cffffff3 	.word	0xcffffff3
  2032e0:	003fcfff 	.word	0x003fcfff
  2032e4:	3cccf000 	.word	0x3cccf000
  2032e8:	51155555 	.word	0x51155555
  2032ec:	00b0b000 	.word	0x00b0b000
  2032f0:	55555550 	.word	0x55555550
  2032f4:	10000400 	.word	0x10000400
  2032f8:	40007000 	.word	0x40007000
  2032fc:	09406c08 	.word	0x09406c08
  203300:	30999400 	.word	0x30999400
  203304:	40023c00 	.word	0x40023c00
	...

00203310 <chSchDoReschedule>:
 *          itself.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;
  203310:	4a0f      	ldr	r2, [pc, #60]	; (203350 <chSchDoReschedule+0x40>)
  tp->state = CH_STATE_READY;
  203312:	f04f 0c00 	mov.w	ip, #0
  ch_priority_queue_t *p = pqp->next;
  203316:	6810      	ldr	r0, [r2, #0]
  return (thread_t *)ch_pqueue_insert_ahead(&ch.rlist.pqueue,
  203318:	4613      	mov	r3, r2
  thread_t *otp = currp;
  20331a:	6991      	ldr	r1, [r2, #24]
void chSchDoRescheduleAhead(void) {
  20331c:	b510      	push	{r4, lr}
  pqp->next       = p->next;
  20331e:	6804      	ldr	r4, [r0, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  currp->state = CH_STATE_CURRENT;
  203320:	f04f 0e01 	mov.w	lr, #1
  pqp->next->prev = pqp;
  203324:	6062      	str	r2, [r4, #4]
  pqp->next       = p->next;
  203326:	6014      	str	r4, [r2, #0]
  203328:	f880 e020 	strb.w	lr, [r0, #32]

  /* Handling idle-leave hook.*/
  if (otp->hdr.pqueue.prio == IDLEPRIO) {
  20332c:	688c      	ldr	r4, [r1, #8]
  tp->state = CH_STATE_READY;
  20332e:	f881 c020 	strb.w	ip, [r1, #32]
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  203332:	6190      	str	r0, [r2, #24]
    pqp = pqp->next;
  203334:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio > p->prio);
  203336:	689a      	ldr	r2, [r3, #8]
  203338:	4294      	cmp	r4, r2
  20333a:	d3fb      	bcc.n	203334 <chSchDoReschedule+0x24>
  p->prev       = pqp->prev;
  20333c:	685a      	ldr	r2, [r3, #4]
  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
  20333e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  203342:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  203346:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  203348:	6059      	str	r1, [r3, #4]
  chSysSwitch(currp, otp);
  20334a:	f7fc bfc9 	b.w	2002e0 <_port_switch>
  20334e:	bf00      	nop
  203350:	200009d0 	.word	0x200009d0
	...

00203360 <chMBFetchTimeoutS>:
 * @retval MSG_RESET    if the mailbox has been reset.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchTimeoutS(mailbox_t *mbp, msg_t *msgp, sysinterval_t timeout) {
  203360:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ch_queue_insert(&currp->hdr.queue, &tqp->queue);
  203364:	4f26      	ldr	r7, [pc, #152]	; (203400 <chMBFetchTimeoutS+0xa0>)
  203366:	4604      	mov	r4, r0
  203368:	4688      	mov	r8, r1
  20336a:	4691      	mov	r9, r2

      return MSG_OK;
    }

    /* No message in the queue, waiting for a message to become available.*/
    rdymsg = chThdEnqueueTimeoutS(&mbp->qr, timeout);
  20336c:	f100 0620 	add.w	r6, r0, #32
  203370:	e00a      	b.n	203388 <chMBFetchTimeoutS+0x28>
  return mbp->cnt;
  203372:	6923      	ldr	r3, [r4, #16]
    if (chMBGetUsedCountI(mbp) > (size_t)0) {
  203374:	b98b      	cbnz	r3, 20339a <chMBFetchTimeoutS+0x3a>
  203376:	69bb      	ldr	r3, [r7, #24]
  p->prev       = qp->prev;
  203378:	6a65      	ldr	r5, [r4, #36]	; 0x24
  20337a:	e9c3 6500 	strd	r6, r5, [r3]
  p->prev->next = p;
  20337e:	602b      	str	r3, [r5, #0]
  qp->prev      = p;
  203380:	6263      	str	r3, [r4, #36]	; 0x24
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
  203382:	f7fd fd55 	bl	200e30 <chSchGoSleepTimeoutS>
  } while (rdymsg == MSG_OK);
  203386:	b930      	cbnz	r0, 203396 <chMBFetchTimeoutS+0x36>
    if (mbp->reset) {
  203388:	7d23      	ldrb	r3, [r4, #20]
  20338a:	4649      	mov	r1, r9
  20338c:	2004      	movs	r0, #4
  20338e:	2b00      	cmp	r3, #0
  203390:	d0ef      	beq.n	203372 <chMBFetchTimeoutS+0x12>
      return MSG_RESET;
  203392:	f06f 0001 	mvn.w	r0, #1

  return rdymsg;
}
  203396:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
      *msgp = *mbp->rdptr++;
  20339a:	68e1      	ldr	r1, [r4, #12]
  20339c:	180a      	adds	r2, r1, r0
  20339e:	6809      	ldr	r1, [r1, #0]
  2033a0:	60e2      	str	r2, [r4, #12]
  2033a2:	f8c8 1000 	str.w	r1, [r8]
      if (mbp->rdptr >= mbp->top) {
  2033a6:	6861      	ldr	r1, [r4, #4]
  2033a8:	428a      	cmp	r2, r1
  2033aa:	d301      	bcc.n	2033b0 <chMBFetchTimeoutS+0x50>
        mbp->rdptr = mbp->buffer;
  2033ac:	6822      	ldr	r2, [r4, #0]
  2033ae:	60e2      	str	r2, [r4, #12]
      chThdDequeueNextI(&mbp->qw, MSG_OK);
  2033b0:	f104 0218 	add.w	r2, r4, #24
  return (bool)(qp->next != qp);
  2033b4:	69a1      	ldr	r1, [r4, #24]
      mbp->cnt--;
  2033b6:	3b01      	subs	r3, #1
  } while (pqp->prio >= p->prio);
  2033b8:	4d11      	ldr	r5, [pc, #68]	; (203400 <chMBFetchTimeoutS+0xa0>)
  if (ch_queue_notempty(&tqp->queue)) {
  2033ba:	428a      	cmp	r2, r1
  2033bc:	6123      	str	r3, [r4, #16]
  2033be:	d011      	beq.n	2033e4 <chMBFetchTimeoutS+0x84>
  qp->next       = p->next;
  2033c0:	680b      	ldr	r3, [r1, #0]
  } while (pqp->prio >= p->prio);
  2033c2:	6888      	ldr	r0, [r1, #8]
  qp->next       = p->next;
  2033c4:	61a3      	str	r3, [r4, #24]
  2033c6:	2400      	movs	r4, #0
  qp->next->prev = qp;
  2033c8:	605a      	str	r2, [r3, #4]
  } while (pqp->prio >= p->prio);
  2033ca:	462b      	mov	r3, r5
  2033cc:	624c      	str	r4, [r1, #36]	; 0x24
  tp->state = CH_STATE_READY;
  2033ce:	f881 4020 	strb.w	r4, [r1, #32]
    pqp = pqp->next;
  2033d2:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  2033d4:	689a      	ldr	r2, [r3, #8]
  2033d6:	4282      	cmp	r2, r0
  2033d8:	d2fb      	bcs.n	2033d2 <chMBFetchTimeoutS+0x72>
  p->prev       = pqp->prev;
  2033da:	685a      	ldr	r2, [r3, #4]
  2033dc:	e9c1 3200 	strd	r3, r2, [r1]
  p->prev->next = p;
  2033e0:	6011      	str	r1, [r2, #0]
  pqp->prev     = p;
  2033e2:	6059      	str	r1, [r3, #4]
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.pqueue) > currp->hdr.pqueue.prio;
  2033e4:	682a      	ldr	r2, [r5, #0]
  2033e6:	69ab      	ldr	r3, [r5, #24]
  if (chSchIsRescRequiredI()) {
  2033e8:	6892      	ldr	r2, [r2, #8]
  2033ea:	689b      	ldr	r3, [r3, #8]
  2033ec:	429a      	cmp	r2, r3
  2033ee:	d802      	bhi.n	2033f6 <chMBFetchTimeoutS+0x96>
      return MSG_OK;
  2033f0:	2000      	movs	r0, #0
}
  2033f2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    chSchDoRescheduleAhead();
  2033f6:	f7ff ff8b 	bl	203310 <chSchDoReschedule>
      return MSG_OK;
  2033fa:	2000      	movs	r0, #0
}
  2033fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  203400:	200009d0 	.word	0x200009d0
	...

00203410 <pid>:
int16_t set_speed=100;

static THD_WORKING_AREA(pidThread, 256);// 256 - stack size

static THD_FUNCTION(pid, arg)
{
  203410:	b580      	push	{r7, lr}
  203412:	f8df a0c0 	ldr.w	sl, [pc, #192]	; 2034d4 <pid+0xc4>
  203416:	b082      	sub	sp, #8
  203418:	4e2f      	ldr	r6, [pc, #188]	; (2034d8 <pid+0xc8>)
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  20341a:	2420      	movs	r4, #32
  20341c:	4f2f      	ldr	r7, [pc, #188]	; (2034dc <pid+0xcc>)
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
  20341e:	f242 7910 	movw	r9, #10000	; 0x2710
  flag_start=0;
}

void Motor_Speed(int16_t speed)
{
  pwmEnableChannel( &PWMD1, 1, PWM_PERCENTAGE_TO_WIDTH(&PWMD1,speed) );
  203422:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 2034e0 <pid+0xd0>
  203426:	4d2f      	ldr	r5, [pc, #188]	; (2034e4 <pid+0xd4>)
  203428:	f384 8811 	msr	BASEPRI, r4
  20342c:	f242 7210 	movw	r2, #10000	; 0x2710
  203430:	a901      	add	r1, sp, #4
  203432:	4628      	mov	r0, r5
  203434:	f7ff ff94 	bl	203360 <chMBFetchTimeoutS>
  203438:	2300      	movs	r3, #0
  20343a:	f383 8811 	msr	BASEPRI, r3
    msg_t my_msg;
    int32_t input=0;
    while(1)
    {
      msg_t msg = chMBFetchTimeout(&pid_mb, &my_msg, chTimeMS2I(10));
      if (msg == MSG_OK)
  20343e:	2800      	cmp	r0, #0
  203440:	d1f2      	bne.n	203428 <pid+0x18>
          {
            if((int16_t)my_msg<0)
  203442:	9b01      	ldr	r3, [sp, #4]
  203444:	fa0f fc83 	sxth.w	ip, r3
  203448:	f1bc 0f00 	cmp.w	ip, #0
  20344c:	da03      	bge.n	203456 <pid+0x46>
              my_msg*=-1;
  20344e:	425b      	negs	r3, r3
            input=PID_Reg(set_speed,(int16_t)my_msg);
  203450:	fa0f fc83 	sxth.w	ip, r3
              my_msg*=-1;
  203454:	9301      	str	r3, [sp, #4]

int16_t PID_Reg(int zadanie, int measure)
{
  int16_t input, e=0, I_Temp, D_Temp;
  e=zadanie-measure;
  if(Reg1.I*(Reg1.Summ_Error)<=Reg1.Max_Summ_Error)
  203456:	f9b6 2002 	ldrsh.w	r2, [r6, #2]
  e=zadanie-measure;
  20345a:	b29b      	uxth	r3, r3
  if(Reg1.I*(Reg1.Summ_Error)<=Reg1.Max_Summ_Error)
  20345c:	68b0      	ldr	r0, [r6, #8]
  e=zadanie-measure;
  20345e:	f8ba 1000 	ldrh.w	r1, [sl]
  if(Reg1.I*(Reg1.Summ_Error)<=Reg1.Max_Summ_Error)
  203462:	fb00 fe02 	mul.w	lr, r0, r2
  203466:	68f5      	ldr	r5, [r6, #12]
  e=zadanie-measure;
  203468:	1ac9      	subs	r1, r1, r3
  if(Reg1.I*(Reg1.Summ_Error)<=Reg1.Max_Summ_Error)
  20346a:	45ae      	cmp	lr, r5
  e=zadanie-measure;
  20346c:	b289      	uxth	r1, r1
  if(Reg1.I*(Reg1.Summ_Error)<=Reg1.Max_Summ_Error)
  20346e:	dc2b      	bgt.n	2034c8 <pid+0xb8>
  {
    I_Temp=Reg1.Summ_Error+e;
  203470:	180d      	adds	r5, r1, r0
  203472:	b2a8      	uxth	r0, r5
    Reg1.Summ_Error=I_Temp;
  203474:	b22d      	sxth	r5, r5
  203476:	60b5      	str	r5, [r6, #8]
  }
  else
    I_Temp=Reg1.Summ_Error;
  D_Temp=Reg1.Last_Process_Value-measure;
  203478:	6935      	ldr	r5, [r6, #16]
  Reg1.Last_Process_Value=measure;
  input=Reg1.P*e+Reg1.I*I_Temp+Reg1.D*D_Temp;
  20347a:	fb12 f200 	smulbb	r2, r2, r0
  Reg1.Last_Process_Value=measure;
  20347e:	f8c6 c010 	str.w	ip, [r6, #16]
  D_Temp=Reg1.Last_Process_Value-measure;
  203482:	1aeb      	subs	r3, r5, r3
  input=Reg1.P*e+Reg1.I*I_Temp+Reg1.D*D_Temp;
  203484:	f8b6 c004 	ldrh.w	ip, [r6, #4]
  203488:	8830      	ldrh	r0, [r6, #0]
  20348a:	fb1c f303 	smulbb	r3, ip, r3
  20348e:	fb10 3101 	smlabb	r1, r0, r1, r3
  203492:	440a      	add	r2, r1
  203494:	b213      	sxth	r3, r2
  203496:	b292      	uxth	r2, r2
  if(input>MAX_VALUE)
  203498:	454b      	cmp	r3, r9
  20349a:	dc17      	bgt.n	2034cc <pid+0xbc>
    input=MAX_VALUE;
  if(input<0)
  20349c:	2b00      	cmp	r3, #0
  20349e:	da01      	bge.n	2034a4 <pid+0x94>
  {
    input*=-1;
  2034a0:	4253      	negs	r3, r2
  2034a2:	b21b      	sxth	r3, r3
  2034a4:	68ba      	ldr	r2, [r7, #8]
  2034a6:	fb02 f303 	mul.w	r3, r2, r3
  2034aa:	fba8 2303 	umull	r2, r3, r8, r3
  2034ae:	0b5b      	lsrs	r3, r3, #13
  2034b0:	f384 8811 	msr	BASEPRI, r4

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
  2034b4:	68fa      	ldr	r2, [r7, #12]
  2034b6:	2000      	movs	r0, #0
    pwmp->tim->CCR[channel] = width;
  2034b8:	69b9      	ldr	r1, [r7, #24]
  2034ba:	f042 0202 	orr.w	r2, r2, #2
  2034be:	638b      	str	r3, [r1, #56]	; 0x38
  2034c0:	60fa      	str	r2, [r7, #12]
  2034c2:	f380 8811 	msr	BASEPRI, r0

  osalSysUnlock();
}
  2034c6:	e7ae      	b.n	203426 <pid+0x16>
  input=Reg1.P*e+Reg1.I*I_Temp+Reg1.D*D_Temp;
  2034c8:	b280      	uxth	r0, r0
  2034ca:	e7d5      	b.n	203478 <pid+0x68>
  2034cc:	f242 7310 	movw	r3, #10000	; 0x2710
  2034d0:	e7e8      	b.n	2034a4 <pid+0x94>
  2034d2:	bf00      	nop
  2034d4:	20020068 	.word	0x20020068
  2034d8:	20000844 	.word	0x20000844
  2034dc:	20000828 	.word	0x20000828
  2034e0:	d1b71759 	.word	0xd1b71759
  2034e4:	200019d0 	.word	0x200019d0
	...

002034f0 <chMtxUnlock.constprop.0>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  2034f0:	b570      	push	{r4, r5, r6, lr}
  return ch.rlist.current;
  2034f2:	4d21      	ldr	r5, [pc, #132]	; (203578 <chMtxUnlock.constprop.0+0x88>)
  2034f4:	2320      	movs	r3, #32
  2034f6:	69ae      	ldr	r6, [r5, #24]
  2034f8:	f383 8811 	msr	BASEPRI, r3
    chDbgAssert(currtp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    currtp->mtxlist = mp->next;
  2034fc:	4c1f      	ldr	r4, [pc, #124]	; (20357c <chMtxUnlock.constprop.0+0x8c>)
  return (bool)(qp->next != qp);
  2034fe:	6820      	ldr	r0, [r4, #0]
  203500:	68e3      	ldr	r3, [r4, #12]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
  203502:	42a0      	cmp	r0, r4
    currtp->mtxlist = mp->next;
  203504:	63b3      	str	r3, [r6, #56]	; 0x38
    if (chMtxQueueNotEmptyS(mp)) {
  203506:	d031      	beq.n	20356c <chMtxUnlock.constprop.0+0x7c>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = currtp->realprio;
  203508:	6bf1      	ldr	r1, [r6, #60]	; 0x3c
      lmp = currtp->mtxlist;
      while (lmp != NULL) {
  20350a:	b14b      	cbz	r3, 203520 <chMtxUnlock.constprop.0+0x30>
  20350c:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
  20350e:	4293      	cmp	r3, r2
  203510:	d003      	beq.n	20351a <chMtxUnlock.constprop.0+0x2a>
  203512:	6892      	ldr	r2, [r2, #8]
  203514:	4291      	cmp	r1, r2
  203516:	bf38      	it	cc
  203518:	4611      	movcc	r1, r2
            (((thread_t *)lmp->queue.next)->hdr.pqueue.prio > newprio)) {
          newprio = ((thread_t *)lmp->queue.next)->hdr.pqueue.prio;
        }
        lmp = lmp->next;
  20351a:	68db      	ldr	r3, [r3, #12]
      while (lmp != NULL) {
  20351c:	2b00      	cmp	r3, #0
  20351e:	d1f5      	bne.n	20350c <chMtxUnlock.constprop.0+0x1c>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      currtp->hdr.pqueue.prio = newprio;
  203520:	60b1      	str	r1, [r6, #8]
  tp->state = CH_STATE_READY;
  203522:	2200      	movs	r2, #0
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = (thread_t *)ch_queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
  203524:	6b81      	ldr	r1, [r0, #56]	; 0x38
  qp->next       = p->next;
  203526:	6803      	ldr	r3, [r0, #0]
  qp->next->prev = qp;
  203528:	605c      	str	r4, [r3, #4]
  qp->next       = p->next;
  20352a:	6023      	str	r3, [r4, #0]
  } while (pqp->prio >= p->prio);
  20352c:	4b12      	ldr	r3, [pc, #72]	; (203578 <chMtxUnlock.constprop.0+0x88>)
      tp->mtxlist = mp;
  20352e:	6384      	str	r4, [r0, #56]	; 0x38
  203530:	f880 2020 	strb.w	r2, [r0, #32]
      mp->next = tp->mtxlist;
  203534:	e9c4 0102 	strd	r0, r1, [r4, #8]
  203538:	6881      	ldr	r1, [r0, #8]
    pqp = pqp->next;
  20353a:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  20353c:	689a      	ldr	r2, [r3, #8]
  20353e:	428a      	cmp	r2, r1
  203540:	d2fb      	bcs.n	20353a <chMtxUnlock.constprop.0+0x4a>
  p->prev       = pqp->prev;
  203542:	685a      	ldr	r2, [r3, #4]
  203544:	69a9      	ldr	r1, [r5, #24]
  203546:	e9c0 3200 	strd	r3, r2, [r0]
  p->prev->next = p;
  20354a:	6010      	str	r0, [r2, #0]
  20354c:	682a      	ldr	r2, [r5, #0]
  pqp->prev     = p;
  20354e:	6058      	str	r0, [r3, #4]
  if (chSchIsRescRequiredI()) {
  203550:	6892      	ldr	r2, [r2, #8]
  203552:	688b      	ldr	r3, [r1, #8]
  203554:	429a      	cmp	r2, r3
  203556:	d803      	bhi.n	203560 <chMtxUnlock.constprop.0+0x70>
  203558:	2300      	movs	r3, #0
  20355a:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
}
  20355e:	bd70      	pop	{r4, r5, r6, pc}
    chSchDoRescheduleAhead();
  203560:	f7ff fed6 	bl	203310 <chSchDoReschedule>
  203564:	2300      	movs	r3, #0
  203566:	f383 8811 	msr	BASEPRI, r3
  20356a:	bd70      	pop	{r4, r5, r6, pc}
      mp->owner = NULL;
  20356c:	2300      	movs	r3, #0
  20356e:	6083      	str	r3, [r0, #8]
  203570:	2300      	movs	r3, #0
  203572:	f383 8811 	msr	BASEPRI, r3
}
  203576:	bd70      	pop	{r4, r5, r6, pc}
  203578:	200009d0 	.word	0x200009d0
  20357c:	200017f8 	.word	0x200017f8

00203580 <menu>:
uint8_t flagmenuspeed=0;

static THD_WORKING_AREA(menuThread, 1024);// 256 - stack size

static THD_FUNCTION(menu, arg)
{
  203580:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  203584:	f8df a2dc 	ldr.w	sl, [pc, #732]	; 203864 <menu+0x2e4>
  203588:	b089      	sub	sp, #36	; 0x24
  20358a:	f8df 92dc 	ldr.w	r9, [pc, #732]	; 203868 <menu+0x2e8>
  20358e:	4fb7      	ldr	r7, [pc, #732]	; (20386c <menu+0x2ec>)
  203590:	4db7      	ldr	r5, [pc, #732]	; (203870 <menu+0x2f0>)
  203592:	4cb8      	ldr	r4, [pc, #736]	; (203874 <menu+0x2f4>)
  203594:	2320      	movs	r3, #32
  203596:	f383 8811 	msr	BASEPRI, r3
  20359a:	462a      	mov	r2, r5
  20359c:	a902      	add	r1, sp, #8
  20359e:	4620      	mov	r0, r4
  2035a0:	f7ff fede 	bl	203360 <chMBFetchTimeoutS>
  2035a4:	2300      	movs	r3, #0
  2035a6:	f383 8811 	msr	BASEPRI, r3
    int8_t button=0;
    bool mutex;
    while(1)
    {
      msg_t msg = chMBFetchTimeout(&menu_mb, &my_msg, chTimeMS2I(200));
      if (msg == MSG_OK)
  2035aa:	2800      	cmp	r0, #0
  2035ac:	d1f2      	bne.n	203594 <menu+0x14>
          {
            button=(int8_t)my_msg;
            switch(button)
  2035ae:	f99d 3008 	ldrsb.w	r3, [sp, #8]
  2035b2:	3b01      	subs	r3, #1
  2035b4:	2b03      	cmp	r3, #3
  2035b6:	d8ed      	bhi.n	203594 <menu+0x14>
  2035b8:	e8df f003 	tbb	[pc, r3]
  2035bc:	02174778 	.word	0x02174778
                }
              }
              break;
              case LEFT:
              {
                if(flagmenu2)
  2035c0:	4bad      	ldr	r3, [pc, #692]	; (203878 <menu+0x2f8>)
  2035c2:	781b      	ldrb	r3, [r3, #0]
  2035c4:	2b00      	cmp	r3, #0
  2035c6:	f040 80ae 	bne.w	203726 <menu+0x1a6>
                    set_speed=menu2_1->menu_value;
                  }
                }
                else
                {
                if(current->parent!=NULL)
  2035ca:	f8d9 2000 	ldr.w	r2, [r9]
  2035ce:	6952      	ldr	r2, [r2, #20]
  2035d0:	2a00      	cmp	r2, #0
  2035d2:	d0df      	beq.n	203594 <menu+0x14>
  2035d4:	2220      	movs	r2, #32
  2035d6:	f382 8811 	msr	BASEPRI, r2
  if (mp->owner != NULL) {
  2035da:	f8da 2008 	ldr.w	r2, [sl, #8]
  2035de:	2a00      	cmp	r2, #0
  2035e0:	f000 8191 	beq.w	203906 <menu+0x386>
  2035e4:	f383 8811 	msr	BASEPRI, r3
                {
                  mutex=chMtxTryLock(&mtx);
                  if(mutex==true)
  2035e8:	e7d4      	b.n	203594 <menu+0x14>
                if(flagmenu2)
  2035ea:	4ba3      	ldr	r3, [pc, #652]	; (203878 <menu+0x2f8>)
  2035ec:	781b      	ldrb	r3, [r3, #0]
  2035ee:	2b00      	cmp	r3, #0
  2035f0:	f040 80fe 	bne.w	2037f0 <menu+0x270>
                  if(current->child!=NULL)
  2035f4:	f8d9 2000 	ldr.w	r2, [r9]
  2035f8:	6991      	ldr	r1, [r2, #24]
  2035fa:	2900      	cmp	r1, #0
  2035fc:	f000 8167 	beq.w	2038ce <menu+0x34e>
  203600:	2220      	movs	r2, #32
  203602:	f382 8811 	msr	BASEPRI, r2
  203606:	f8da 2008 	ldr.w	r2, [sl, #8]
  20360a:	2a00      	cmp	r2, #0
  20360c:	d1ea      	bne.n	2035e4 <menu+0x64>
  20360e:	4b9b      	ldr	r3, [pc, #620]	; (20387c <menu+0x2fc>)
  203610:	699b      	ldr	r3, [r3, #24]
  mp->next = currtp->mtxlist;
  203612:	6b99      	ldr	r1, [r3, #56]	; 0x38
  mp->owner = currtp;
  203614:	f8ca 3008 	str.w	r3, [sl, #8]
  currtp->mtxlist = mp;
  203618:	f8c3 a038 	str.w	sl, [r3, #56]	; 0x38
  mp->next = currtp->mtxlist;
  20361c:	f8ca 100c 	str.w	r1, [sl, #12]
  203620:	f382 8811 	msr	BASEPRI, r2
                      current=current->child;
  203624:	f8d9 3000 	ldr.w	r3, [r9]
  203628:	699b      	ldr	r3, [r3, #24]
  20362a:	f8c9 3000 	str.w	r3, [r9]
                      Menu_Disp();
  20362e:	f7fe fbd7 	bl	201de0 <Menu_Disp>
                      Cursor();
  203632:	f7fe f8a5 	bl	201780 <Cursor>
                      if(current==menu2_1)
  203636:	4b92      	ldr	r3, [pc, #584]	; (203880 <menu+0x300>)
  203638:	f8d9 2000 	ldr.w	r2, [r9]
  20363c:	681b      	ldr	r3, [r3, #0]
  20363e:	429a      	cmp	r2, r3
  203640:	f000 8178 	beq.w	203934 <menu+0x3b4>
                  {
                    flagmenuspeed=0;
                    current=current->parent;
                    Menu_Disp();
                    Cursor();
                    chMtxUnlock(&mtx);
  203644:	f7ff ff54 	bl	2034f0 <chMtxUnlock.constprop.0>
  203648:	e7a4      	b.n	203594 <menu+0x14>
                if(flagmenu2)
  20364a:	4b8b      	ldr	r3, [pc, #556]	; (203878 <menu+0x2f8>)
  20364c:	781b      	ldrb	r3, [r3, #0]
  20364e:	2b00      	cmp	r3, #0
  203650:	d15d      	bne.n	20370e <menu+0x18e>
                  if(current->next!=NULL)
  203652:	f8d9 3000 	ldr.w	r3, [r9]
  203656:	691b      	ldr	r3, [r3, #16]
  203658:	2b00      	cmp	r3, #0
  20365a:	d09b      	beq.n	203594 <menu+0x14>
                    current=current->next;
  20365c:	f8c9 3000 	str.w	r3, [r9]
                    Menu_Disp();
  203660:	f7fe fbbe 	bl	201de0 <Menu_Disp>
    TFT_Draw_String(current->x_pos,current->y_pos, RED, WHITE, current->text, 2);
  203664:	f8d9 3000 	ldr.w	r3, [r9]
  203668:	f8d3 8000 	ldr.w	r8, [r3]
  20366c:	e9d3 6b07 	ldrd	r6, fp, [r3, #28]
	while(*string)
  203670:	f898 3000 	ldrb.w	r3, [r8]
  203674:	b983      	cbnz	r3, 203698 <menu+0x118>
  203676:	e78d      	b.n	203594 <menu+0x14>
		x += FONT_X*size;     
  203678:	4630      	mov	r0, r6
  20367a:	3610      	adds	r6, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  20367c:	f04f 0c02 	mov.w	ip, #2
  203680:	f44f 4278 	mov.w	r2, #63488	; 0xf800
  203684:	4659      	mov	r1, fp
  203686:	f8cd c000 	str.w	ip, [sp]
  20368a:	f7fe f801 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  20368e:	f818 3f01 	ldrb.w	r3, [r8, #1]!
  203692:	2b00      	cmp	r3, #0
  203694:	f43f af7e 	beq.w	203594 <menu+0x14>
		if((x + FONT_X) > MAX_X)
  203698:	f106 0208 	add.w	r2, r6, #8
  20369c:	6839      	ldr	r1, [r7, #0]
			x = 1;
  20369e:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  2036a0:	428a      	cmp	r2, r1
  2036a2:	d9e9      	bls.n	203678 <menu+0xf8>
			y = y + FONT_X*size;
  2036a4:	f10b 0b10 	add.w	fp, fp, #16
  2036a8:	2611      	movs	r6, #17
  2036aa:	e7e7      	b.n	20367c <menu+0xfc>
                if(flagmenu2)
  2036ac:	4b72      	ldr	r3, [pc, #456]	; (203878 <menu+0x2f8>)
  2036ae:	781b      	ldrb	r3, [r3, #0]
  2036b0:	bb6b      	cbnz	r3, 20370e <menu+0x18e>
                if(current->prev!=NULL)
  2036b2:	f8d9 3000 	ldr.w	r3, [r9]
  2036b6:	68db      	ldr	r3, [r3, #12]
  2036b8:	2b00      	cmp	r3, #0
  2036ba:	f43f af6b 	beq.w	203594 <menu+0x14>
                  current=current->prev;
  2036be:	f8c9 3000 	str.w	r3, [r9]
                  Menu_Disp();
  2036c2:	f7fe fb8d 	bl	201de0 <Menu_Disp>
  2036c6:	f8d9 3000 	ldr.w	r3, [r9]
  2036ca:	f8d3 8000 	ldr.w	r8, [r3]
  2036ce:	e9d3 6b07 	ldrd	r6, fp, [r3, #28]
	while(*string)
  2036d2:	f898 3000 	ldrb.w	r3, [r8]
  2036d6:	b983      	cbnz	r3, 2036fa <menu+0x17a>
  2036d8:	e75c      	b.n	203594 <menu+0x14>
		x += FONT_X*size;     
  2036da:	4630      	mov	r0, r6
  2036dc:	3610      	adds	r6, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  2036de:	f04f 0c02 	mov.w	ip, #2
  2036e2:	f44f 4278 	mov.w	r2, #63488	; 0xf800
  2036e6:	4659      	mov	r1, fp
  2036e8:	f8cd c000 	str.w	ip, [sp]
  2036ec:	f7fd ffd0 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  2036f0:	f818 3f01 	ldrb.w	r3, [r8, #1]!
  2036f4:	2b00      	cmp	r3, #0
  2036f6:	f43f af4d 	beq.w	203594 <menu+0x14>
		if((x + FONT_X) > MAX_X)
  2036fa:	f106 0208 	add.w	r2, r6, #8
  2036fe:	6839      	ldr	r1, [r7, #0]
			x = 1;
  203700:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  203702:	428a      	cmp	r2, r1
  203704:	d9e9      	bls.n	2036da <menu+0x15a>
			y = y + FONT_X*size;
  203706:	f10b 0b10 	add.w	fp, fp, #16
  20370a:	2611      	movs	r6, #17
  20370c:	e7e7      	b.n	2036de <menu+0x15e>
  20370e:	2320      	movs	r3, #32
  203710:	f383 8811 	msr	BASEPRI, r3
  if (mp->owner != NULL) {
  203714:	f8da 3008 	ldr.w	r3, [sl, #8]
  203718:	2b00      	cmp	r3, #0
  20371a:	f000 80e0 	beq.w	2038de <menu+0x35e>
  20371e:	2300      	movs	r3, #0
  203720:	f383 8811 	msr	BASEPRI, r3
                  if(mutex==true)
  203724:	e736      	b.n	203594 <menu+0x14>
  203726:	2320      	movs	r3, #32
  203728:	f383 8811 	msr	BASEPRI, r3
  20372c:	f8da 3008 	ldr.w	r3, [sl, #8]
  203730:	2b00      	cmp	r3, #0
  203732:	d1f4      	bne.n	20371e <menu+0x19e>
  203734:	4a51      	ldr	r2, [pc, #324]	; (20387c <menu+0x2fc>)
  203736:	6992      	ldr	r2, [r2, #24]
  mp->next = currtp->mtxlist;
  203738:	6b91      	ldr	r1, [r2, #56]	; 0x38
  mp->owner = currtp;
  20373a:	f8ca 2008 	str.w	r2, [sl, #8]
  currtp->mtxlist = mp;
  20373e:	f8c2 a038 	str.w	sl, [r2, #56]	; 0x38
  mp->next = currtp->mtxlist;
  203742:	f8ca 100c 	str.w	r1, [sl, #12]
  203746:	f383 8811 	msr	BASEPRI, r3
                    if(current->menu_value>0)
  20374a:	f8d9 3000 	ldr.w	r3, [r9]
  20374e:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
  203752:	2a00      	cmp	r2, #0
  203754:	dd02      	ble.n	20375c <menu+0x1dc>
                      current->menu_value-=5;
  203756:	3a05      	subs	r2, #5
  203758:	b212      	sxth	r2, r2
  20375a:	851a      	strh	r2, [r3, #40]	; 0x28
                    sprintf(Value,"%d",current->menu_value);
  20375c:	4949      	ldr	r1, [pc, #292]	; (203884 <menu+0x304>)
  20375e:	a803      	add	r0, sp, #12
  203760:	f001 fe30 	bl	2053c4 <siprintf>
                    TFT_Fill_Screen(current->x_pos+145,current->x_pos+200,current->y_pos,current->y_pos+20,WHITE);
  203764:	f8d9 3000 	ldr.w	r3, [r9]
  203768:	f64f 71ff 	movw	r1, #65535	; 0xffff
  20376c:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203770:	9100      	str	r1, [sp, #0]
  203772:	f102 0314 	add.w	r3, r2, #20
  203776:	f100 01c8 	add.w	r1, r0, #200	; 0xc8
  20377a:	3091      	adds	r0, #145	; 0x91
  20377c:	f7fd fe18 	bl	2013b0 <TFT_Fill_Screen>
                    TFT_Draw_String(current->x_pos+150,current->y_pos, GREEN, WHITE,Value , 2);
  203780:	f8d9 2000 	ldr.w	r2, [r9]
	while(*string)
  203784:	f89d 300c 	ldrb.w	r3, [sp, #12]
  203788:	e9d2 6b07 	ldrd	r6, fp, [r2, #28]
  20378c:	3696      	adds	r6, #150	; 0x96
  20378e:	b1d3      	cbz	r3, 2037c6 <menu+0x246>
  203790:	f10d 080c 	add.w	r8, sp, #12
  203794:	e00d      	b.n	2037b2 <menu+0x232>
		x += FONT_X*size;     
  203796:	4630      	mov	r0, r6
  203798:	3610      	adds	r6, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  20379a:	f04f 0c02 	mov.w	ip, #2
  20379e:	f44f 62fc 	mov.w	r2, #2016	; 0x7e0
  2037a2:	4659      	mov	r1, fp
  2037a4:	f8cd c000 	str.w	ip, [sp]
  2037a8:	f7fd ff72 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  2037ac:	f818 3f01 	ldrb.w	r3, [r8, #1]!
  2037b0:	b14b      	cbz	r3, 2037c6 <menu+0x246>
		if((x + FONT_X) > MAX_X)
  2037b2:	f106 0208 	add.w	r2, r6, #8
  2037b6:	6839      	ldr	r1, [r7, #0]
			x = 1;
  2037b8:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  2037ba:	428a      	cmp	r2, r1
  2037bc:	d9eb      	bls.n	203796 <menu+0x216>
			y = y + FONT_X*size;
  2037be:	f10b 0b10 	add.w	fp, fp, #16
  2037c2:	2611      	movs	r6, #17
  2037c4:	e7e9      	b.n	20379a <menu+0x21a>
                    chMtxUnlock(&mtx);
  2037c6:	f7ff fe93 	bl	2034f0 <chMtxUnlock.constprop.0>
                    Reg1.P=menu3_1->menu_value;
  2037ca:	4b2f      	ldr	r3, [pc, #188]	; (203888 <menu+0x308>)
  2037cc:	4a2f      	ldr	r2, [pc, #188]	; (20388c <menu+0x30c>)
  2037ce:	681b      	ldr	r3, [r3, #0]
  2037d0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
  2037d2:	8013      	strh	r3, [r2, #0]
                    Reg1.D=menu3_2->menu_value;
  2037d4:	4b2e      	ldr	r3, [pc, #184]	; (203890 <menu+0x310>)
  2037d6:	681b      	ldr	r3, [r3, #0]
  2037d8:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
  2037da:	8093      	strh	r3, [r2, #4]
                    Reg1.I=menu3_3->menu_value;
  2037dc:	4b2d      	ldr	r3, [pc, #180]	; (203894 <menu+0x314>)
  2037de:	681b      	ldr	r3, [r3, #0]
  2037e0:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
  2037e2:	8053      	strh	r3, [r2, #2]
                    set_speed=menu2_1->menu_value;
  2037e4:	4b26      	ldr	r3, [pc, #152]	; (203880 <menu+0x300>)
  2037e6:	4a2c      	ldr	r2, [pc, #176]	; (203898 <menu+0x318>)
  2037e8:	681b      	ldr	r3, [r3, #0]
  2037ea:	8d1b      	ldrh	r3, [r3, #40]	; 0x28
  2037ec:	8013      	strh	r3, [r2, #0]
  2037ee:	e6d1      	b.n	203594 <menu+0x14>
  2037f0:	2320      	movs	r3, #32
  2037f2:	f383 8811 	msr	BASEPRI, r3
  if (mp->owner != NULL) {
  2037f6:	f8da 3008 	ldr.w	r3, [sl, #8]
  2037fa:	2b00      	cmp	r3, #0
  2037fc:	d18f      	bne.n	20371e <menu+0x19e>
  2037fe:	4a1f      	ldr	r2, [pc, #124]	; (20387c <menu+0x2fc>)
  203800:	6992      	ldr	r2, [r2, #24]
  mp->next = currtp->mtxlist;
  203802:	6b91      	ldr	r1, [r2, #56]	; 0x38
  mp->owner = currtp;
  203804:	f8ca 2008 	str.w	r2, [sl, #8]
  currtp->mtxlist = mp;
  203808:	f8c2 a038 	str.w	sl, [r2, #56]	; 0x38
  mp->next = currtp->mtxlist;
  20380c:	f8ca 100c 	str.w	r1, [sl, #12]
  203810:	f383 8811 	msr	BASEPRI, r3
                    if(current->menu_value<=200)
  203814:	f8d9 3000 	ldr.w	r3, [r9]
  203818:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
  20381c:	2ac8      	cmp	r2, #200	; 0xc8
  20381e:	dc02      	bgt.n	203826 <menu+0x2a6>
                    current->menu_value+=5;
  203820:	3205      	adds	r2, #5
  203822:	b212      	sxth	r2, r2
  203824:	851a      	strh	r2, [r3, #40]	; 0x28
                    sprintf(Value,"%d",current->menu_value);
  203826:	4917      	ldr	r1, [pc, #92]	; (203884 <menu+0x304>)
  203828:	a803      	add	r0, sp, #12
  20382a:	f001 fdcb 	bl	2053c4 <siprintf>
                    TFT_Fill_Screen(current->x_pos+145,current->x_pos+200,current->y_pos,current->y_pos+20,WHITE);
  20382e:	f8d9 3000 	ldr.w	r3, [r9]
  203832:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203836:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  20383a:	9100      	str	r1, [sp, #0]
  20383c:	f102 0314 	add.w	r3, r2, #20
  203840:	f100 01c8 	add.w	r1, r0, #200	; 0xc8
  203844:	3091      	adds	r0, #145	; 0x91
  203846:	f7fd fdb3 	bl	2013b0 <TFT_Fill_Screen>
                    TFT_Draw_String(current->x_pos+150,current->y_pos, GREEN, WHITE,Value , 2);
  20384a:	f8d9 2000 	ldr.w	r2, [r9]
	while(*string)
  20384e:	f89d 300c 	ldrb.w	r3, [sp, #12]
  203852:	e9d2 6b07 	ldrd	r6, fp, [r2, #28]
  203856:	3696      	adds	r6, #150	; 0x96
  203858:	2b00      	cmp	r3, #0
  20385a:	d0b4      	beq.n	2037c6 <menu+0x246>
  20385c:	f10d 080c 	add.w	r8, sp, #12
  203860:	e02b      	b.n	2038ba <menu+0x33a>
  203862:	bf00      	nop
  203864:	200017f8 	.word	0x200017f8
  203868:	20000ef0 	.word	0x20000ef0
  20386c:	20000820 	.word	0x20000820
  203870:	00030d40 	.word	0x00030d40
  203874:	20001640 	.word	0x20001640
  203878:	20000f96 	.word	0x20000f96
  20387c:	200009d0 	.word	0x200009d0
  203880:	20001164 	.word	0x20001164
  203884:	08005ab4 	.word	0x08005ab4
  203888:	20001168 	.word	0x20001168
  20388c:	20000844 	.word	0x20000844
  203890:	2000116c 	.word	0x2000116c
  203894:	20001170 	.word	0x20001170
  203898:	20020068 	.word	0x20020068
		x += FONT_X*size;     
  20389c:	4630      	mov	r0, r6
  20389e:	3610      	adds	r6, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  2038a0:	f04f 0c02 	mov.w	ip, #2
  2038a4:	f44f 62fc 	mov.w	r2, #2016	; 0x7e0
  2038a8:	4659      	mov	r1, fp
  2038aa:	f8cd c000 	str.w	ip, [sp]
  2038ae:	f7fd feef 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  2038b2:	f818 3f01 	ldrb.w	r3, [r8, #1]!
  2038b6:	2b00      	cmp	r3, #0
  2038b8:	d085      	beq.n	2037c6 <menu+0x246>
		if((x + FONT_X) > MAX_X)
  2038ba:	f106 0208 	add.w	r2, r6, #8
  2038be:	6839      	ldr	r1, [r7, #0]
			x = 1;
  2038c0:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  2038c2:	428a      	cmp	r2, r1
  2038c4:	d9ea      	bls.n	20389c <menu+0x31c>
			y = y + FONT_X*size;
  2038c6:	f10b 0b10 	add.w	fp, fp, #16
  2038ca:	2611      	movs	r6, #17
  2038cc:	e7e8      	b.n	2038a0 <menu+0x320>
                  else if((current->cmd!=0)&&(current->child==NULL))
  2038ce:	7a11      	ldrb	r1, [r2, #8]
  2038d0:	2900      	cmp	r1, #0
  2038d2:	f43f ae5f 	beq.w	203594 <menu+0x14>
                    chMBPostI(&cmd_mb, current->cmd);
  2038d6:	4819      	ldr	r0, [pc, #100]	; (20393c <menu+0x3bc>)
  2038d8:	f7fc ff72 	bl	2007c0 <chMBPostI.isra.0>
  2038dc:	e65a      	b.n	203594 <menu+0x14>
  2038de:	4a18      	ldr	r2, [pc, #96]	; (203940 <menu+0x3c0>)
  2038e0:	6992      	ldr	r2, [r2, #24]
  2038e2:	6b91      	ldr	r1, [r2, #56]	; 0x38
  mp->owner = currtp;
  2038e4:	f8ca 2008 	str.w	r2, [sl, #8]
  currtp->mtxlist = mp;
  2038e8:	f8c2 a038 	str.w	sl, [r2, #56]	; 0x38
  mp->next = currtp->mtxlist;
  2038ec:	f8ca 100c 	str.w	r1, [sl, #12]
  2038f0:	f383 8811 	msr	BASEPRI, r3
                    flagmenu2=0;
  2038f4:	4a13      	ldr	r2, [pc, #76]	; (203944 <menu+0x3c4>)
  2038f6:	7013      	strb	r3, [r2, #0]
                    Menu_Disp();
  2038f8:	f7fe fa72 	bl	201de0 <Menu_Disp>
                    Cursor();
  2038fc:	f7fd ff40 	bl	201780 <Cursor>
                    chMtxUnlock(&mtx);
  203900:	f7ff fdf6 	bl	2034f0 <chMtxUnlock.constprop.0>
  203904:	e646      	b.n	203594 <menu+0x14>
  203906:	4b0e      	ldr	r3, [pc, #56]	; (203940 <menu+0x3c0>)
  203908:	699b      	ldr	r3, [r3, #24]
  20390a:	6b99      	ldr	r1, [r3, #56]	; 0x38
  mp->owner = currtp;
  20390c:	f8ca 3008 	str.w	r3, [sl, #8]
  currtp->mtxlist = mp;
  203910:	f8c3 a038 	str.w	sl, [r3, #56]	; 0x38
  mp->next = currtp->mtxlist;
  203914:	f8ca 100c 	str.w	r1, [sl, #12]
  203918:	f382 8811 	msr	BASEPRI, r2
                    flagmenuspeed=0;
  20391c:	4b0a      	ldr	r3, [pc, #40]	; (203948 <menu+0x3c8>)
  20391e:	701a      	strb	r2, [r3, #0]
                    current=current->parent;
  203920:	f8d9 3000 	ldr.w	r3, [r9]
  203924:	695b      	ldr	r3, [r3, #20]
  203926:	f8c9 3000 	str.w	r3, [r9]
                    Menu_Disp();
  20392a:	f7fe fa59 	bl	201de0 <Menu_Disp>
                    Cursor();
  20392e:	f7fd ff27 	bl	201780 <Cursor>
  203932:	e687      	b.n	203644 <menu+0xc4>
                        flagmenuspeed=1;
  203934:	2301      	movs	r3, #1
  203936:	4a04      	ldr	r2, [pc, #16]	; (203948 <menu+0x3c8>)
  203938:	7013      	strb	r3, [r2, #0]
                      chMtxUnlock(&mtx);
  20393a:	e683      	b.n	203644 <menu+0xc4>
  20393c:	20000d38 	.word	0x20000d38
  203940:	200009d0 	.word	0x200009d0
  203944:	20000f96 	.word	0x20000f96
  203948:	20000f97 	.word	0x20000f97
  20394c:	00000000 	.word	0x00000000

00203950 <cmd>:


static THD_WORKING_AREA(cmdThread, 256);// 256 - stack size

static THD_FUNCTION(cmd, arg)
{
  203950:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  203954:	f8df 81a4 	ldr.w	r8, [pc, #420]	; 203afc <cmd+0x1ac>
  203958:	b089      	sub	sp, #36	; 0x24
  20395a:	4c69      	ldr	r4, [pc, #420]	; (203b00 <cmd+0x1b0>)
  20395c:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 203b04 <cmd+0x1b4>
  203960:	4f69      	ldr	r7, [pc, #420]	; (203b08 <cmd+0x1b8>)
  203962:	4e6a      	ldr	r6, [pc, #424]	; (203b0c <cmd+0x1bc>)
  203964:	2320      	movs	r3, #32
  203966:	f383 8811 	msr	BASEPRI, r3
  20396a:	463a      	mov	r2, r7
  20396c:	a902      	add	r1, sp, #8
  20396e:	4630      	mov	r0, r6
  203970:	f7ff fcf6 	bl	203360 <chMBFetchTimeoutS>
  203974:	2300      	movs	r3, #0
  203976:	f383 8811 	msr	BASEPRI, r3
    msg_t my_msg;
    int8_t cmd=0;
    while(1)
        {
          msg_t msg = chMBFetchTimeout(&cmd_mb, &my_msg, chTimeMS2I(300));
          if (msg == MSG_OK)
  20397a:	2800      	cmp	r0, #0
  20397c:	d1f2      	bne.n	203964 <cmd+0x14>
          {
            cmd=(int8_t)my_msg;
            switch(cmd)
  20397e:	f99d 3008 	ldrsb.w	r3, [sp, #8]
  203982:	3b05      	subs	r3, #5
  203984:	2b04      	cmp	r3, #4
  203986:	d8ed      	bhi.n	203964 <cmd+0x14>
  203988:	e8df f013 	tbh	[pc, r3, lsl #1]
  20398c:	00d201aa 	.word	0x00d201aa
  203990:	00110262 	.word	0x00110262
  203994:	0005      	.short	0x0005
  203996:	2320      	movs	r3, #32
  203998:	f383 8811 	msr	BASEPRI, r3
  if (mp->owner != NULL) {
  20399c:	4b5c      	ldr	r3, [pc, #368]	; (203b10 <cmd+0x1c0>)
  20399e:	689b      	ldr	r3, [r3, #8]
  2039a0:	2b00      	cmp	r3, #0
  2039a2:	f000 82fa 	beq.w	203f9a <cmd+0x64a>
  2039a6:	2300      	movs	r3, #0
  2039a8:	f383 8811 	msr	BASEPRI, r3
              }
              break;
              case SPEED:
              {
                bool mutex=chMtxTryLock(&mtx);
                if(mutex==true)
  2039ac:	e7da      	b.n	203964 <cmd+0x14>
  IN1_HI;
  2039ae:	f44f 7300 	mov.w	r3, #512	; 0x200
  2039b2:	4a58      	ldr	r2, [pc, #352]	; (203b14 <cmd+0x1c4>)
                menu1_1->bool_value="TRUE";
  2039b4:	4d58      	ldr	r5, [pc, #352]	; (203b18 <cmd+0x1c8>)
  2039b6:	8313      	strh	r3, [r2, #24]
  IN2_LO;
  2039b8:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  2039bc:	4b57      	ldr	r3, [pc, #348]	; (203b1c <cmd+0x1cc>)
  2039be:	4958      	ldr	r1, [pc, #352]	; (203b20 <cmd+0x1d0>)
  2039c0:	835a      	strh	r2, [r3, #26]
  2039c2:	682b      	ldr	r3, [r5, #0]
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  2039c4:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
                menu1_1->bool_value="TRUE";
  2039c8:	6259      	str	r1, [r3, #36]	; 0x24
                menu1_3->bool_value="TRUE";
  2039ca:	f8d8 3000 	ldr.w	r3, [r8]
  2039ce:	6259      	str	r1, [r3, #36]	; 0x24
                menu1_4->bool_value="FALSE";
  2039d0:	f8d9 3000 	ldr.w	r3, [r9]
  2039d4:	4953      	ldr	r1, [pc, #332]	; (203b24 <cmd+0x1d4>)
  2039d6:	6259      	str	r1, [r3, #36]	; 0x24
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  2039d8:	f64f 73ff 	movw	r3, #65535	; 0xffff
  flag_start=1;
  2039dc:	f04f 0101 	mov.w	r1, #1
  2039e0:	9300      	str	r3, [sp, #0]
  2039e2:	4b51      	ldr	r3, [pc, #324]	; (203b28 <cmd+0x1d8>)
  2039e4:	7019      	strb	r1, [r3, #0]
                Reg1.Summ_Error=0;
  2039e6:	2300      	movs	r3, #0
  2039e8:	4950      	ldr	r1, [pc, #320]	; (203b2c <cmd+0x1dc>)
  2039ea:	608b      	str	r3, [r1, #8]
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  2039ec:	f102 0314 	add.w	r3, r2, #20
  2039f0:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  2039f4:	30dc      	adds	r0, #220	; 0xdc
  2039f6:	f7fd fcdb 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_1->x_pos+220,menu1_1->y_pos, BLUE, WHITE, menu1_1->bool_value, 1);
  2039fa:	682b      	ldr	r3, [r5, #0]
  2039fc:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203a00:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
	while(*string)
  203a04:	f89a 3000 	ldrb.w	r3, [sl]
  203a08:	35dc      	adds	r5, #220	; 0xdc
  203a0a:	b1b3      	cbz	r3, 203a3a <cmd+0xea>
		if((x + FONT_X) > MAX_X)
  203a0c:	f105 0108 	add.w	r1, r5, #8
  203a10:	6822      	ldr	r2, [r4, #0]
  203a12:	4628      	mov	r0, r5
  203a14:	4291      	cmp	r1, r2
  203a16:	460d      	mov	r5, r1
  203a18:	d903      	bls.n	203a22 <cmd+0xd2>
			y = y + FONT_X*size;
  203a1a:	f10b 0b08 	add.w	fp, fp, #8
  203a1e:	2509      	movs	r5, #9
			x = 1;
  203a20:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203a22:	f04f 0c01 	mov.w	ip, #1
  203a26:	221f      	movs	r2, #31
  203a28:	4659      	mov	r1, fp
  203a2a:	f8cd c000 	str.w	ip, [sp]
  203a2e:	f7fd fe2f 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203a32:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203a36:	2b00      	cmp	r3, #0
  203a38:	d1e8      	bne.n	203a0c <cmd+0xbc>
                TFT_Fill_Screen(menu1_3->x_pos+220,menu1_3->x_pos+270,menu1_3->y_pos,menu1_3->y_pos+20,WHITE);
  203a3a:	f8d8 3000 	ldr.w	r3, [r8]
  203a3e:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203a42:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203a46:	9100      	str	r1, [sp, #0]
  203a48:	f102 0314 	add.w	r3, r2, #20
  203a4c:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203a50:	30dc      	adds	r0, #220	; 0xdc
  203a52:	f7fd fcad 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_3->x_pos+220,menu1_3->y_pos, BLUE, WHITE, menu1_3->bool_value, 1);
  203a56:	f8d8 3000 	ldr.w	r3, [r8]
  203a5a:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203a5e:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203a62:	f89a 3000 	ldrb.w	r3, [sl]
  203a66:	35dc      	adds	r5, #220	; 0xdc
  203a68:	b1b3      	cbz	r3, 203a98 <cmd+0x148>
		if((x + FONT_X) > MAX_X)
  203a6a:	f105 0108 	add.w	r1, r5, #8
  203a6e:	6822      	ldr	r2, [r4, #0]
  203a70:	4628      	mov	r0, r5
  203a72:	4291      	cmp	r1, r2
  203a74:	460d      	mov	r5, r1
  203a76:	d903      	bls.n	203a80 <cmd+0x130>
			y = y + FONT_X*size;
  203a78:	f10b 0b08 	add.w	fp, fp, #8
  203a7c:	2509      	movs	r5, #9
			x = 1;
  203a7e:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203a80:	f04f 0c01 	mov.w	ip, #1
  203a84:	221f      	movs	r2, #31
  203a86:	4659      	mov	r1, fp
  203a88:	f8cd c000 	str.w	ip, [sp]
  203a8c:	f7fd fe00 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203a90:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203a94:	2b00      	cmp	r3, #0
  203a96:	d1e8      	bne.n	203a6a <cmd+0x11a>
                TFT_Fill_Screen(menu1_4->x_pos+220,menu1_4->x_pos+270,menu1_4->y_pos,menu1_4->y_pos+20,WHITE);
  203a98:	f8d9 3000 	ldr.w	r3, [r9]
  203a9c:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203aa0:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203aa4:	9100      	str	r1, [sp, #0]
  203aa6:	f102 0314 	add.w	r3, r2, #20
  203aaa:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203aae:	30dc      	adds	r0, #220	; 0xdc
  203ab0:	f7fd fc7e 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_4->x_pos+220,menu1_4->y_pos, BLUE, WHITE, menu1_4->bool_value, 1);
  203ab4:	f8d9 3000 	ldr.w	r3, [r9]
  203ab8:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203abc:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203ac0:	f89a 3000 	ldrb.w	r3, [sl]
  203ac4:	35dc      	adds	r5, #220	; 0xdc
  203ac6:	2b00      	cmp	r3, #0
  203ac8:	f43f af4c 	beq.w	203964 <cmd+0x14>
		if((x + FONT_X) > MAX_X)
  203acc:	f105 0108 	add.w	r1, r5, #8
  203ad0:	6822      	ldr	r2, [r4, #0]
  203ad2:	4628      	mov	r0, r5
  203ad4:	4291      	cmp	r1, r2
  203ad6:	460d      	mov	r5, r1
  203ad8:	d903      	bls.n	203ae2 <cmd+0x192>
			y = y + FONT_X*size;
  203ada:	f10b 0b08 	add.w	fp, fp, #8
  203ade:	2509      	movs	r5, #9
			x = 1;
  203ae0:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203ae2:	f04f 0c01 	mov.w	ip, #1
  203ae6:	221f      	movs	r2, #31
  203ae8:	4659      	mov	r1, fp
  203aea:	f8cd c000 	str.w	ip, [sp]
  203aee:	f7fd fdcf 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203af2:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203af6:	2b00      	cmp	r3, #0
  203af8:	d1e8      	bne.n	203acc <cmd+0x17c>
  203afa:	e733      	b.n	203964 <cmd+0x14>
  203afc:	2000115c 	.word	0x2000115c
  203b00:	20000820 	.word	0x20000820
  203b04:	20001160 	.word	0x20001160
  203b08:	000493e0 	.word	0x000493e0
  203b0c:	20000d38 	.word	0x20000d38
  203b10:	200017f8 	.word	0x200017f8
  203b14:	40021000 	.word	0x40021000
  203b18:	20001154 	.word	0x20001154
  203b1c:	40021400 	.word	0x40021400
  203b20:	08005ab8 	.word	0x08005ab8
  203b24:	08005ac0 	.word	0x08005ac0
  203b28:	20000f95 	.word	0x20000f95
  203b2c:	20000844 	.word	0x20000844
  IN1_LO;
  203b30:	f44f 7300 	mov.w	r3, #512	; 0x200
  203b34:	4abe      	ldr	r2, [pc, #760]	; (203e30 <cmd+0x4e0>)
                menu1_1->bool_value="FALSE";
  203b36:	4dbf      	ldr	r5, [pc, #764]	; (203e34 <cmd+0x4e4>)
  203b38:	8353      	strh	r3, [r2, #26]
  IN2_LO;
  203b3a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  203b3e:	4bbe      	ldr	r3, [pc, #760]	; (203e38 <cmd+0x4e8>)
  203b40:	49be      	ldr	r1, [pc, #760]	; (203e3c <cmd+0x4ec>)
  203b42:	835a      	strh	r2, [r3, #26]
  203b44:	682b      	ldr	r3, [r5, #0]
                menu1_2->bool_value="TRUE";
  203b46:	f8df c2f8 	ldr.w	ip, [pc, #760]	; 203e40 <cmd+0x4f0>
                menu1_1->bool_value="FALSE";
  203b4a:	6259      	str	r1, [r3, #36]	; 0x24
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203b4c:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
                menu1_2->bool_value="TRUE";
  203b50:	4bbc      	ldr	r3, [pc, #752]	; (203e44 <cmd+0x4f4>)
  203b52:	681b      	ldr	r3, [r3, #0]
  203b54:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
                menu1_3->bool_value="FALSE";
  203b58:	f8d8 3000 	ldr.w	r3, [r8]
  203b5c:	6259      	str	r1, [r3, #36]	; 0x24
                menu1_4->bool_value="FALSE";
  203b5e:	f8d9 3000 	ldr.w	r3, [r9]
  203b62:	6259      	str	r1, [r3, #36]	; 0x24
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203b64:	f64f 73ff 	movw	r3, #65535	; 0xffff
  flag_start=0;
  203b68:	49b7      	ldr	r1, [pc, #732]	; (203e48 <cmd+0x4f8>)
  203b6a:	9300      	str	r3, [sp, #0]
  203b6c:	2300      	movs	r3, #0
  203b6e:	700b      	strb	r3, [r1, #0]
                Reg1.Summ_Error=0;
  203b70:	49b6      	ldr	r1, [pc, #728]	; (203e4c <cmd+0x4fc>)
  203b72:	608b      	str	r3, [r1, #8]
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203b74:	f102 0314 	add.w	r3, r2, #20
  203b78:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203b7c:	30dc      	adds	r0, #220	; 0xdc
  203b7e:	f7fd fc17 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_1->x_pos+220,menu1_1->y_pos, BLUE, WHITE, menu1_1->bool_value, 1);
  203b82:	682b      	ldr	r3, [r5, #0]
  203b84:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203b88:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203b8c:	f89a 3000 	ldrb.w	r3, [sl]
  203b90:	35dc      	adds	r5, #220	; 0xdc
  203b92:	b1b3      	cbz	r3, 203bc2 <cmd+0x272>
		if((x + FONT_X) > MAX_X)
  203b94:	f105 0108 	add.w	r1, r5, #8
  203b98:	6822      	ldr	r2, [r4, #0]
  203b9a:	4628      	mov	r0, r5
  203b9c:	4291      	cmp	r1, r2
  203b9e:	460d      	mov	r5, r1
  203ba0:	d903      	bls.n	203baa <cmd+0x25a>
			y = y + FONT_X*size;
  203ba2:	f10b 0b08 	add.w	fp, fp, #8
  203ba6:	2509      	movs	r5, #9
			x = 1;
  203ba8:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203baa:	f04f 0c01 	mov.w	ip, #1
  203bae:	221f      	movs	r2, #31
  203bb0:	4659      	mov	r1, fp
  203bb2:	f8cd c000 	str.w	ip, [sp]
  203bb6:	f7fd fd6b 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203bba:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203bbe:	2b00      	cmp	r3, #0
  203bc0:	d1e8      	bne.n	203b94 <cmd+0x244>
                TFT_Fill_Screen(menu1_2->x_pos+220,menu1_2->x_pos+270,menu1_2->y_pos,menu1_2->y_pos+20,WHITE);
  203bc2:	4da0      	ldr	r5, [pc, #640]	; (203e44 <cmd+0x4f4>)
  203bc4:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203bc8:	682b      	ldr	r3, [r5, #0]
  203bca:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203bce:	9100      	str	r1, [sp, #0]
  203bd0:	f102 0314 	add.w	r3, r2, #20
  203bd4:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203bd8:	30dc      	adds	r0, #220	; 0xdc
  203bda:	f7fd fbe9 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_2->x_pos+220,menu1_2->y_pos, BLUE, WHITE, menu1_2->bool_value, 1);
  203bde:	682b      	ldr	r3, [r5, #0]
  203be0:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203be4:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203be8:	f89a 3000 	ldrb.w	r3, [sl]
  203bec:	35dc      	adds	r5, #220	; 0xdc
  203bee:	b1b3      	cbz	r3, 203c1e <cmd+0x2ce>
		if((x + FONT_X) > MAX_X)
  203bf0:	f105 0108 	add.w	r1, r5, #8
  203bf4:	6822      	ldr	r2, [r4, #0]
  203bf6:	4628      	mov	r0, r5
  203bf8:	4291      	cmp	r1, r2
  203bfa:	460d      	mov	r5, r1
  203bfc:	d903      	bls.n	203c06 <cmd+0x2b6>
			y = y + FONT_X*size;
  203bfe:	f10b 0b08 	add.w	fp, fp, #8
  203c02:	2509      	movs	r5, #9
			x = 1;
  203c04:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203c06:	f04f 0c01 	mov.w	ip, #1
  203c0a:	221f      	movs	r2, #31
  203c0c:	4659      	mov	r1, fp
  203c0e:	f8cd c000 	str.w	ip, [sp]
  203c12:	f7fd fd3d 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203c16:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203c1a:	2b00      	cmp	r3, #0
  203c1c:	d1e8      	bne.n	203bf0 <cmd+0x2a0>
                TFT_Fill_Screen(menu1_3->x_pos+220,menu1_3->x_pos+270,menu1_3->y_pos,menu1_3->y_pos+20,WHITE);
  203c1e:	f8d8 3000 	ldr.w	r3, [r8]
  203c22:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203c26:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203c2a:	9100      	str	r1, [sp, #0]
  203c2c:	f102 0314 	add.w	r3, r2, #20
  203c30:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203c34:	30dc      	adds	r0, #220	; 0xdc
  203c36:	f7fd fbbb 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_3->x_pos+220,menu1_3->y_pos, BLUE, WHITE, menu1_3->bool_value, 1);
  203c3a:	f8d8 3000 	ldr.w	r3, [r8]
  203c3e:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203c42:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203c46:	f89a 3000 	ldrb.w	r3, [sl]
  203c4a:	35dc      	adds	r5, #220	; 0xdc
  203c4c:	b1b3      	cbz	r3, 203c7c <cmd+0x32c>
		if((x + FONT_X) > MAX_X)
  203c4e:	f105 0108 	add.w	r1, r5, #8
  203c52:	6822      	ldr	r2, [r4, #0]
  203c54:	4628      	mov	r0, r5
  203c56:	4291      	cmp	r1, r2
  203c58:	460d      	mov	r5, r1
  203c5a:	d903      	bls.n	203c64 <cmd+0x314>
			y = y + FONT_X*size;
  203c5c:	f10b 0b08 	add.w	fp, fp, #8
  203c60:	2509      	movs	r5, #9
			x = 1;
  203c62:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203c64:	f04f 0c01 	mov.w	ip, #1
  203c68:	221f      	movs	r2, #31
  203c6a:	4659      	mov	r1, fp
  203c6c:	f8cd c000 	str.w	ip, [sp]
  203c70:	f7fd fd0e 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203c74:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203c78:	2b00      	cmp	r3, #0
  203c7a:	d1e8      	bne.n	203c4e <cmd+0x2fe>
                TFT_Fill_Screen(menu1_4->x_pos+220,menu1_4->x_pos+270,menu1_4->y_pos,menu1_4->y_pos+20,WHITE);
  203c7c:	f8d9 3000 	ldr.w	r3, [r9]
  203c80:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203c84:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203c88:	9100      	str	r1, [sp, #0]
  203c8a:	f102 0314 	add.w	r3, r2, #20
  203c8e:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203c92:	30dc      	adds	r0, #220	; 0xdc
  203c94:	f7fd fb8c 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_4->x_pos+220,menu1_4->y_pos, BLUE, WHITE, menu1_4->bool_value, 1);
  203c98:	f8d9 3000 	ldr.w	r3, [r9]
  203c9c:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203ca0:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203ca4:	f89a 3000 	ldrb.w	r3, [sl]
  203ca8:	35dc      	adds	r5, #220	; 0xdc
  203caa:	2b00      	cmp	r3, #0
  203cac:	f43f ae5a 	beq.w	203964 <cmd+0x14>
		if((x + FONT_X) > MAX_X)
  203cb0:	f105 0108 	add.w	r1, r5, #8
  203cb4:	6822      	ldr	r2, [r4, #0]
  203cb6:	4628      	mov	r0, r5
  203cb8:	4291      	cmp	r1, r2
  203cba:	460d      	mov	r5, r1
  203cbc:	d903      	bls.n	203cc6 <cmd+0x376>
			y = y + FONT_X*size;
  203cbe:	f10b 0b08 	add.w	fp, fp, #8
  203cc2:	2509      	movs	r5, #9
			x = 1;
  203cc4:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203cc6:	f04f 0c01 	mov.w	ip, #1
  203cca:	221f      	movs	r2, #31
  203ccc:	4659      	mov	r1, fp
  203cce:	f8cd c000 	str.w	ip, [sp]
  203cd2:	f7fd fcdd 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203cd6:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203cda:	2b00      	cmp	r3, #0
  203cdc:	d1e8      	bne.n	203cb0 <cmd+0x360>
  203cde:	e641      	b.n	203964 <cmd+0x14>
  IN1_HI;
  203ce0:	f44f 7300 	mov.w	r3, #512	; 0x200
  203ce4:	4a52      	ldr	r2, [pc, #328]	; (203e30 <cmd+0x4e0>)
                menu1_1->bool_value="TRUE";
  203ce6:	4d53      	ldr	r5, [pc, #332]	; (203e34 <cmd+0x4e4>)
  203ce8:	8313      	strh	r3, [r2, #24]
  IN2_LO;
  203cea:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  203cee:	4b52      	ldr	r3, [pc, #328]	; (203e38 <cmd+0x4e8>)
  203cf0:	4953      	ldr	r1, [pc, #332]	; (203e40 <cmd+0x4f0>)
  203cf2:	835a      	strh	r2, [r3, #26]
  203cf4:	682b      	ldr	r3, [r5, #0]
                menu1_2->bool_value="FALSE";
  203cf6:	f8df c144 	ldr.w	ip, [pc, #324]	; 203e3c <cmd+0x4ec>
                menu1_1->bool_value="TRUE";
  203cfa:	6259      	str	r1, [r3, #36]	; 0x24
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203cfc:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
                menu1_2->bool_value="FALSE";
  203d00:	4b50      	ldr	r3, [pc, #320]	; (203e44 <cmd+0x4f4>)
  203d02:	681b      	ldr	r3, [r3, #0]
  203d04:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
                menu1_3->bool_value="TRUE";
  203d08:	f8d8 3000 	ldr.w	r3, [r8]
  203d0c:	6259      	str	r1, [r3, #36]	; 0x24
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203d0e:	f64f 73ff 	movw	r3, #65535	; 0xffff
  flag_start=1;
  203d12:	f04f 0101 	mov.w	r1, #1
  203d16:	9300      	str	r3, [sp, #0]
  203d18:	4b4b      	ldr	r3, [pc, #300]	; (203e48 <cmd+0x4f8>)
  203d1a:	7019      	strb	r1, [r3, #0]
                Reg1.Summ_Error=0;
  203d1c:	2300      	movs	r3, #0
  203d1e:	494b      	ldr	r1, [pc, #300]	; (203e4c <cmd+0x4fc>)
  203d20:	608b      	str	r3, [r1, #8]
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203d22:	f102 0314 	add.w	r3, r2, #20
  203d26:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203d2a:	30dc      	adds	r0, #220	; 0xdc
  203d2c:	f7fd fb40 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_1->x_pos+220,menu1_1->y_pos, BLUE, WHITE, menu1_1->bool_value, 1);
  203d30:	682b      	ldr	r3, [r5, #0]
  203d32:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203d36:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203d3a:	f89a 3000 	ldrb.w	r3, [sl]
  203d3e:	35dc      	adds	r5, #220	; 0xdc
  203d40:	b1b3      	cbz	r3, 203d70 <cmd+0x420>
		if((x + FONT_X) > MAX_X)
  203d42:	f105 0108 	add.w	r1, r5, #8
  203d46:	6822      	ldr	r2, [r4, #0]
  203d48:	4628      	mov	r0, r5
  203d4a:	4291      	cmp	r1, r2
  203d4c:	460d      	mov	r5, r1
  203d4e:	d903      	bls.n	203d58 <cmd+0x408>
			y = y + FONT_X*size;
  203d50:	f10b 0b08 	add.w	fp, fp, #8
  203d54:	2509      	movs	r5, #9
			x = 1;
  203d56:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203d58:	f04f 0c01 	mov.w	ip, #1
  203d5c:	221f      	movs	r2, #31
  203d5e:	4659      	mov	r1, fp
  203d60:	f8cd c000 	str.w	ip, [sp]
  203d64:	f7fd fc94 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203d68:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203d6c:	2b00      	cmp	r3, #0
  203d6e:	d1e8      	bne.n	203d42 <cmd+0x3f2>
                TFT_Fill_Screen(menu1_2->x_pos+220,menu1_2->x_pos+270,menu1_2->y_pos,menu1_2->y_pos+20,WHITE);
  203d70:	4d34      	ldr	r5, [pc, #208]	; (203e44 <cmd+0x4f4>)
  203d72:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203d76:	682b      	ldr	r3, [r5, #0]
  203d78:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203d7c:	9100      	str	r1, [sp, #0]
  203d7e:	f102 0314 	add.w	r3, r2, #20
  203d82:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203d86:	30dc      	adds	r0, #220	; 0xdc
  203d88:	f7fd fb12 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_2->x_pos+220,menu1_2->y_pos, BLUE, WHITE, menu1_2->bool_value, 1);
  203d8c:	682b      	ldr	r3, [r5, #0]
  203d8e:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203d92:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203d96:	f89a 3000 	ldrb.w	r3, [sl]
  203d9a:	35dc      	adds	r5, #220	; 0xdc
  203d9c:	b1b3      	cbz	r3, 203dcc <cmd+0x47c>
		if((x + FONT_X) > MAX_X)
  203d9e:	f105 0108 	add.w	r1, r5, #8
  203da2:	6822      	ldr	r2, [r4, #0]
  203da4:	4628      	mov	r0, r5
  203da6:	4291      	cmp	r1, r2
  203da8:	460d      	mov	r5, r1
  203daa:	d903      	bls.n	203db4 <cmd+0x464>
			y = y + FONT_X*size;
  203dac:	f10b 0b08 	add.w	fp, fp, #8
  203db0:	2509      	movs	r5, #9
			x = 1;
  203db2:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203db4:	f04f 0c01 	mov.w	ip, #1
  203db8:	221f      	movs	r2, #31
  203dba:	4659      	mov	r1, fp
  203dbc:	f8cd c000 	str.w	ip, [sp]
  203dc0:	f7fd fc66 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203dc4:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203dc8:	2b00      	cmp	r3, #0
  203dca:	d1e8      	bne.n	203d9e <cmd+0x44e>
                TFT_Fill_Screen(menu1_3->x_pos+220,menu1_3->x_pos+270,menu1_3->y_pos,menu1_3->y_pos+20,WHITE);
  203dcc:	f8d8 3000 	ldr.w	r3, [r8]
  203dd0:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203dd4:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203dd8:	9100      	str	r1, [sp, #0]
  203dda:	f102 0314 	add.w	r3, r2, #20
  203dde:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203de2:	30dc      	adds	r0, #220	; 0xdc
  203de4:	f7fd fae4 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_3->x_pos+220,menu1_3->y_pos, BLUE, WHITE, menu1_3->bool_value, 1);
  203de8:	f8d8 3000 	ldr.w	r3, [r8]
  203dec:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203df0:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203df4:	f89a 3000 	ldrb.w	r3, [sl]
  203df8:	35dc      	adds	r5, #220	; 0xdc
  203dfa:	2b00      	cmp	r3, #0
  203dfc:	f43f adb2 	beq.w	203964 <cmd+0x14>
		if((x + FONT_X) > MAX_X)
  203e00:	f105 0108 	add.w	r1, r5, #8
  203e04:	6822      	ldr	r2, [r4, #0]
  203e06:	4628      	mov	r0, r5
  203e08:	4291      	cmp	r1, r2
  203e0a:	460d      	mov	r5, r1
  203e0c:	d903      	bls.n	203e16 <cmd+0x4c6>
			y = y + FONT_X*size;
  203e0e:	f10b 0b08 	add.w	fp, fp, #8
  203e12:	2509      	movs	r5, #9
			x = 1;
  203e14:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203e16:	f04f 0c01 	mov.w	ip, #1
  203e1a:	221f      	movs	r2, #31
  203e1c:	4659      	mov	r1, fp
  203e1e:	f8cd c000 	str.w	ip, [sp]
  203e22:	f7fd fc35 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203e26:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203e2a:	2b00      	cmp	r3, #0
  203e2c:	d1e8      	bne.n	203e00 <cmd+0x4b0>
  203e2e:	e599      	b.n	203964 <cmd+0x14>
  203e30:	40021000 	.word	0x40021000
  203e34:	20001154 	.word	0x20001154
  203e38:	40021400 	.word	0x40021400
  203e3c:	08005ac0 	.word	0x08005ac0
  203e40:	08005ab8 	.word	0x08005ab8
  203e44:	20001158 	.word	0x20001158
  203e48:	20000f95 	.word	0x20000f95
  203e4c:	20000844 	.word	0x20000844
  IN1_LO;
  203e50:	f44f 7300 	mov.w	r3, #512	; 0x200
  203e54:	4a6d      	ldr	r2, [pc, #436]	; (20400c <cmd+0x6bc>)
                menu1_1->bool_value="TRUE";
  203e56:	4d6e      	ldr	r5, [pc, #440]	; (204010 <cmd+0x6c0>)
  203e58:	8353      	strh	r3, [r2, #26]
  IN2_HI;
  203e5a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
  203e5e:	4b6d      	ldr	r3, [pc, #436]	; (204014 <cmd+0x6c4>)
  203e60:	496d      	ldr	r1, [pc, #436]	; (204018 <cmd+0x6c8>)
  203e62:	831a      	strh	r2, [r3, #24]
  203e64:	682b      	ldr	r3, [r5, #0]
                menu1_3->bool_value="FALSE";
  203e66:	f8df c1b4 	ldr.w	ip, [pc, #436]	; 20401c <cmd+0x6cc>
                menu1_1->bool_value="TRUE";
  203e6a:	6259      	str	r1, [r3, #36]	; 0x24
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203e6c:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
                menu1_3->bool_value="FALSE";
  203e70:	f8d8 3000 	ldr.w	r3, [r8]
  203e74:	f8c3 c024 	str.w	ip, [r3, #36]	; 0x24
                menu1_4->bool_value="TRUE";
  203e78:	f8d9 3000 	ldr.w	r3, [r9]
  203e7c:	6259      	str	r1, [r3, #36]	; 0x24
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203e7e:	f64f 73ff 	movw	r3, #65535	; 0xffff
                Reg1.Summ_Error=0;
  203e82:	4967      	ldr	r1, [pc, #412]	; (204020 <cmd+0x6d0>)
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203e84:	9300      	str	r3, [sp, #0]
                Reg1.Summ_Error=0;
  203e86:	2300      	movs	r3, #0
  203e88:	608b      	str	r3, [r1, #8]
                TFT_Fill_Screen(menu1_1->x_pos+220,menu1_1->x_pos+270,menu1_1->y_pos,menu1_1->y_pos+20,WHITE);
  203e8a:	f102 0314 	add.w	r3, r2, #20
  203e8e:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203e92:	30dc      	adds	r0, #220	; 0xdc
  203e94:	f7fd fa8c 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_1->x_pos+220,menu1_1->y_pos, BLUE, WHITE, menu1_1->bool_value, 1);
  203e98:	682b      	ldr	r3, [r5, #0]
  203e9a:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203e9e:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203ea2:	f89a 3000 	ldrb.w	r3, [sl]
  203ea6:	35dc      	adds	r5, #220	; 0xdc
  203ea8:	b1b3      	cbz	r3, 203ed8 <cmd+0x588>
		if((x + FONT_X) > MAX_X)
  203eaa:	f105 0108 	add.w	r1, r5, #8
  203eae:	6822      	ldr	r2, [r4, #0]
  203eb0:	4628      	mov	r0, r5
  203eb2:	4291      	cmp	r1, r2
  203eb4:	460d      	mov	r5, r1
  203eb6:	d903      	bls.n	203ec0 <cmd+0x570>
			y = y + FONT_X*size;
  203eb8:	f10b 0b08 	add.w	fp, fp, #8
  203ebc:	2509      	movs	r5, #9
			x = 1;
  203ebe:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203ec0:	f04f 0c01 	mov.w	ip, #1
  203ec4:	221f      	movs	r2, #31
  203ec6:	4659      	mov	r1, fp
  203ec8:	f8cd c000 	str.w	ip, [sp]
  203ecc:	f7fd fbe0 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203ed0:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203ed4:	2b00      	cmp	r3, #0
  203ed6:	d1e8      	bne.n	203eaa <cmd+0x55a>
                TFT_Fill_Screen(menu1_3->x_pos+220,menu1_3->x_pos+270,menu1_3->y_pos,menu1_3->y_pos+20,WHITE);
  203ed8:	f8d8 3000 	ldr.w	r3, [r8]
  203edc:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203ee0:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203ee4:	9100      	str	r1, [sp, #0]
  203ee6:	f102 0314 	add.w	r3, r2, #20
  203eea:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203eee:	30dc      	adds	r0, #220	; 0xdc
  203ef0:	f7fd fa5e 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_3->x_pos+220,menu1_3->y_pos, BLUE, WHITE, menu1_3->bool_value, 1);
  203ef4:	f8d8 3000 	ldr.w	r3, [r8]
  203ef8:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203efc:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203f00:	f89a 3000 	ldrb.w	r3, [sl]
  203f04:	35dc      	adds	r5, #220	; 0xdc
  203f06:	b1b3      	cbz	r3, 203f36 <cmd+0x5e6>
		if((x + FONT_X) > MAX_X)
  203f08:	f105 0108 	add.w	r1, r5, #8
  203f0c:	6822      	ldr	r2, [r4, #0]
  203f0e:	4628      	mov	r0, r5
  203f10:	4291      	cmp	r1, r2
  203f12:	460d      	mov	r5, r1
  203f14:	d903      	bls.n	203f1e <cmd+0x5ce>
			y = y + FONT_X*size;
  203f16:	f10b 0b08 	add.w	fp, fp, #8
  203f1a:	2509      	movs	r5, #9
			x = 1;
  203f1c:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203f1e:	f04f 0c01 	mov.w	ip, #1
  203f22:	221f      	movs	r2, #31
  203f24:	4659      	mov	r1, fp
  203f26:	f8cd c000 	str.w	ip, [sp]
  203f2a:	f7fd fbb1 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203f2e:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203f32:	2b00      	cmp	r3, #0
  203f34:	d1e8      	bne.n	203f08 <cmd+0x5b8>
                TFT_Fill_Screen(menu1_4->x_pos+220,menu1_4->x_pos+270,menu1_4->y_pos,menu1_4->y_pos+20,WHITE);
  203f36:	f8d9 3000 	ldr.w	r3, [r9]
  203f3a:	f64f 71ff 	movw	r1, #65535	; 0xffff
  203f3e:	e9d3 0207 	ldrd	r0, r2, [r3, #28]
  203f42:	9100      	str	r1, [sp, #0]
  203f44:	f102 0314 	add.w	r3, r2, #20
  203f48:	f500 7187 	add.w	r1, r0, #270	; 0x10e
  203f4c:	30dc      	adds	r0, #220	; 0xdc
  203f4e:	f7fd fa2f 	bl	2013b0 <TFT_Fill_Screen>
                TFT_Draw_String(menu1_4->x_pos+220,menu1_4->y_pos, BLUE, WHITE, menu1_4->bool_value, 1);
  203f52:	f8d9 3000 	ldr.w	r3, [r9]
  203f56:	f8d3 a024 	ldr.w	sl, [r3, #36]	; 0x24
  203f5a:	e9d3 5b07 	ldrd	r5, fp, [r3, #28]
  203f5e:	f89a 3000 	ldrb.w	r3, [sl]
  203f62:	35dc      	adds	r5, #220	; 0xdc
  203f64:	2b00      	cmp	r3, #0
  203f66:	f43f acfd 	beq.w	203964 <cmd+0x14>
		if((x + FONT_X) > MAX_X)
  203f6a:	f105 0108 	add.w	r1, r5, #8
  203f6e:	6822      	ldr	r2, [r4, #0]
  203f70:	4628      	mov	r0, r5
  203f72:	4291      	cmp	r1, r2
  203f74:	460d      	mov	r5, r1
  203f76:	d903      	bls.n	203f80 <cmd+0x630>
			y = y + FONT_X*size;
  203f78:	f10b 0b08 	add.w	fp, fp, #8
  203f7c:	2509      	movs	r5, #9
			x = 1;
  203f7e:	2001      	movs	r0, #1
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203f80:	f04f 0c01 	mov.w	ip, #1
  203f84:	221f      	movs	r2, #31
  203f86:	4659      	mov	r1, fp
  203f88:	f8cd c000 	str.w	ip, [sp]
  203f8c:	f7fd fb80 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203f90:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203f94:	2b00      	cmp	r3, #0
  203f96:	d1e8      	bne.n	203f6a <cmd+0x61a>
  203f98:	e4e4      	b.n	203964 <cmd+0x14>
  203f9a:	4a22      	ldr	r2, [pc, #136]	; (204024 <cmd+0x6d4>)
  mp->owner = currtp;
  203f9c:	4822      	ldr	r0, [pc, #136]	; (204028 <cmd+0x6d8>)
  203f9e:	6992      	ldr	r2, [r2, #24]
  mp->next = currtp->mtxlist;
  203fa0:	6b91      	ldr	r1, [r2, #56]	; 0x38
  mp->owner = currtp;
  203fa2:	6082      	str	r2, [r0, #8]
  currtp->mtxlist = mp;
  203fa4:	6390      	str	r0, [r2, #56]	; 0x38
  mp->next = currtp->mtxlist;
  203fa6:	60c1      	str	r1, [r0, #12]
  203fa8:	f383 8811 	msr	BASEPRI, r3
                {
                  flagmenu2=1;
                  sprintf(Value,"%d",current->menu_value);
  203fac:	4d1f      	ldr	r5, [pc, #124]	; (20402c <cmd+0x6dc>)
  203fae:	a803      	add	r0, sp, #12
                  flagmenu2=1;
  203fb0:	491f      	ldr	r1, [pc, #124]	; (204030 <cmd+0x6e0>)
                  sprintf(Value,"%d",current->menu_value);
  203fb2:	682b      	ldr	r3, [r5, #0]
  203fb4:	f9b3 2028 	ldrsh.w	r2, [r3, #40]	; 0x28
                  flagmenu2=1;
  203fb8:	2301      	movs	r3, #1
  203fba:	700b      	strb	r3, [r1, #0]
                  sprintf(Value,"%d",current->menu_value);
  203fbc:	491d      	ldr	r1, [pc, #116]	; (204034 <cmd+0x6e4>)
  203fbe:	f001 fa01 	bl	2053c4 <siprintf>
                  TFT_Draw_String(current->x_pos+150,current->y_pos, GREEN, WHITE,Value , 2);
  203fc2:	682a      	ldr	r2, [r5, #0]
  203fc4:	f89d 300c 	ldrb.w	r3, [sp, #12]
  203fc8:	e9d2 5b07 	ldrd	r5, fp, [r2, #28]
  203fcc:	3596      	adds	r5, #150	; 0x96
  203fce:	b1d3      	cbz	r3, 204006 <cmd+0x6b6>
  203fd0:	f10d 0a0c 	add.w	sl, sp, #12
  203fd4:	e00d      	b.n	203ff2 <cmd+0x6a2>
		x += FONT_X*size;     
  203fd6:	4628      	mov	r0, r5
  203fd8:	3510      	adds	r5, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  203fda:	f04f 0c02 	mov.w	ip, #2
  203fde:	f44f 62fc 	mov.w	r2, #2016	; 0x7e0
  203fe2:	4659      	mov	r1, fp
  203fe4:	f8cd c000 	str.w	ip, [sp]
  203fe8:	f7fd fb52 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  203fec:	f81a 3f01 	ldrb.w	r3, [sl, #1]!
  203ff0:	b14b      	cbz	r3, 204006 <cmd+0x6b6>
		if((x + FONT_X) > MAX_X)
  203ff2:	f105 0208 	add.w	r2, r5, #8
  203ff6:	6821      	ldr	r1, [r4, #0]
			x = 1;
  203ff8:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  203ffa:	428a      	cmp	r2, r1
  203ffc:	d9eb      	bls.n	203fd6 <cmd+0x686>
			y = y + FONT_X*size;
  203ffe:	f10b 0b10 	add.w	fp, fp, #16
  204002:	2511      	movs	r5, #17
  204004:	e7e9      	b.n	203fda <cmd+0x68a>
                  chMtxUnlock(&mtx);
  204006:	f7ff fa73 	bl	2034f0 <chMtxUnlock.constprop.0>
  20400a:	e4ab      	b.n	203964 <cmd+0x14>
  20400c:	40021000 	.word	0x40021000
  204010:	20001154 	.word	0x20001154
  204014:	40021400 	.word	0x40021400
  204018:	08005ab8 	.word	0x08005ab8
  20401c:	08005ac0 	.word	0x08005ac0
  204020:	20000844 	.word	0x20000844
  204024:	200009d0 	.word	0x200009d0
  204028:	200017f8 	.word	0x200017f8
  20402c:	20000ef0 	.word	0x20000ef0
  204030:	20000f96 	.word	0x20000f96
  204034:	08005ab4 	.word	0x08005ab4
	...

00204040 <speed_menu>:
}

static THD_WORKING_AREA(speed_menuThread, 512);// 256 - stack size

static THD_FUNCTION(speed_menu, arg)
{
  204040:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  204044:	f8df 90f4 	ldr.w	r9, [pc, #244]	; 20413c <speed_menu+0xfc>
  204048:	b089      	sub	sp, #36	; 0x24
  20404a:	4e3d      	ldr	r6, [pc, #244]	; (204140 <speed_menu+0x100>)
  20404c:	f8df 80f4 	ldr.w	r8, [pc, #244]	; 204144 <speed_menu+0x104>
  204050:	4f3d      	ldr	r7, [pc, #244]	; (204148 <speed_menu+0x108>)
  204052:	2420      	movs	r4, #32
  204054:	f384 8811 	msr	BASEPRI, r4
  204058:	4642      	mov	r2, r8
  20405a:	a902      	add	r1, sp, #8
  20405c:	4638      	mov	r0, r7
  20405e:	f7ff f97f 	bl	203360 <chMBFetchTimeoutS>
  204062:	2300      	movs	r3, #0
  204064:	f383 8811 	msr	BASEPRI, r3
  arg=arg;
  msg_t my_msg;
  while(1)
  {
    msg_t msg = chMBFetchTimeout(&holl_mb, &my_msg, chTimeMS2I(300));
    if (msg == MSG_OK)
  204068:	2800      	cmp	r0, #0
  20406a:	d1f2      	bne.n	204052 <speed_menu+0x12>
    {
      if(flagmenuspeed)
  20406c:	4b37      	ldr	r3, [pc, #220]	; (20414c <speed_menu+0x10c>)
  20406e:	781b      	ldrb	r3, [r3, #0]
  204070:	2b00      	cmp	r3, #0
  204072:	d0ee      	beq.n	204052 <speed_menu+0x12>
  204074:	f384 8811 	msr	BASEPRI, r4
  if (mp->owner != NULL) {
  204078:	f8d9 3008 	ldr.w	r3, [r9, #8]
  20407c:	b113      	cbz	r3, 204084 <speed_menu+0x44>
  20407e:	f380 8811 	msr	BASEPRI, r0
      {
        bool mutex=chMtxTryLock(&mtx);
        if(mutex==true)
  204082:	e7e6      	b.n	204052 <speed_menu+0x12>
  204084:	4a32      	ldr	r2, [pc, #200]	; (204150 <speed_menu+0x110>)
  204086:	6992      	ldr	r2, [r2, #24]
  mp->next = currtp->mtxlist;
  204088:	6b91      	ldr	r1, [r2, #56]	; 0x38
  mp->owner = currtp;
  20408a:	f8c9 2008 	str.w	r2, [r9, #8]
  currtp->mtxlist = mp;
  20408e:	f8c2 9038 	str.w	r9, [r2, #56]	; 0x38
  mp->next = currtp->mtxlist;
  204092:	f8c9 100c 	str.w	r1, [r9, #12]
  204096:	f383 8811 	msr	BASEPRI, r3
        {
          sprintf(Speed_Value,"%d",(int16_t)my_msg);
  20409a:	492e      	ldr	r1, [pc, #184]	; (204154 <speed_menu+0x114>)
  20409c:	a803      	add	r0, sp, #12
  20409e:	f9bd 2008 	ldrsh.w	r2, [sp, #8]
  2040a2:	f001 f98f 	bl	2053c4 <siprintf>
          TFT_Fill_Screen(230,290,110,130,WHITE);
  2040a6:	f64f 70ff 	movw	r0, #65535	; 0xffff
  2040aa:	2382      	movs	r3, #130	; 0x82
  2040ac:	226e      	movs	r2, #110	; 0x6e
  2040ae:	9000      	str	r0, [sp, #0]
  2040b0:	f44f 7191 	mov.w	r1, #290	; 0x122
  2040b4:	20e6      	movs	r0, #230	; 0xe6
  2040b6:	f7fd f97b 	bl	2013b0 <TFT_Fill_Screen>
	while(*string)
  2040ba:	f89d 300c 	ldrb.w	r3, [sp, #12]
  2040be:	b1e3      	cbz	r3, 2040fa <speed_menu+0xba>
  2040c0:	ad03      	add	r5, sp, #12
  2040c2:	f04f 0b6e 	mov.w	fp, #110	; 0x6e
  2040c6:	24e6      	movs	r4, #230	; 0xe6
		TFT_Draw_Char(x, y, color, phone,*string, size);
  2040c8:	f04f 0a02 	mov.w	sl, #2
  2040cc:	e00b      	b.n	2040e6 <speed_menu+0xa6>
		x += FONT_X*size;     
  2040ce:	4620      	mov	r0, r4
  2040d0:	3410      	adds	r4, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  2040d2:	f44f 4278 	mov.w	r2, #63488	; 0xf800
  2040d6:	4659      	mov	r1, fp
  2040d8:	f8cd a000 	str.w	sl, [sp]
  2040dc:	f7fd fad8 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  2040e0:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  2040e4:	b14b      	cbz	r3, 2040fa <speed_menu+0xba>
		if((x + FONT_X) > MAX_X)
  2040e6:	f104 0208 	add.w	r2, r4, #8
  2040ea:	6831      	ldr	r1, [r6, #0]
			x = 1;
  2040ec:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  2040ee:	428a      	cmp	r2, r1
  2040f0:	d9ed      	bls.n	2040ce <speed_menu+0x8e>
			y = y + FONT_X*size;
  2040f2:	f10b 0b10 	add.w	fp, fp, #16
  2040f6:	2411      	movs	r4, #17
  2040f8:	e7eb      	b.n	2040d2 <speed_menu+0x92>
		x += FONT_X*size;     
  2040fa:	4d17      	ldr	r5, [pc, #92]	; (204158 <speed_menu+0x118>)
	while(*string)
  2040fc:	2343      	movs	r3, #67	; 0x43
  2040fe:	f04f 0b6e 	mov.w	fp, #110	; 0x6e
  204102:	240a      	movs	r4, #10
		TFT_Draw_Char(x, y, color, phone,*string, size);
  204104:	f04f 0a02 	mov.w	sl, #2
  204108:	e00b      	b.n	204122 <speed_menu+0xe2>
		x += FONT_X*size;     
  20410a:	4620      	mov	r0, r4
  20410c:	3410      	adds	r4, #16
		TFT_Draw_Char(x, y, color, phone,*string, size);
  20410e:	f44f 4278 	mov.w	r2, #63488	; 0xf800
  204112:	4659      	mov	r1, fp
  204114:	f8cd a000 	str.w	sl, [sp]
  204118:	f7fd faba 	bl	201690 <TFT_Draw_Char.constprop.0>
	while(*string)
  20411c:	f815 3f01 	ldrb.w	r3, [r5, #1]!
  204120:	b14b      	cbz	r3, 204136 <speed_menu+0xf6>
		if((x + FONT_X) > MAX_X)
  204122:	f104 0208 	add.w	r2, r4, #8
  204126:	6831      	ldr	r1, [r6, #0]
			x = 1;
  204128:	2001      	movs	r0, #1
		if((x + FONT_X) > MAX_X)
  20412a:	428a      	cmp	r2, r1
  20412c:	d9ed      	bls.n	20410a <speed_menu+0xca>
			y = y + FONT_X*size;
  20412e:	f10b 0b10 	add.w	fp, fp, #16
  204132:	2411      	movs	r4, #17
  204134:	e7eb      	b.n	20410e <speed_menu+0xce>
          TFT_Draw_String(230,110,RED,WHITE,Speed_Value,2);
          TFT_Draw_String(10,110,RED,WHITE,"Current Speed",2);
          chMtxUnlock(&mtx);
  204136:	f7ff f9db 	bl	2034f0 <chMtxUnlock.constprop.0>
  20413a:	e78a      	b.n	204052 <speed_menu+0x12>
  20413c:	200017f8 	.word	0x200017f8
  204140:	20000820 	.word	0x20000820
  204144:	000493e0 	.word	0x000493e0
  204148:	20000f98 	.word	0x20000f98
  20414c:	20000f97 	.word	0x20000f97
  204150:	200009d0 	.word	0x200009d0
  204154:	08005ab4 	.word	0x08005ab4
  204158:	08005ac8 	.word	0x08005ac8
  20415c:	00000000 	.word	0x00000000

00204160 <chThdExit>:
  204160:	2320      	movs	r3, #32
void chThdExit(msg_t msg) {
  204162:	b570      	push	{r4, r5, r6, lr}
  204164:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = currp;
  204168:	4e1a      	ldr	r6, [pc, #104]	; (2041d4 <chThdExit+0x74>)
  20416a:	69b1      	ldr	r1, [r6, #24]
  while (ch_list_notempty(&tp->waiting)) {
  20416c:	f101 0c28 	add.w	ip, r1, #40	; 0x28
  return (bool)(lp->next != lp);
  204170:	6a8d      	ldr	r5, [r1, #40]	; 0x28
  tp->u.exitcode = msg;
  204172:	6248      	str	r0, [r1, #36]	; 0x24
  while (ch_list_notempty(&tp->waiting)) {
  204174:	4565      	cmp	r5, ip
  204176:	d013      	beq.n	2041a0 <chThdExit+0x40>
  tp->state = CH_STATE_READY;
  204178:	f04f 0e00 	mov.w	lr, #0
  lp->next = p->next;
  20417c:	462c      	mov	r4, r5
  } while (pqp->prio >= p->prio);
  20417e:	4b15      	ldr	r3, [pc, #84]	; (2041d4 <chThdExit+0x74>)
  lp->next = p->next;
  204180:	682d      	ldr	r5, [r5, #0]
  } while (pqp->prio >= p->prio);
  204182:	68a0      	ldr	r0, [r4, #8]
  lp->next = p->next;
  204184:	628d      	str	r5, [r1, #40]	; 0x28
  204186:	f884 e020 	strb.w	lr, [r4, #32]
    pqp = pqp->next;
  20418a:	681b      	ldr	r3, [r3, #0]
  } while (pqp->prio >= p->prio);
  20418c:	689a      	ldr	r2, [r3, #8]
  20418e:	4282      	cmp	r2, r0
  204190:	d2fb      	bcs.n	20418a <chThdExit+0x2a>
  p->prev       = pqp->prev;
  204192:	685a      	ldr	r2, [r3, #4]
  204194:	4565      	cmp	r5, ip
  204196:	e9c4 3200 	strd	r3, r2, [r4]
  p->prev->next = p;
  20419a:	6014      	str	r4, [r2, #0]
  pqp->prev     = p;
  20419c:	605c      	str	r4, [r3, #4]
  20419e:	d1ed      	bne.n	20417c <chThdExit+0x1c>
  if ((tp->refs == (trefs_t)0) &&
  2041a0:	f891 3022 	ldrb.w	r3, [r1, #34]	; 0x22
  2041a4:	b93b      	cbnz	r3, 2041b6 <chThdExit+0x56>
  2041a6:	f891 3021 	ldrb.w	r3, [r1, #33]	; 0x21
  2041aa:	079b      	lsls	r3, r3, #30
  2041ac:	d103      	bne.n	2041b6 <chThdExit+0x56>
    REG_REMOVE(tp);
  2041ae:	e9d1 3204 	ldrd	r3, r2, [r1, #16]
  2041b2:	6113      	str	r3, [r2, #16]
  2041b4:	615a      	str	r2, [r3, #20]
  ch_priority_queue_t *p = pqp->next;
  2041b6:	6830      	ldr	r0, [r6, #0]
  otp->state = newstate;
  2041b8:	230f      	movs	r3, #15
  currp->state = CH_STATE_CURRENT;
  2041ba:	2201      	movs	r2, #1
  otp->state = newstate;
  2041bc:	f881 3020 	strb.w	r3, [r1, #32]
  pqp->next       = p->next;
  2041c0:	6803      	ldr	r3, [r0, #0]
  pqp->next->prev = pqp;
  2041c2:	605e      	str	r6, [r3, #4]
  pqp->next       = p->next;
  2041c4:	6033      	str	r3, [r6, #0]
  currp->state = CH_STATE_CURRENT;
  2041c6:	f880 2020 	strb.w	r2, [r0, #32]
  currp = (thread_t *)ch_pqueue_remove_highest(&ch.rlist.pqueue);
  2041ca:	61b0      	str	r0, [r6, #24]
}
  2041cc:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  chSysSwitch(currp, otp);
  2041d0:	f7fc b886 	b.w	2002e0 <_port_switch>
  2041d4:	200009d0 	.word	0x200009d0
	...

002041e0 <SVC_Handler>:
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
  2041e0:	f3ef 8309 	mrs	r3, PSP
    psp += sizeof (struct port_extctx);
  2041e4:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
  2041e6:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2041ea:	2300      	movs	r3, #0
  2041ec:	f383 8811 	msr	BASEPRI, r3
}
  2041f0:	4770      	bx	lr
  2041f2:	bf00      	nop
	...

00204200 <main>:
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  204200:	4b23      	ldr	r3, [pc, #140]	; (204290 <main+0x90>)
  rccResetAHB2(~0);
  204202:	f04f 34ff 	mov.w	r4, #4294967295
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  204206:	4a23      	ldr	r2, [pc, #140]	; (204294 <main+0x94>)
  rccResetAHB2(~0);
  204208:	2100      	movs	r1, #0
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  20420a:	6918      	ldr	r0, [r3, #16]
  20420c:	4302      	orrs	r2, r0
  PWR->CR1 |= PWR_CR1_DBP;
  20420e:	4822      	ldr	r0, [pc, #136]	; (204298 <main+0x98>)
{
  204210:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
  rccResetAHB1(~STM32_GPIO_EN_MASK);
  204214:	611a      	str	r2, [r3, #16]
  204216:	b08b      	sub	sp, #44	; 0x2c
  204218:	691a      	ldr	r2, [r3, #16]
  20421a:	f3c2 020a 	ubfx	r2, r2, #0, #11
  20421e:	611a      	str	r2, [r3, #16]
  204220:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
  204222:	695a      	ldr	r2, [r3, #20]
  204224:	615c      	str	r4, [r3, #20]
  204226:	695a      	ldr	r2, [r3, #20]
  204228:	6159      	str	r1, [r3, #20]
  20422a:	695a      	ldr	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  20422c:	6a1a      	ldr	r2, [r3, #32]
  20422e:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
  204232:	621a      	str	r2, [r3, #32]
  204234:	6a1a      	ldr	r2, [r3, #32]
  204236:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
  20423a:	621a      	str	r2, [r3, #32]
  20423c:	6a1a      	ldr	r2, [r3, #32]
  rccResetAPB2(~0);
  20423e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  204240:	625c      	str	r4, [r3, #36]	; 0x24
  204242:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  204244:	6259      	str	r1, [r3, #36]	; 0x24
  204246:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  PWR->CR1 |= PWR_CR1_DBP;
  204248:	6802      	ldr	r2, [r0, #0]
  20424a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  20424e:	6002      	str	r2, [r0, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
  204250:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  204252:	f402 7240 	and.w	r2, r2, #768	; 0x300
  204256:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  20425a:	d003      	beq.n	204264 <main+0x64>
    RCC->BDCR = RCC_BDCR_BDRST;
  20425c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  204260:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
  204262:	6719      	str	r1, [r3, #112]	; 0x70
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  204264:	4a0a      	ldr	r2, [pc, #40]	; (204290 <main+0x90>)
  204266:	6f13      	ldr	r3, [r2, #112]	; 0x70
  204268:	f043 0319 	orr.w	r3, r3, #25
  20426c:	6713      	str	r3, [r2, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  20426e:	6f13      	ldr	r3, [r2, #112]	; 0x70
  204270:	079b      	lsls	r3, r3, #30
  204272:	d5fc      	bpl.n	20426e <main+0x6e>
  PWR->CSR1 &= ~PWR_CSR1_BRE;
  204274:	4c08      	ldr	r4, [pc, #32]	; (204298 <main+0x98>)
 * @init
 */
void dmaInit(void) {
  unsigned i;

  dma.allocated_mask = 0U;
  204276:	2100      	movs	r1, #0
  204278:	4808      	ldr	r0, [pc, #32]	; (20429c <main+0x9c>)
  20427a:	6862      	ldr	r2, [r4, #4]
  20427c:	4b08      	ldr	r3, [pc, #32]	; (2042a0 <main+0xa0>)
  20427e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
  204282:	6062      	str	r2, [r4, #4]
  204284:	4602      	mov	r2, r0
  204286:	6001      	str	r1, [r0, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  204288:	f103 04c0 	add.w	r4, r3, #192	; 0xc0
  dma.allocated_mask = 0U;
  20428c:	4805      	ldr	r0, [pc, #20]	; (2042a4 <main+0xa4>)
  20428e:	e00d      	b.n	2042ac <main+0xac>
  204290:	40023800 	.word	0x40023800
  204294:	fffff800 	.word	0xfffff800
  204298:	40007000 	.word	0x40007000
  20429c:	20000f10 	.word	0x20000f10
  2042a0:	08005ba8 	.word	0x08005ba8
  2042a4:	40026010 	.word	0x40026010
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
  2042a8:	f853 0c0c 	ldr.w	r0, [r3, #-12]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  2042ac:	330c      	adds	r3, #12
  2042ae:	3208      	adds	r2, #8
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
  2042b0:	6001      	str	r1, [r0, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  2042b2:	42a3      	cmp	r3, r4
    dma.streams[i].func = NULL;
  2042b4:	f842 1c04 	str.w	r1, [r2, #-4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
  2042b8:	d1f6      	bne.n	2042a8 <main+0xa8>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
  2042ba:	f04f 32ff 	mov.w	r2, #4294967295
  2042be:	4cc9      	ldr	r4, [pc, #804]	; (2045e4 <main+0x3e4>)
  DMA1->HIFCR = 0xFFFFFFFFU;
  DMA2->LIFCR = 0xFFFFFFFFU;
  2042c0:	48c9      	ldr	r0, [pc, #804]	; (2045e8 <main+0x3e8>)

#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2042c2:	2160      	movs	r1, #96	; 0x60
  2042c4:	4bc9      	ldr	r3, [pc, #804]	; (2045ec <main+0x3ec>)
  DMA1->LIFCR = 0xFFFFFFFFU;
  2042c6:	60a2      	str	r2, [r4, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
  2042c8:	60e2      	str	r2, [r4, #12]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2042ca:	f44f 7480 	mov.w	r4, #256	; 0x100
  DMA2->LIFCR = 0xFFFFFFFFU;
  2042ce:	6082      	str	r2, [r0, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
  2042d0:	60c2      	str	r2, [r0, #12]
  2042d2:	2240      	movs	r2, #64	; 0x40
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2042d4:	f883 1306 	strb.w	r1, [r3, #774]	; 0x306
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2042d8:	2080      	movs	r0, #128	; 0x80
  2042da:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2042de:	601a      	str	r2, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2042e0:	f44f 7200 	mov.w	r2, #512	; 0x200
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2042e4:	f883 1307 	strb.w	r1, [r3, #775]	; 0x307
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2042e8:	f8c3 0180 	str.w	r0, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2042ec:	6018      	str	r0, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2042ee:	f883 1308 	strb.w	r1, [r3, #776]	; 0x308
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2042f2:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  2042f6:	601c      	str	r4, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  2042f8:	f883 1309 	strb.w	r1, [r3, #777]	; 0x309
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  2042fc:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  204300:	601a      	str	r2, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204302:	f44f 6280 	mov.w	r2, #1024	; 0x400
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204306:	f883 130a 	strb.w	r1, [r3, #778]	; 0x30a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20430a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20430e:	601a      	str	r2, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204310:	f44f 0200 	mov.w	r2, #8388608	; 0x800000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204314:	f883 1317 	strb.w	r1, [r3, #791]	; 0x317
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204318:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20431c:	601a      	str	r2, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20431e:	2270      	movs	r2, #112	; 0x70
  204320:	f883 1328 	strb.w	r1, [r3, #808]	; 0x328
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204324:	f04f 7100 	mov.w	r1, #33554432	; 0x2000000
  204328:	f8c3 4184 	str.w	r4, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20432c:	605c      	str	r4, [r3, #4]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20432e:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204332:	f883 2318 	strb.w	r2, [r3, #792]	; 0x318
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204336:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20433a:	601c      	str	r4, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20433c:	f04f 6480 	mov.w	r4, #67108864	; 0x4000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204340:	f883 2319 	strb.w	r2, [r3, #793]	; 0x319
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204344:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  204348:	6019      	str	r1, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20434a:	f04f 6100 	mov.w	r1, #134217728	; 0x8000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20434e:	f883 231a 	strb.w	r2, [r3, #794]	; 0x31a
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204352:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  204356:	601c      	str	r4, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204358:	f04f 5480 	mov.w	r4, #268435456	; 0x10000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20435c:	f883 231b 	strb.w	r2, [r3, #795]	; 0x31b
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204360:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  204364:	6019      	str	r1, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204366:	f04f 5100 	mov.w	r1, #536870912	; 0x20000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20436a:	f883 231c 	strb.w	r2, [r3, #796]	; 0x31c
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20436e:	f8c3 4180 	str.w	r4, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  204372:	601c      	str	r4, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204374:	f883 231d 	strb.w	r2, [r3, #797]	; 0x31d
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204378:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20437c:	6019      	str	r1, [r3, #0]
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  20437e:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  204382:	f883 231e 	strb.w	r2, [r3, #798]	; 0x31e
  204386:	22c0      	movs	r2, #192	; 0xc0
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204388:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  20438c:	6019      	str	r1, [r3, #0]
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
  20438e:	f883 2327 	strb.w	r2, [r3, #807]	; 0x327
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
  204392:	4a97      	ldr	r2, [pc, #604]	; (2045f0 <main+0x3f0>)
  204394:	f8c3 0184 	str.w	r0, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
  204398:	4611      	mov	r1, r2
  20439a:	6058      	str	r0, [r3, #4]
    _pal_init_event(i);
  20439c:	2300      	movs	r3, #0
  20439e:	4401      	add	r1, r0
  2043a0:	e9c2 3300 	strd	r3, r3, [r2]
  for (i = 0; i < 16; i++) {
  2043a4:	3208      	adds	r2, #8
  2043a6:	428a      	cmp	r2, r1
  2043a8:	d1fa      	bne.n	2043a0 <main+0x1a0>
  sdp->vmt = &vmt;
  2043aa:	4d92      	ldr	r5, [pc, #584]	; (2045f4 <main+0x3f4>)
  gptp->state  = GPT_STOP;
  2043ac:	2701      	movs	r7, #1
  2043ae:	f8df c248 	ldr.w	ip, [pc, #584]	; 2045f8 <main+0x3f8>
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  2043b2:	f04f 38ff 	mov.w	r8, #4294967295
  qp->next = qp;
  2043b6:	f105 040c 	add.w	r4, r5, #12
  pwmp->state    = PWM_STOP;
  2043ba:	4e90      	ldr	r6, [pc, #576]	; (2045fc <main+0x3fc>)
  2043bc:	4990      	ldr	r1, [pc, #576]	; (204600 <main+0x400>)
  GPTD3.tim = STM32_TIM3;
  2043be:	4a91      	ldr	r2, [pc, #580]	; (204604 <main+0x404>)
  2043c0:	700f      	strb	r7, [r1, #0]
  2043c2:	60ca      	str	r2, [r1, #12]
  iqp->q_buffer  = bp;
  2043c4:	4a90      	ldr	r2, [pc, #576]	; (204608 <main+0x408>)
  gptp->config = NULL;
  2043c6:	604b      	str	r3, [r1, #4]
  2043c8:	4629      	mov	r1, r5
  2043ca:	61aa      	str	r2, [r5, #24]
  iqp->q_counter = 0;
  2043cc:	616b      	str	r3, [r5, #20]
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {

  spip->state = SPI_STOP;
  2043ce:	488f      	ldr	r0, [pc, #572]	; (20460c <main+0x40c>)
  gptp->state  = GPT_STOP;
  2043d0:	f88c 7000 	strb.w	r7, [ip]
  gptp->config = NULL;
  2043d4:	f8cc 3004 	str.w	r3, [ip, #4]
  2043d8:	f100 090c 	add.w	r9, r0, #12
  sdp->state = SD_STOP;
  2043dc:	722f      	strb	r7, [r5, #8]
  2043de:	7037      	strb	r7, [r6, #0]
  pwmp->config   = NULL;
  2043e0:	6073      	str	r3, [r6, #4]
  pwmp->enabled  = 0;
  2043e2:	60f3      	str	r3, [r6, #12]
  oqp->q_link    = link;
  2043e4:	652d      	str	r5, [r5, #80]	; 0x50
  SD3.clock = STM32_USART3CLK;
  2043e6:	f8df b228 	ldr.w	fp, [pc, #552]	; 204610 <main+0x410>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAlignedWithOffset;
  2043ea:	f8df e228 	ldr.w	lr, [pc, #552]	; 204614 <main+0x414>
  qp->prev = qp;
  2043ee:	e9c5 4403 	strd	r4, r4, [r5, #12]
  qp->next = qp;
  2043f2:	f105 0430 	add.w	r4, r5, #48	; 0x30
  2043f6:	f10e 0a0c 	add.w	sl, lr, #12
  qp->prev = qp;
  2043fa:	e9c5 440c 	strd	r4, r4, [r5, #48]	; 0x30
  GPTD4.tim = STM32_TIM4;
  2043fe:	4c86      	ldr	r4, [pc, #536]	; (204618 <main+0x418>)
  204400:	f8cc 400c 	str.w	r4, [ip, #12]
  PWMD1.channels = STM32_TIM1_CHANNELS;
  204404:	2406      	movs	r4, #6
  ST_ENABLE_STOP();
  204406:	f8df c214 	ldr.w	ip, [pc, #532]	; 20461c <main+0x41c>
  20440a:	7434      	strb	r4, [r6, #16]
  PWMD1.tim = STM32_TIM1;
  20440c:	4c84      	ldr	r4, [pc, #528]	; (204620 <main+0x420>)
  iqp->q_wrptr   = bp;
  20440e:	e9c5 2208 	strd	r2, r2, [r5, #32]
  204412:	61b4      	str	r4, [r6, #24]
  iqp->q_top     = bp + size;
  204414:	3210      	adds	r2, #16
  sdp->vmt = &vmt;
  204416:	4c83      	ldr	r4, [pc, #524]	; (204624 <main+0x424>)
  204418:	61ea      	str	r2, [r5, #28]
  20441a:	f841 4b04 	str.w	r4, [r1], #4
  oqp->q_buffer  = bp;
  20441e:	4a82      	ldr	r2, [pc, #520]	; (204628 <main+0x428>)
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
  204420:	6069      	str	r1, [r5, #4]
  oqp->q_counter = size;
  204422:	2110      	movs	r1, #16
  oqp->q_buffer  = bp;
  204424:	63ea      	str	r2, [r5, #60]	; 0x3c
  oqp->q_counter = size;
  204426:	63a9      	str	r1, [r5, #56]	; 0x38
  oqp->q_notify  = onfy;
  204428:	4980      	ldr	r1, [pc, #512]	; (20462c <main+0x42c>)
  pqp->next = pqp;
  20442a:	4c81      	ldr	r4, [pc, #516]	; (204630 <main+0x430>)
  20442c:	64e9      	str	r1, [r5, #76]	; 0x4c
  SD3.usart = USART3;
  20442e:	4981      	ldr	r1, [pc, #516]	; (204634 <main+0x434>)
  oqp->q_wrptr   = bp;
  204430:	e9c5 2211 	strd	r2, r2, [r5, #68]	; 0x44
  oqp->q_top     = bp + size;
  204434:	3210      	adds	r2, #16
  204436:	642a      	str	r2, [r5, #64]	; 0x40
  ST_ENABLE_CLOCK();
  204438:	4a7f      	ldr	r2, [pc, #508]	; (204638 <main+0x438>)
  iqp->q_link    = link;
  20443a:	e9c5 350a 	strd	r3, r5, [r5, #40]	; 0x28
  20443e:	6569      	str	r1, [r5, #84]	; 0x54
  204440:	7007      	strb	r7, [r0, #0]
  204442:	6c11      	ldr	r1, [r2, #64]	; 0x40
  mp->owner = NULL;
  204444:	6143      	str	r3, [r0, #20]
  204446:	4339      	orrs	r1, r7
  spip->config = NULL;
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
  204448:	e9c0 3301 	strd	r3, r3, [r0, #4]

#if STM32_SPI_USE_SPI1
  spiObjectInit(&SPID1);
  SPID1.spi       = SPI1;
  SPID1.dmarx     = NULL;
  SPID1.dmatx     = NULL;
  20444c:	e9c0 3308 	strd	r3, r3, [r0, #32]
  204450:	6411      	str	r1, [r2, #64]	; 0x40
  204452:	6e11      	ldr	r1, [r2, #96]	; 0x60
  204454:	4339      	orrs	r1, r7
  204456:	6611      	str	r1, [r2, #96]	; 0x60
  204458:	6e12      	ldr	r2, [r2, #96]	; 0x60
  qp->next = qp;
  20445a:	4978      	ldr	r1, [pc, #480]	; (20463c <main+0x43c>)
  pqp->prio = (tprio_t)0;
  20445c:	e9c4 4301 	strd	r4, r3, [r4, #4]
  ST_ENABLE_STOP();
  204460:	f8dc 2008 	ldr.w	r2, [ip, #8]
  204464:	433a      	orrs	r2, r7
  ch.rlist.older = (thread_t *)&ch.rlist;
  204466:	e9c4 4404 	strd	r4, r4, [r4, #16]
  20446a:	f8cc 2008 	str.w	r2, [ip, #8]
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  20446e:	f04f 4c80 	mov.w	ip, #1073741824	; 0x40000000
  SD3.clock = STM32_USART3CLK;
  204472:	f8c5 b058 	str.w	fp, [r5, #88]	; 0x58
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
  mp->object_size = size;
  mp->align = align;
  204476:	2204      	movs	r2, #4
  SPID1.spi       = SPI1;
  204478:	f8df b1c4 	ldr.w	fp, [pc, #452]	; 204640 <main+0x440>
  20447c:	f8c0 b01c 	str.w	fp, [r0, #28]
  SPID1.rxdmamode = STM32_DMA_CR_CHSEL(SPI1_RX_DMA_STREAM) |
  204480:	f8df b1c0 	ldr.w	fp, [pc, #448]	; 204644 <main+0x444>
  204484:	f8c0 b028 	str.w	fp, [r0, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI1_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID1.txdmamode = STM32_DMA_CR_CHSEL(SPI1_TX_DMA_STREAM) |
  204488:	f10b 0b30 	add.w	fp, fp, #48	; 0x30
  qp->prev = qp;
  20448c:	e9c0 9903 	strd	r9, r9, [r0, #12]
  204490:	f8c0 b02c 	str.w	fp, [r0, #44]	; 0x2c
  204494:	206b      	movs	r0, #107	; 0x6b
  ch_memcore.basemem = __heap_base__;
  204496:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 204648 <main+0x448>
  20449a:	f8cc 0028 	str.w	r0, [ip, #40]	; 0x28
  ch.vtlist.dlist.next = &ch.vtlist.dlist;
  20449e:	f104 001c 	add.w	r0, r4, #28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
  2044a2:	f8cc 802c 	str.w	r8, [ip, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
  2044a6:	f8cc 3018 	str.w	r3, [ip, #24]
  STM32_ST_TIM->CCR[0] = 0;
  2044aa:	f8cc 3034 	str.w	r3, [ip, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
  2044ae:	f8cc 300c 	str.w	r3, [ip, #12]
  STM32_ST_TIM->CR2    = 0;
  2044b2:	f8cc 3004 	str.w	r3, [ip, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
  2044b6:	f8cc 7014 	str.w	r7, [ip, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
  2044ba:	f8cc 7000 	str.w	r7, [ip]
  tmp->cumulative = (rttime_t)0;
  2044be:	4617      	mov	r7, r2
  pqp->next = pqp;
  2044c0:	6024      	str	r4, [r4, #0]
  ch.vtlist.dlist.prev = &ch.vtlist.dlist;
  2044c2:	e9c4 0007 	strd	r0, r0, [r4, #28]
  2044c6:	61ca      	str	r2, [r1, #28]
  2044c8:	634a      	str	r2, [r1, #52]	; 0x34
  2044ca:	4a60      	ldr	r2, [pc, #384]	; (20464c <main+0x44c>)
  mp->provider = provider;
  2044cc:	4860      	ldr	r0, [pc, #384]	; (204650 <main+0x450>)
  2044ce:	f8c9 2000 	str.w	r2, [r9]
  ch_memcore.topmem  = __heap_end__;
  2044d2:	4a60      	ldr	r2, [pc, #384]	; (204654 <main+0x454>)
  ch.vtlist.lasttime = (systime_t)0;
  2044d4:	62a3      	str	r3, [r4, #40]	; 0x28
  2044d6:	f8c9 2004 	str.w	r2, [r9, #4]
  2044da:	4a5f      	ldr	r2, [pc, #380]	; (204658 <main+0x458>)
  2044dc:	f8ce 3014 	str.w	r3, [lr, #20]
  2044e0:	f8ce 2000 	str.w	r2, [lr]
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {

  dlp->next = (dyn_element_t *)dlp;
  2044e4:	f101 0210 	add.w	r2, r1, #16
  2044e8:	608b      	str	r3, [r1, #8]
  2044ea:	610a      	str	r2, [r1, #16]
  mp->object_size = size;
  2044ec:	2214      	movs	r2, #20
  mp->next = NULL;
  2044ee:	614b      	str	r3, [r1, #20]
  mp->object_size = size;
  2044f0:	618a      	str	r2, [r1, #24]
  2044f2:	f101 0224 	add.w	r2, r1, #36	; 0x24
  mp->next = NULL;
  2044f6:	62cb      	str	r3, [r1, #44]	; 0x2c
  2044f8:	624a      	str	r2, [r1, #36]	; 0x24
  2044fa:	f101 0228 	add.w	r2, r1, #40	; 0x28
  ch.tm.offset = (rtcnt_t)0;
  2044fe:	6763      	str	r3, [r4, #116]	; 0x74
  204500:	628a      	str	r2, [r1, #40]	; 0x28
  mp->object_size = size;
  204502:	221c      	movs	r2, #28
  ch.vtlist.dlist.delta = (sysinterval_t)-1;
  204504:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
  204508:	630a      	str	r2, [r1, #48]	; 0x30
  20450a:	f101 023c 	add.w	r2, r1, #60	; 0x3c
  tmp->best       = (rtcnt_t)-1;
  20450e:	f8cd 8010 	str.w	r8, [sp, #16]
  204512:	63ca      	str	r2, [r1, #60]	; 0x3c
  204514:	f101 0240 	add.w	r2, r1, #64	; 0x40
  mp->provider = provider;
  204518:	6208      	str	r0, [r1, #32]
  20451a:	640a      	str	r2, [r1, #64]	; 0x40
  20451c:	f101 0244 	add.w	r2, r1, #68	; 0x44
  204520:	6388      	str	r0, [r1, #56]	; 0x38
  204522:	644a      	str	r2, [r1, #68]	; 0x44
  tmp->cumulative = (rttime_t)0;
  204524:	2200      	movs	r2, #0
  H_NEXT(&default_heap.header) = NULL;
  H_PAGES(&default_heap.header) = 0;
  204526:	e9ce 3301 	strd	r3, r3, [lr, #4]
  tmp->last       = (rtcnt_t)0;
  20452a:	e9cd 3305 	strd	r3, r3, [sp, #20]
  qp->prev = qp;
  20452e:	e9ce aa03 	strd	sl, sl, [lr, #12]
  204532:	e9c1 1100 	strd	r1, r1, [r1]
  tmp->n          = (ucnt_t)0;
  204536:	9307      	str	r3, [sp, #28]
  tmp->cumulative = (rttime_t)0;
  204538:	2300      	movs	r3, #0
  20453a:	e9cd 2308 	strd	r2, r3, [sp, #32]
    chTMStartMeasurementX(&tm);
  20453e:	a804      	add	r0, sp, #16
  204540:	f7fc f8ae 	bl	2006a0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
  204544:	f7fc f8b4 	bl	2006b0 <chTMStopMeasurementX>
  } while (i > 0U);
  204548:	3f01      	subs	r7, #1
  20454a:	d1f8      	bne.n	20453e <main+0x33e>
  ch.tm.offset = tm.best;
  20454c:	9b04      	ldr	r3, [sp, #16]
  tp->refs            = (trefs_t)1;
  20454e:	2201      	movs	r2, #1
  REG_INSERT(tp);
  204550:	4942      	ldr	r1, [pc, #264]	; (20465c <main+0x45c>)
  204552:	f04f 0820 	mov.w	r8, #32
  204556:	6763      	str	r3, [r4, #116]	; 0x74
  tp->hdr.pqueue.prio = prio;
  204558:	2380      	movs	r3, #128	; 0x80
  REG_INSERT(tp);
  20455a:	f8d4 c014 	ldr.w	ip, [r4, #20]
  qp->next = qp;
  20455e:	f101 002c 	add.w	r0, r1, #44	; 0x2c
  tp->hdr.pqueue.prio = prio;
  204562:	63a3      	str	r3, [r4, #56]	; 0x38
  tp->realprio        = prio;
  204564:	66e3      	str	r3, [r4, #108]	; 0x6c
  lp->next = lp;
  204566:	f101 0328 	add.w	r3, r1, #40	; 0x28
  tp->name            = name;
  20456a:	f8df e0f4 	ldr.w	lr, [pc, #244]	; 204660 <main+0x460>
  tp->flags           = CH_FLAG_MODE_STATIC;
  20456e:	f884 7051 	strb.w	r7, [r4, #81]	; 0x51
  REG_INSERT(tp);
  204572:	6424      	str	r4, [r4, #64]	; 0x40
  204574:	f8c4 c044 	str.w	ip, [r4, #68]	; 0x44
  tp->refs            = (trefs_t)1;
  204578:	f884 2052 	strb.w	r2, [r4, #82]	; 0x52
  tp->name            = name;
  20457c:	f8c4 e048 	str.w	lr, [r4, #72]	; 0x48
  tp->epending        = (eventmask_t)0;
  204580:	e9c4 7719 	strd	r7, r7, [r4, #100]	; 0x64
  REG_INSERT(tp);
  204584:	f8cc 1010 	str.w	r1, [ip, #16]
  204588:	65a3      	str	r3, [r4, #88]	; 0x58
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
  20458a:	f884 2050 	strb.w	r2, [r4, #80]	; 0x50
  currp->wabase = NULL;
  20458e:	64e7      	str	r7, [r4, #76]	; 0x4c
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  204590:	e9c4 1105 	strd	r1, r1, [r4, #20]
  qp->prev = qp;
  204594:	e9c4 0017 	strd	r0, r0, [r4, #92]	; 0x5c
  204598:	f388 8811 	msr	BASEPRI, r8
  __ASM volatile ("cpsie i" : : : "memory");
  20459c:	b662      	cpsie	i
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  20459e:	4b31      	ldr	r3, [pc, #196]	; (204664 <main+0x464>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  2045a0:	f64f 0eff 	movw	lr, #63743	; 0xf8ff
  reg_value  =  (reg_value                                   |
  2045a4:	4830      	ldr	r0, [pc, #192]	; (204668 <main+0x468>)
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  2045a6:	f8d3 c00c 	ldr.w	ip, [r3, #12]
  DWT->LAR = 0xC5ACCE55U;
  2045aa:	4930      	ldr	r1, [pc, #192]	; (20466c <main+0x46c>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  2045ac:	ea0c 0c0e 	and.w	ip, ip, lr
  reg_value  =  (reg_value                                   |
  2045b0:	ea4c 0000 	orr.w	r0, ip, r0
  SCB->AIRCR =  reg_value;
  2045b4:	60d8      	str	r0, [r3, #12]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  2045b6:	f8d3 00fc 	ldr.w	r0, [r3, #252]	; 0xfc
  2045ba:	f040 7080 	orr.w	r0, r0, #16777216	; 0x1000000
  2045be:	f8c3 00fc 	str.w	r0, [r3, #252]	; 0xfc
  DWT->LAR = 0xC5ACCE55U;
  2045c2:	482b      	ldr	r0, [pc, #172]	; (204670 <main+0x470>)
  2045c4:	f8c1 0fb0 	str.w	r0, [r1, #4016]	; 0xfb0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  2045c8:	6808      	ldr	r0, [r1, #0]
  2045ca:	4310      	orrs	r0, r2
  2045cc:	6008      	str	r0, [r1, #0]
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  2045ce:	2110      	movs	r1, #16
  2045d0:	77d9      	strb	r1, [r3, #31]
  2045d2:	f883 8022 	strb.w	r8, [r3, #34]	; 0x22
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2045d6:	f387 8811 	msr	BASEPRI, r7
  __ASM volatile ("cpsie i" : : : "memory");
  2045da:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
  2045dc:	f388 8811 	msr	BASEPRI, r8
  2045e0:	e048      	b.n	204674 <main+0x474>
  2045e2:	bf00      	nop
  2045e4:	40026000 	.word	0x40026000
  2045e8:	40026400 	.word	0x40026400
  2045ec:	e000e100 	.word	0xe000e100
  2045f0:	200008e8 	.word	0x200008e8
  2045f4:	20000858 	.word	0x20000858
  2045f8:	20000810 	.word	0x20000810
  2045fc:	20000828 	.word	0x20000828
  204600:	20000800 	.word	0x20000800
  204604:	40000400 	.word	0x40000400
  204608:	20001b8c 	.word	0x20001b8c
  20460c:	200008b8 	.word	0x200008b8
  204610:	0337f980 	.word	0x0337f980
  204614:	20000ef4 	.word	0x20000ef4
  204618:	40000800 	.word	0x40000800
  20461c:	e0042000 	.word	0xe0042000
  204620:	40010000 	.word	0x40010000
  204624:	08005ff4 	.word	0x08005ff4
  204628:	20001b9c 	.word	0x20001b9c
  20462c:	00200611 	.word	0x00200611
  204630:	200009d0 	.word	0x200009d0
  204634:	40004800 	.word	0x40004800
  204638:	40023800 	.word	0x40023800
  20463c:	20000a48 	.word	0x20000a48
  204640:	40013000 	.word	0x40013000
  204644:	06010016 	.word	0x06010016
  204648:	20000b68 	.word	0x20000b68
  20464c:	200200d0 	.word	0x200200d0
  204650:	00200741 	.word	0x00200741
  204654:	20080000 	.word	0x20080000
  204658:	00200701 	.word	0x00200701
  20465c:	20000a00 	.word	0x20000a00
  204660:	08005c5c 	.word	0x08005c5c
  204664:	e000ed00 	.word	0xe000ed00
  204668:	05fa0300 	.word	0x05fa0300
  20466c:	e0001000 	.word	0xe0001000
  204670:	c5acce55 	.word	0xc5acce55
  tp->wabase = tdp->wbase;
  204674:	4bc2      	ldr	r3, [pc, #776]	; (204980 <main+0x780>)
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204676:	f103 016c 	add.w	r1, r3, #108	; 0x6c
  REG_INSERT(tp);
  20467a:	f103 0090 	add.w	r0, r3, #144	; 0x90
  tp->hdr.pqueue.prio = prio;
  20467e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204682:	f8c3 109c 	str.w	r1, [r3, #156]	; 0x9c
  204686:	49bf      	ldr	r1, [pc, #764]	; (204984 <main+0x784>)
  tp->realprio        = prio;
  204688:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  20468c:	66d9      	str	r1, [r3, #108]	; 0x6c
  20468e:	49be      	ldr	r1, [pc, #760]	; (204988 <main+0x788>)
  tp->refs            = (trefs_t)1;
  204690:	f883 20b2 	strb.w	r2, [r3, #178]	; 0xb2
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  204694:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
  tp->state           = CH_STATE_WTSTART;
  204698:	2102      	movs	r1, #2
  REG_INSERT(tp);
  20469a:	6962      	ldr	r2, [r4, #20]
  tp->state           = CH_STATE_WTSTART;
  20469c:	f8a3 10b0 	strh.w	r1, [r3, #176]	; 0xb0
  tp->name            = name;
  2046a0:	49ba      	ldr	r1, [pc, #744]	; (20498c <main+0x78c>)
  REG_INSERT(tp);
  2046a2:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  tp->wabase = tdp->wbase;
  2046a6:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  2046aa:	671f      	str	r7, [r3, #112]	; 0x70
  REG_INSERT(tp);
  2046ac:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
  tp->name            = name;
  2046b0:	f8c3 10a8 	str.w	r1, [r3, #168]	; 0xa8
  tp->epending        = (eventmask_t)0;
  2046b4:	e9c3 7731 	strd	r7, r7, [r3, #196]	; 0xc4
  REG_INSERT(tp);
  2046b8:	6110      	str	r0, [r2, #16]
  qp->next = qp;
  2046ba:	f103 02bc 	add.w	r2, r3, #188	; 0xbc
  2046be:	6160      	str	r0, [r4, #20]
  qp->prev = qp;
  2046c0:	e9c3 222f 	strd	r2, r2, [r3, #188]	; 0xbc
  lp->next = lp;
  2046c4:	f103 02b8 	add.w	r2, r3, #184	; 0xb8
  2046c8:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
  chSchWakeupS(tp, MSG_OK);
  2046cc:	f7fd fb20 	bl	201d10 <chSchWakeupS.constprop.0>
  2046d0:	f387 8811 	msr	BASEPRI, r7
  2046d4:	f388 8811 	msr	BASEPRI, r8
  if (sdp->state == SD_STOP) {
  2046d8:	7a2b      	ldrb	r3, [r5, #8]
  2046da:	2b01      	cmp	r3, #1
  2046dc:	f000 8589 	beq.w	2051f2 <main+0xff2>
    brr = (uint32_t)(sdp->clock / config->speed);
  2046e0:	6dab      	ldr	r3, [r5, #88]	; 0x58
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  2046e2:	2140      	movs	r1, #64	; 0x40
    brr = (uint32_t)(sdp->clock / config->speed);
  2046e4:	4aaa      	ldr	r2, [pc, #680]	; (204990 <main+0x790>)
  u->CR3 = config->cr3 | USART_CR3_EIE;
  2046e6:	2401      	movs	r4, #1
  sdp->state = SD_READY;
  2046e8:	f04f 0802 	mov.w	r8, #2
    brr = (uint32_t)(sdp->clock / config->speed);
  2046ec:	fba2 2303 	umull	r2, r3, r2, r3
  2046f0:	0c1a      	lsrs	r2, r3, #16
  USART_TypeDef *u = sdp->usart;
  2046f2:	6d6b      	ldr	r3, [r5, #84]	; 0x54
  u->BRR = brr;
  2046f4:	60da      	str	r2, [r3, #12]
  u->ICR = 0xFFFFFFFFU;
  2046f6:	f04f 32ff 	mov.w	r2, #4294967295
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  2046fa:	6059      	str	r1, [r3, #4]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  2046fc:	f240 112d 	movw	r1, #301	; 0x12d
  u->CR3 = config->cr3 | USART_CR3_EIE;
  204700:	609c      	str	r4, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
  204702:	6019      	str	r1, [r3, #0]
  u->ICR = 0xFFFFFFFFU;
  204704:	621a      	str	r2, [r3, #32]
  204706:	f885 8008 	strb.w	r8, [r5, #8]
    sdp->rxmask = 0xFF;
  20470a:	f885 205c 	strb.w	r2, [r5, #92]	; 0x5c
  20470e:	2500      	movs	r5, #0
  204710:	f385 8811 	msr	BASEPRI, r5
void Uart_Init(void)
{
  // запускаем драйвер в работу
  sdStart(uart3, &uart_conf);
  // Переводим ноги в состояние Rx, Tx
  palSetPadMode( GPIOD, 8, PAL_MODE_ALTERNATE(7) );
  204714:	489f      	ldr	r0, [pc, #636]	; (204994 <main+0x794>)
  204716:	f240 3282 	movw	r2, #898	; 0x382
  20471a:	f44f 7180 	mov.w	r1, #256	; 0x100
  20471e:	f04f 0920 	mov.w	r9, #32
  204722:	f7fb fe75 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode( GPIOD, 9, PAL_MODE_ALTERNATE(7) );
  204726:	f240 3282 	movw	r2, #898	; 0x382
  20472a:	f44f 7100 	mov.w	r1, #512	; 0x200
  20472e:	f7fb fe6f 	bl	200410 <_pal_lld_setgroupmode>
  mbp->buffer = buf;
  204732:	4a99      	ldr	r2, [pc, #612]	; (204998 <main+0x798>)
  204734:	4999      	ldr	r1, [pc, #612]	; (20499c <main+0x79c>)
    palSetLineMode(LINE_LED1, PAL_MODE_OUTPUT_PUSHPULL);
  204736:	f5a0 6000 	sub.w	r0, r0, #2048	; 0x800
  20473a:	4b99      	ldr	r3, [pc, #612]	; (2049a0 <main+0x7a0>)
  20473c:	6011      	str	r1, [r2, #0]
  mbp->cnt    = (size_t)0;
  20473e:	6115      	str	r5, [r2, #16]
  mbp->reset  = false;
  204740:	7515      	strb	r5, [r2, #20]
  mbp->cnt    = (size_t)0;
  204742:	611d      	str	r5, [r3, #16]
  mbp->reset  = false;
  204744:	751d      	strb	r5, [r3, #20]
  mbp->wrptr  = buf;
  204746:	e9c2 1102 	strd	r1, r1, [r2, #8]
  mbp->top    = &buf[n];
  20474a:	f501 71c8 	add.w	r1, r1, #400	; 0x190
  20474e:	6051      	str	r1, [r2, #4]
  mbp->buffer = buf;
  204750:	4994      	ldr	r1, [pc, #592]	; (2049a4 <main+0x7a4>)
  204752:	6019      	str	r1, [r3, #0]
  mbp->wrptr  = buf;
  204754:	e9c3 1102 	strd	r1, r1, [r3, #8]
  mbp->top    = &buf[n];
  204758:	f501 71c8 	add.w	r1, r1, #400	; 0x190
  20475c:	6059      	str	r1, [r3, #4]
  qp->next = qp;
  20475e:	f102 0118 	add.w	r1, r2, #24
  qp->prev = qp;
  204762:	e9c2 1106 	strd	r1, r1, [r2, #24]
  qp->next = qp;
  204766:	f102 0120 	add.w	r1, r2, #32
  qp->prev = qp;
  20476a:	e9c2 1108 	strd	r1, r1, [r2, #32]
  qp->next = qp;
  20476e:	f103 0218 	add.w	r2, r3, #24
  204772:	4621      	mov	r1, r4
  qp->prev = qp;
  204774:	e9c3 2206 	strd	r2, r2, [r3, #24]
  qp->next = qp;
  204778:	f103 0220 	add.w	r2, r3, #32
  qp->prev = qp;
  20477c:	e9c3 2208 	strd	r2, r2, [r3, #32]
  204780:	4622      	mov	r2, r4
  204782:	f7fb fe45 	bl	200410 <_pal_lld_setgroupmode>
    palSetLineMode(LINE_LED2, PAL_MODE_OUTPUT_PUSHPULL);
  204786:	4622      	mov	r2, r4
  204788:	2180      	movs	r1, #128	; 0x80
  20478a:	f7fb fe41 	bl	200410 <_pal_lld_setgroupmode>
    palSetLineMode(LINE_LED3, PAL_MODE_OUTPUT_PUSHPULL);
  20478e:	4622      	mov	r2, r4
  204790:	f44f 4180 	mov.w	r1, #16384	; 0x4000
  204794:	f7fb fe3c 	bl	200410 <_pal_lld_setgroupmode>
  204798:	f389 8811 	msr	BASEPRI, r9
  gptp->config = config;
  20479c:	4a82      	ldr	r2, [pc, #520]	; (2049a8 <main+0x7a8>)
  20479e:	4b83      	ldr	r3, [pc, #524]	; (2049ac <main+0x7ac>)
  2047a0:	4692      	mov	sl, r2
  gpt_lld_start(gptp);
  2047a2:	4610      	mov	r0, r2
  gptp->config = config;
  2047a4:	6053      	str	r3, [r2, #4]
  gpt_lld_start(gptp);
  2047a6:	f7fb fedb 	bl	200560 <gpt_lld_start>
  gptp->state = GPT_READY;
  2047aa:	f88a 8000 	strb.w	r8, [sl]
  2047ae:	f385 8811 	msr	BASEPRI, r5
  palSetPadMode(IN2_PORT,IN2_PIN,PAL_MODE_OUTPUT_PUSHPULL);
  2047b2:	487f      	ldr	r0, [pc, #508]	; (2049b0 <main+0x7b0>)
  2047b4:	4622      	mov	r2, r4
  2047b6:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  2047ba:	f7fb fe29 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(IN1_PORT,IN1_PIN,PAL_MODE_OUTPUT_PUSHPULL);
  2047be:	4622      	mov	r2, r4
  2047c0:	f5a0 6080 	sub.w	r0, r0, #1024	; 0x400
  2047c4:	f44f 7100 	mov.w	r1, #512	; 0x200
  2047c8:	f7fb fe22 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(ENA_PORT,ENA_PIN,  PAL_MODE_ALTERNATE(1) );
  2047cc:	2282      	movs	r2, #130	; 0x82
  2047ce:	f44f 6100 	mov.w	r1, #2048	; 0x800
  2047d2:	f7fb fe1d 	bl	200410 <_pal_lld_setgroupmode>
  2047d6:	f389 8811 	msr	BASEPRI, r9
  pwmp->config = config;
  2047da:	4b76      	ldr	r3, [pc, #472]	; (2049b4 <main+0x7b4>)
  if (pwmp->state == PWM_STOP) {
  2047dc:	7832      	ldrb	r2, [r6, #0]
  pwmp->period = config->period;
  2047de:	6859      	ldr	r1, [r3, #4]
  2047e0:	42a2      	cmp	r2, r4
  pwmp->config = config;
  2047e2:	6073      	str	r3, [r6, #4]
  pwmp->period = config->period;
  2047e4:	60b1      	str	r1, [r6, #8]
  2047e6:	f000 84e6 	beq.w	2051b6 <main+0xfb6>
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
  2047ea:	69b2      	ldr	r2, [r6, #24]
  2047ec:	6015      	str	r5, [r2, #0]
    if (pwmp->channels > 4) {
  2047ee:	7c30      	ldrb	r0, [r6, #16]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
  2047f0:	6355      	str	r5, [r2, #52]	; 0x34
    if (pwmp->channels > 4) {
  2047f2:	2804      	cmp	r0, #4
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
  2047f4:	6395      	str	r5, [r2, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
  2047f6:	63d5      	str	r5, [r2, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
  2047f8:	6415      	str	r5, [r2, #64]	; 0x40
    if (pwmp->channels > 4) {
  2047fa:	f200 84d8 	bhi.w	2051ae <main+0xfae>
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
  2047fe:	2000      	movs	r0, #0
  204800:	6250      	str	r0, [r2, #36]	; 0x24
  pwmp->tim->ARR  = pwmp->period - 1;
  204802:	1e48      	subs	r0, r1, #1
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  204804:	6972      	ldr	r2, [r6, #20]
  204806:	6819      	ldr	r1, [r3, #0]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
  204808:	68dd      	ldr	r5, [r3, #12]
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
  20480a:	fbb2 f2f1 	udiv	r2, r2, r1
  20480e:	1e51      	subs	r1, r2, #1
  pwmp->tim->PSC  = psc;
  204810:	69b2      	ldr	r2, [r6, #24]
  204812:	6291      	str	r1, [r2, #40]	; 0x28
  pwmp->tim->CR2  = pwmp->config->cr2;
  204814:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
  pwmp->tim->ARR  = pwmp->period - 1;
  204816:	62d0      	str	r0, [r2, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
  204818:	6051      	str	r1, [r2, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
  20481a:	f005 010f 	and.w	r1, r5, #15
  20481e:	2901      	cmp	r1, #1
  204820:	d002      	beq.n	204828 <main+0x628>
  204822:	2902      	cmp	r1, #2
  204824:	d102      	bne.n	20482c <main+0x62c>
    ccer |= STM32_TIM_CCER_CC1P;
  204826:	460f      	mov	r7, r1
    ccer |= STM32_TIM_CCER_CC1E;
  204828:	f047 0701 	orr.w	r7, r7, #1
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
  20482c:	695c      	ldr	r4, [r3, #20]
  20482e:	f004 010f 	and.w	r1, r4, #15
  204832:	2901      	cmp	r1, #1
  204834:	d003      	beq.n	20483e <main+0x63e>
  204836:	2902      	cmp	r1, #2
  204838:	d103      	bne.n	204842 <main+0x642>
    ccer |= STM32_TIM_CCER_CC2P;
  20483a:	f047 0720 	orr.w	r7, r7, #32
    ccer |= STM32_TIM_CCER_CC2E;
  20483e:	f047 0710 	orr.w	r7, r7, #16
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
  204842:	69d8      	ldr	r0, [r3, #28]
  204844:	f000 010f 	and.w	r1, r0, #15
  204848:	2901      	cmp	r1, #1
  20484a:	d003      	beq.n	204854 <main+0x654>
  20484c:	2902      	cmp	r1, #2
  20484e:	d103      	bne.n	204858 <main+0x658>
    ccer |= STM32_TIM_CCER_CC3P;
  204850:	f447 7700 	orr.w	r7, r7, #512	; 0x200
    ccer |= STM32_TIM_CCER_CC3E;
  204854:	f447 7780 	orr.w	r7, r7, #256	; 0x100
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
  204858:	6a59      	ldr	r1, [r3, #36]	; 0x24
  20485a:	f001 0c0f 	and.w	ip, r1, #15
  20485e:	f1bc 0f01 	cmp.w	ip, #1
  204862:	d004      	beq.n	20486e <main+0x66e>
  204864:	f1bc 0f02 	cmp.w	ip, #2
  204868:	d103      	bne.n	204872 <main+0x672>
    ccer |= STM32_TIM_CCER_CC4P;
  20486a:	f447 5700 	orr.w	r7, r7, #8192	; 0x2000
    ccer |= STM32_TIM_CCER_CC4E;
  20486e:	f447 5780 	orr.w	r7, r7, #4096	; 0x1000
    switch (pwmp->config->channels[0].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
  204872:	f005 05f0 	and.w	r5, r5, #240	; 0xf0
  204876:	2d10      	cmp	r5, #16
  204878:	d003      	beq.n	204882 <main+0x682>
  20487a:	2d20      	cmp	r5, #32
  20487c:	d103      	bne.n	204886 <main+0x686>
      ccer |= STM32_TIM_CCER_CC1NP;
  20487e:	f047 0708 	orr.w	r7, r7, #8
      ccer |= STM32_TIM_CCER_CC1NE;
  204882:	f047 0704 	orr.w	r7, r7, #4
    switch (pwmp->config->channels[1].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
  204886:	f004 04f0 	and.w	r4, r4, #240	; 0xf0
  20488a:	2c10      	cmp	r4, #16
  20488c:	d003      	beq.n	204896 <main+0x696>
  20488e:	2c20      	cmp	r4, #32
  204890:	d103      	bne.n	20489a <main+0x69a>
      ccer |= STM32_TIM_CCER_CC2NP;
  204892:	f047 0780 	orr.w	r7, r7, #128	; 0x80
      ccer |= STM32_TIM_CCER_CC2NE;
  204896:	f047 0740 	orr.w	r7, r7, #64	; 0x40
    switch (pwmp->config->channels[2].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
  20489a:	f000 00f0 	and.w	r0, r0, #240	; 0xf0
  20489e:	2810      	cmp	r0, #16
  2048a0:	d003      	beq.n	2048aa <main+0x6aa>
  2048a2:	2820      	cmp	r0, #32
  2048a4:	d103      	bne.n	2048ae <main+0x6ae>
      ccer |= STM32_TIM_CCER_CC3NP;
  2048a6:	f447 6700 	orr.w	r7, r7, #2048	; 0x800
      ccer |= STM32_TIM_CCER_CC3NE;
  2048aa:	f447 6780 	orr.w	r7, r7, #1024	; 0x400
    switch (pwmp->config->channels[3].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
  2048ae:	f001 01f0 	and.w	r1, r1, #240	; 0xf0
  2048b2:	2910      	cmp	r1, #16
  2048b4:	d003      	beq.n	2048be <main+0x6be>
  2048b6:	2920      	cmp	r1, #32
  2048b8:	d103      	bne.n	2048c2 <main+0x6c2>
      ccer |= STM32_TIM_CCER_CC4NP;
  2048ba:	f447 4700 	orr.w	r7, r7, #32768	; 0x8000
      ccer |= STM32_TIM_CCER_CC4NE;
  2048be:	f447 4780 	orr.w	r7, r7, #16384	; 0x4000
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  2048c2:	2500      	movs	r5, #0
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  2048c4:	f04f 0901 	mov.w	r9, #1
  pwmp->tim->CCER  = ccer;
  2048c8:	6217      	str	r7, [r2, #32]
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
  2048ca:	e9d3 3110 	ldrd	r3, r1, [r3, #64]	; 0x40
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
  2048ce:	f8c2 9014 	str.w	r9, [r2, #20]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
  2048d2:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
  2048d6:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
  2048da:	6115      	str	r5, [r2, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
  2048dc:	60d1      	str	r1, [r2, #12]
  pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
  2048de:	6453      	str	r3, [r2, #68]	; 0x44
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
  2048e0:	2385      	movs	r3, #133	; 0x85
  2048e2:	6013      	str	r3, [r2, #0]
  pwmp->state = PWM_READY;
  2048e4:	f04f 0302 	mov.w	r3, #2
  pwmp->enabled = 0;
  2048e8:	60f5      	str	r5, [r6, #12]
  pwmp->state = PWM_READY;
  2048ea:	7033      	strb	r3, [r6, #0]
  2048ec:	f385 8811 	msr	BASEPRI, r5
  IN1_HI;
  2048f0:	4b31      	ldr	r3, [pc, #196]	; (2049b8 <main+0x7b8>)
  2048f2:	f44f 7700 	mov.w	r7, #512	; 0x200
  IN2_LO;
  2048f6:	492e      	ldr	r1, [pc, #184]	; (2049b0 <main+0x7b0>)
  palSetPadMode(GPIOB, 8u, PAL_MODE_INPUT);
  2048f8:	462a      	mov	r2, r5
  IN1_HI;
  2048fa:	831f      	strh	r7, [r3, #24]
  IN2_LO;
  2048fc:	f44f 5300 	mov.w	r3, #8192	; 0x2000
  return input;
}

void Init_PID_Reg(void)
{
  Reg1.P=20;
  204900:	4c2e      	ldr	r4, [pc, #184]	; (2049bc <main+0x7bc>)
  204902:	834b      	strh	r3, [r1, #26]
  204904:	4b2e      	ldr	r3, [pc, #184]	; (2049c0 <main+0x7c0>)
  204906:	4e2f      	ldr	r6, [pc, #188]	; (2049c4 <main+0x7c4>)
  204908:	6023      	str	r3, [r4, #0]
  Reg1.D=0 ;
  Reg1.I=2;
  Reg1.Summ_Error=0;
  Reg1.Max_Summ_Error=MAX_I_Reg;
  20490a:	f242 7310 	movw	r3, #10000	; 0x2710
  flag_start=1;
  20490e:	492e      	ldr	r1, [pc, #184]	; (2049c8 <main+0x7c8>)
  204910:	4630      	mov	r0, r6
  204912:	60e3      	str	r3, [r4, #12]
  uint8_t arg = 5;
  204914:	f04f 0305 	mov.w	r3, #5
  204918:	f881 9000 	strb.w	r9, [r1]
  palSetPadMode(GPIOB, 8u, PAL_MODE_INPUT);
  20491c:	f44f 7180 	mov.w	r1, #256	; 0x100
  Reg1.D=0 ;
  204920:	80a5      	strh	r5, [r4, #4]
  Reg1.Summ_Error=0;
  204922:	60a5      	str	r5, [r4, #8]
  Reg1.Last_Process_Value=0;
  204924:	6125      	str	r5, [r4, #16]
  uint8_t arg = 5;
  204926:	f88d 3010 	strb.w	r3, [sp, #16]
  palSetPadMode(GPIOB, 8u, PAL_MODE_INPUT);
  20492a:	f7fb fd71 	bl	200410 <_pal_lld_setgroupmode>
  20492e:	2120      	movs	r1, #32
  204930:	4688      	mov	r8, r1
  204932:	f381 8811 	msr	BASEPRI, r1
  palEnablePadEvent(GPIOB, 8u, PAL_EVENT_MODE_BOTH_EDGES);
  204936:	2203      	movs	r2, #3
  204938:	2108      	movs	r1, #8
  20493a:	f7fb fdd9 	bl	2004f0 <_pal_lld_enablepadevent>
  20493e:	f385 8811 	msr	BASEPRI, r5
  204942:	f388 8811 	msr	BASEPRI, r8
  204946:	f8df b084 	ldr.w	fp, [pc, #132]	; 2049cc <main+0x7cc>
  20494a:	a904      	add	r1, sp, #16
  pep->cb = cb;
  20494c:	4b20      	ldr	r3, [pc, #128]	; (2049d0 <main+0x7d0>)
  pep->arg = arg;
  20494e:	f8cb 1044 	str.w	r1, [fp, #68]	; 0x44
  pep->cb = cb;
  204952:	f8cb 3040 	str.w	r3, [fp, #64]	; 0x40
  204956:	f385 8811 	msr	BASEPRI, r5
  palSetPadMode(GPIOB, 9u, PAL_MODE_INPUT);
  20495a:	4639      	mov	r1, r7
  20495c:	462a      	mov	r2, r5
  20495e:	4630      	mov	r0, r6
  204960:	f7fb fd56 	bl	200410 <_pal_lld_setgroupmode>
  mbp->buffer = buf;
  204964:	4b1b      	ldr	r3, [pc, #108]	; (2049d4 <main+0x7d4>)
  204966:	4a1c      	ldr	r2, [pc, #112]	; (2049d8 <main+0x7d8>)
  Motor_Init();
  Motor_Forward();
  Init_PID_Reg();
  Sensor_Gpio_Init();
  chMBObjectInit(&pid_mb, pid_mb_buffer, BUFFER_SIZE);
  chThdCreateStatic(pidThread, sizeof(pidThread), NORMALPRIO, pid, NULL);
  204968:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
  mbp->cnt    = (size_t)0;
  20496c:	611d      	str	r5, [r3, #16]
  mbp->buffer = buf;
  20496e:	601a      	str	r2, [r3, #0]
  mbp->reset  = false;
  204970:	751d      	strb	r5, [r3, #20]
  204972:	481a      	ldr	r0, [pc, #104]	; (2049dc <main+0x7dc>)
  mbp->wrptr  = buf;
  204974:	e9c3 2202 	strd	r2, r2, [r3, #8]
  mbp->top    = &buf[n];
  204978:	f502 72c8 	add.w	r2, r2, #400	; 0x190
  20497c:	605a      	str	r2, [r3, #4]
  20497e:	e02f      	b.n	2049e0 <main+0x7e0>
  204980:	20000a90 	.word	0x20000a90
  204984:	00200621 	.word	0x00200621
  204988:	002002f1 	.word	0x002002f1
  20498c:	08005ad8 	.word	0x08005ad8
  204990:	91a2b3c5 	.word	0x91a2b3c5
  204994:	40020c00 	.word	0x40020c00
  204998:	20000f98 	.word	0x20000f98
  20499c:	20000fc0 	.word	0x20000fc0
  2049a0:	20001e78 	.word	0x20001e78
  2049a4:	20001ea0 	.word	0x20001ea0
  2049a8:	20000800 	.word	0x20000800
  2049ac:	20020000 	.word	0x20020000
  2049b0:	40021400 	.word	0x40021400
  2049b4:	20020020 	.word	0x20020020
  2049b8:	40021000 	.word	0x40021000
  2049bc:	20000844 	.word	0x20000844
  2049c0:	00020014 	.word	0x00020014
  2049c4:	40020400 	.word	0x40020400
  2049c8:	20000f95 	.word	0x20000f95
  2049cc:	200008e8 	.word	0x200008e8
  2049d0:	00200761 	.word	0x00200761
  2049d4:	200019d0 	.word	0x200019d0
  2049d8:	200019f8 	.word	0x200019f8
  2049dc:	20001808 	.word	0x20001808
  qp->next = qp;
  2049e0:	f103 0218 	add.w	r2, r3, #24
  qp->prev = qp;
  2049e4:	e9c3 2206 	strd	r2, r2, [r3, #24]
  qp->next = qp;
  2049e8:	eb03 0208 	add.w	r2, r3, r8
  qp->prev = qp;
  2049ec:	e9c3 2208 	strd	r2, r2, [r3, #32]
  2049f0:	4bd6      	ldr	r3, [pc, #856]	; (204d4c <main+0xb4c>)
  2049f2:	2280      	movs	r2, #128	; 0x80
  2049f4:	f7fd f9bc 	bl	201d70 <chThdCreateStatic.constprop.0.isra.0>
  palSetPadMode(DB8_GPIO_Port,DB8_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  2049f8:	48d5      	ldr	r0, [pc, #852]	; (204d50 <main+0xb50>)
  2049fa:	464a      	mov	r2, r9
  2049fc:	4649      	mov	r1, r9
  2049fe:	f7fb fd07 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(DB9_GPIO_Port,DB9_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a02:	464a      	mov	r2, r9
  204a04:	2102      	movs	r1, #2
  204a06:	f7fb fd03 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(DB10_GPIO_Port,DB10_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a0a:	464a      	mov	r2, r9
  204a0c:	2104      	movs	r1, #4
  204a0e:	f7fb fcff 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(DB11_GPIO_Port,DB11_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a12:	464a      	mov	r2, r9
  204a14:	2108      	movs	r1, #8
  204a16:	f7fb fcfb 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(DB12_GPIO_Port,DB12_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a1a:	464a      	mov	r2, r9
  204a1c:	2110      	movs	r1, #16
  204a1e:	f7fb fcf7 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(DB13_GPIO_Port,DB13_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a22:	464a      	mov	r2, r9
  204a24:	4641      	mov	r1, r8
  204a26:	f7fb fcf3 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(DB14_GPIO_Port,DB14_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a2a:	464a      	mov	r2, r9
  204a2c:	2140      	movs	r1, #64	; 0x40
  204a2e:	f7fb fcef 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(DB15_GPIO_Port,DB15_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a32:	464a      	mov	r2, r9
  204a34:	2180      	movs	r1, #128	; 0x80
  204a36:	f7fb fceb 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(CS_GPIO_Port,CS_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a3a:	4630      	mov	r0, r6
  204a3c:	464a      	mov	r2, r9
  204a3e:	2110      	movs	r1, #16
  204a40:	f7fb fce6 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(RESET_GPIO_Port,RESET_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a44:	464a      	mov	r2, r9
  204a46:	4641      	mov	r1, r8
  204a48:	f7fb fce2 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(RS_GPIO_Port,RS_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a4c:	464a      	mov	r2, r9
  204a4e:	2140      	movs	r1, #64	; 0x40
  204a50:	f7fb fcde 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(WR_GPIO_Port,WR_Pin,PAL_MODE_OUTPUT_PUSHPULL);
  204a54:	464a      	mov	r2, r9
  204a56:	2102      	movs	r1, #2
  204a58:	f7fb fcda 	bl	200410 <_pal_lld_setgroupmode>
  palSetPadMode(RD_GPIO_Port,RD_Pin,PAL_MODE_OUTPUT_PUSHPULL);	
  204a5c:	464a      	mov	r2, r9
  204a5e:	2104      	movs	r1, #4
  204a60:	f7fb fcd6 	bl	200410 <_pal_lld_setgroupmode>
    RESET_Hi;
  204a64:	f04f 0120 	mov.w	r1, #32
	TFT_Send_Cmd(0x01);        //Software Reset
  204a68:	4648      	mov	r0, r9
    RESET_Hi;
  204a6a:	8331      	strh	r1, [r6, #24]
	TFT_Send_Cmd(0x01);        //Software Reset
  204a6c:	f7fc fc60 	bl	201330 <TFT_Send_Cmd>
  204a70:	f388 8811 	msr	BASEPRI, r8
  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
  204a74:	49b7      	ldr	r1, [pc, #732]	; (204d54 <main+0xb54>)
  204a76:	2008      	movs	r0, #8
  204a78:	f7fc f9da 	bl	200e30 <chSchGoSleepTimeoutS>
  204a7c:	f385 8811 	msr	BASEPRI, r5
	TFT_Send_Cmd(0xC0);
  204a80:	20c0      	movs	r0, #192	; 0xc0
  204a82:	f7fc fc55 	bl	201330 <TFT_Send_Cmd>
	TFT_Write_Data(0x25);	
  204a86:	2025      	movs	r0, #37	; 0x25
  204a88:	f7fc fc72 	bl	201370 <TFT_Write_Data>
	TFT_Send_Cmd(0xC1);
  204a8c:	20c1      	movs	r0, #193	; 0xc1
  204a8e:	f7fc fc4f 	bl	201330 <TFT_Send_Cmd>
	TFT_Write_Data(0x11);
  204a92:	2011      	movs	r0, #17
  204a94:	f7fc fc6c 	bl	201370 <TFT_Write_Data>
	TFT_Send_Cmd(0xC5);
  204a98:	20c5      	movs	r0, #197	; 0xc5
  204a9a:	f7fc fc49 	bl	201330 <TFT_Send_Cmd>
	TFT_Write_Data(0x2B);	        //VCOMH = 3.825
  204a9e:	202b      	movs	r0, #43	; 0x2b
  204aa0:	f7fc fc66 	bl	201370 <TFT_Write_Data>
	TFT_Write_Data(0x2B);  	//VCOML = -1.375
  204aa4:	202b      	movs	r0, #43	; 0x2b
  204aa6:	f7fc fc63 	bl	201370 <TFT_Write_Data>
	TFT_Send_Cmd(0xC7);
  204aaa:	20c7      	movs	r0, #199	; 0xc7
  204aac:	f7fc fc40 	bl	201330 <TFT_Send_Cmd>
	TFT_Write_Data(0x86);        //VML=58 VMH=58
  204ab0:	2086      	movs	r0, #134	; 0x86
  204ab2:	f7fc fc5d 	bl	201370 <TFT_Write_Data>
  TFT_Send_Cmd(0x36);
  204ab6:	2036      	movs	r0, #54	; 0x36
  204ab8:	f7fc fc3a 	bl	201330 <TFT_Send_Cmd>
		case 1: TFT_Write_Data(0x28);
  204abc:	2028      	movs	r0, #40	; 0x28
  204abe:	f7fc fc57 	bl	201370 <TFT_Write_Data>
		MAX_X = 319;
  204ac2:	4ba5      	ldr	r3, [pc, #660]	; (204d58 <main+0xb58>)
  204ac4:	f240 123f 	movw	r2, #319	; 0x13f
	TFT_Send_Cmd(0x3A);
  204ac8:	203a      	movs	r0, #58	; 0x3a
		MAX_X = 319;
  204aca:	601a      	str	r2, [r3, #0]
		MAX_Y = 239;
  204acc:	22ef      	movs	r2, #239	; 0xef
  204ace:	4ba3      	ldr	r3, [pc, #652]	; (204d5c <main+0xb5c>)
  204ad0:	601a      	str	r2, [r3, #0]
	TFT_Send_Cmd(0x3A);
  204ad2:	f7fc fc2d 	bl	201330 <TFT_Send_Cmd>
	TFT_Write_Data(0x05);
  204ad6:	2005      	movs	r0, #5
  204ad8:	f7fc fc4a 	bl	201370 <TFT_Write_Data>
	TFT_Send_Cmd(0xB1);
  204adc:	20b1      	movs	r0, #177	; 0xb1
  204ade:	f7fc fc27 	bl	201330 <TFT_Send_Cmd>
	TFT_Write_Data(0x00);
  204ae2:	4628      	mov	r0, r5
  204ae4:	f7fc fc44 	bl	201370 <TFT_Write_Data>
	TFT_Write_Data(0x18);	 //Frame Rate 79Hz
  204ae8:	2018      	movs	r0, #24
  204aea:	f7fc fc41 	bl	201370 <TFT_Write_Data>
	TFT_Send_Cmd(0xB6);
  204aee:	20b6      	movs	r0, #182	; 0xb6
  204af0:	f7fc fc1e 	bl	201330 <TFT_Send_Cmd>
	TFT_Write_Data(0x0A);
  204af4:	200a      	movs	r0, #10
  204af6:	f7fc fc3b 	bl	201370 <TFT_Write_Data>
	TFT_Write_Data(0x82);
  204afa:	2082      	movs	r0, #130	; 0x82
  204afc:	f7fc fc38 	bl	201370 <TFT_Write_Data>
	TFT_Write_Data(0x27);
  204b00:	2027      	movs	r0, #39	; 0x27
  204b02:	f7fc fc35 	bl	201370 <TFT_Write_Data>
	TFT_Send_Cmd(0x11);
  204b06:	2011      	movs	r0, #17
  204b08:	f7fc fc12 	bl	201330 <TFT_Send_Cmd>
  204b0c:	f388 8811 	msr	BASEPRI, r8
  204b10:	4993      	ldr	r1, [pc, #588]	; (204d60 <main+0xb60>)
  204b12:	2008      	movs	r0, #8
  204b14:	f7fc f98c 	bl	200e30 <chSchGoSleepTimeoutS>
  204b18:	f385 8811 	msr	BASEPRI, r5
	TFT_Send_Cmd(0x29);
  204b1c:	2029      	movs	r0, #41	; 0x29
  menu1->menu_value=-1;
  204b1e:	f04f 38ff 	mov.w	r8, #4294967295
  204b22:	f7fc fc05 	bl	201330 <TFT_Send_Cmd>
  menu1=malloc(sizeof(node_t));
  204b26:	202c      	movs	r0, #44	; 0x2c
  204b28:	f000 fb7a 	bl	205220 <malloc>
  menu1->text="Motor Control";
  204b2c:	4b8d      	ldr	r3, [pc, #564]	; (204d64 <main+0xb64>)
  menu1=malloc(sizeof(node_t));
  204b2e:	4682      	mov	sl, r0
  menu1->prev=NULL;
  204b30:	60c5      	str	r5, [r0, #12]
  menu1->text="Motor Control";
  204b32:	6003      	str	r3, [r0, #0]
  menu1->starttext="Main Menu";
  204b34:	4b8c      	ldr	r3, [pc, #560]	; (204d68 <main+0xb68>)
  menu1->parent=NULL;
  204b36:	6145      	str	r5, [r0, #20]
  menu1->starttext="Main Menu";
  204b38:	6043      	str	r3, [r0, #4]
  menu1->next=malloc(sizeof(node_t));
  204b3a:	202c      	movs	r0, #44	; 0x2c
  204b3c:	f000 fb70 	bl	205220 <malloc>
  204b40:	4606      	mov	r6, r0
  204b42:	f8ca 0010 	str.w	r0, [sl, #16]
  menu1->child=malloc(sizeof(node_t));
  204b46:	202c      	movs	r0, #44	; 0x2c
  204b48:	f000 fb6a 	bl	205220 <malloc>
  menu1->y_pos=70;
  204b4c:	233c      	movs	r3, #60	; 0x3c
  204b4e:	2246      	movs	r2, #70	; 0x46
  menu1->child=malloc(sizeof(node_t));
  204b50:	4607      	mov	r7, r0
  menu1->bool_value=NULL;
  204b52:	f8ca 5024 	str.w	r5, [sl, #36]	; 0x24
  menu1->cmd=0;
  204b56:	f88a 5008 	strb.w	r5, [sl, #8]
  menu1->child=malloc(sizeof(node_t));
  204b5a:	f8ca 0018 	str.w	r0, [sl, #24]
  menu1_1->prev=NULL;
  204b5e:	60c5      	str	r5, [r0, #12]
  menu1->menu_value=-1;
  204b60:	f8aa 8028 	strh.w	r8, [sl, #40]	; 0x28
  menu1_1->bool_value="FALSE";
  204b64:	f8df b204 	ldr.w	fp, [pc, #516]	; 204d6c <main+0xb6c>
  menu1->y_pos=70;
  204b68:	e9ca 3207 	strd	r3, r2, [sl, #28]
  menu1_1=menu1->child;
  204b6c:	4a80      	ldr	r2, [pc, #512]	; (204d70 <main+0xb70>)
  204b6e:	6010      	str	r0, [r2, #0]
  menu1_1->text="Motor Start";
  204b70:	4a80      	ldr	r2, [pc, #512]	; (204d74 <main+0xb74>)
  204b72:	6002      	str	r2, [r0, #0]
  menu1_1->starttext="Menu Settings";
  204b74:	4a80      	ldr	r2, [pc, #512]	; (204d78 <main+0xb78>)
  menu1_1->child=NULL;
  204b76:	e9c0 a505 	strd	sl, r5, [r0, #20]
  menu1_1->starttext="Menu Settings";
  204b7a:	6042      	str	r2, [r0, #4]
  menu1_1->next=malloc(sizeof(node_t));
  204b7c:	202c      	movs	r0, #44	; 0x2c
  204b7e:	f000 fb4f 	bl	205220 <malloc>
  menu1_1->y_pos=50;
  204b82:	2232      	movs	r2, #50	; 0x32
  menu1_1->cmd=START;
  204b84:	f04f 0305 	mov.w	r3, #5
  menu1_1->menu_value=-1;
  204b88:	f8a7 8028 	strh.w	r8, [r7, #40]	; 0x28
  menu1_1->y_pos=50;
  204b8c:	623a      	str	r2, [r7, #32]
  menu1_1->next=malloc(sizeof(node_t));
  204b8e:	4680      	mov	r8, r0
  menu1_2=menu1_1->next;
  204b90:	4a7a      	ldr	r2, [pc, #488]	; (204d7c <main+0xb7c>)
  menu1_1->cmd=START;
  204b92:	723b      	strb	r3, [r7, #8]
  menu1_1->x_pos=10;
  204b94:	230a      	movs	r3, #10
  menu1_2=menu1_1->next;
  204b96:	6010      	str	r0, [r2, #0]
  menu1_2->text="Motor Stop";
  204b98:	4a79      	ldr	r2, [pc, #484]	; (204d80 <main+0xb80>)
  menu1_1->next=malloc(sizeof(node_t));
  204b9a:	6138      	str	r0, [r7, #16]
  menu1_2->text="Motor Stop";
  204b9c:	6002      	str	r2, [r0, #0]
  menu1_2->cmd=STOP;
  204b9e:	2206      	movs	r2, #6
  menu1_2->parent=menu1;
  204ba0:	f8c0 a014 	str.w	sl, [r0, #20]
  menu1_2->starttext=NULL;
  204ba4:	6045      	str	r5, [r0, #4]
  menu1_2->child=NULL;
  204ba6:	6185      	str	r5, [r0, #24]
  menu1_2->prev=menu1_1;
  204ba8:	60c7      	str	r7, [r0, #12]
  menu1_1->x_pos=10;
  204baa:	61fb      	str	r3, [r7, #28]
  menu1_1->bool_value="FALSE";
  204bac:	f8c7 b024 	str.w	fp, [r7, #36]	; 0x24
  menu1_2->cmd=STOP;
  204bb0:	7202      	strb	r2, [r0, #8]
  menu1_2->next=malloc(sizeof(node_t));
  204bb2:	202c      	movs	r0, #44	; 0x2c
  204bb4:	f000 fb34 	bl	205220 <malloc>
  menu1_2->menu_value=-1;
  204bb8:	f04f 32ff 	mov.w	r2, #4294967295
  menu1_2->y_pos=90;
  204bbc:	215a      	movs	r1, #90	; 0x5a
  menu1_2->x_pos=10;
  204bbe:	230a      	movs	r3, #10
  menu1_2->menu_value=-1;
  204bc0:	f8a8 2028 	strh.w	r2, [r8, #40]	; 0x28
  menu1_2->next=malloc(sizeof(node_t));
  204bc4:	4607      	mov	r7, r0
  menu1_3=menu1_2->next;
  204bc6:	4a6f      	ldr	r2, [pc, #444]	; (204d84 <main+0xb84>)
  menu1_2->y_pos=90;
  204bc8:	f8c8 1020 	str.w	r1, [r8, #32]
  menu1_3->cmd=FORWARD;
  204bcc:	f04f 0108 	mov.w	r1, #8
  menu1_3=menu1_2->next;
  204bd0:	6010      	str	r0, [r2, #0]
  menu1_3->text="Motor Forward";
  204bd2:	4a6d      	ldr	r2, [pc, #436]	; (204d88 <main+0xb88>)
  menu1_3->cmd=FORWARD;
  204bd4:	7201      	strb	r1, [r0, #8]
  menu1_2->x_pos=10;
  204bd6:	f8c8 301c 	str.w	r3, [r8, #28]
  menu1_2->bool_value="FALSE";
  204bda:	f8c8 b024 	str.w	fp, [r8, #36]	; 0x24
  menu1_2->next=malloc(sizeof(node_t));
  204bde:	f8c8 0010 	str.w	r0, [r8, #16]
  menu1_3->parent=menu1;
  204be2:	f8c0 a014 	str.w	sl, [r0, #20]
  menu1_3->starttext=NULL;
  204be6:	6045      	str	r5, [r0, #4]
  menu1_3->child=NULL;
  204be8:	6185      	str	r5, [r0, #24]
  menu1_3->prev=menu1_2;
  204bea:	f8c0 800c 	str.w	r8, [r0, #12]
  menu1_3->menu_value=-1;
  204bee:	f04f 38ff 	mov.w	r8, #4294967295
  menu1_3->text="Motor Forward";
  204bf2:	6002      	str	r2, [r0, #0]
  menu1_3->next=malloc(sizeof(node_t));;
  204bf4:	202c      	movs	r0, #44	; 0x2c
  204bf6:	f000 fb13 	bl	205220 <malloc>
  menu1_3->y_pos=130;
  204bfa:	2282      	movs	r2, #130	; 0x82
  menu1_3->x_pos=10;
  204bfc:	230a      	movs	r3, #10
  menu1_4->y_pos=170;
  204bfe:	f04f 0caa 	mov.w	ip, #170	; 0xaa
  menu1_3->y_pos=130;
  204c02:	623a      	str	r2, [r7, #32]
  menu1_4=menu1_3->next;
  204c04:	4a61      	ldr	r2, [pc, #388]	; (204d8c <main+0xb8c>)
  menu1_3->bool_value="FALSE";
  204c06:	f8c7 b024 	str.w	fp, [r7, #36]	; 0x24
  menu1_4=menu1_3->next;
  204c0a:	6010      	str	r0, [r2, #0]
  menu1_4->text="Motor Back";
  204c0c:	4a60      	ldr	r2, [pc, #384]	; (204d90 <main+0xb90>)
  menu1_4->bool_value="FALSE";
  204c0e:	f8c0 b024 	str.w	fp, [r0, #36]	; 0x24
  menu1_4->text="Motor Back";
  204c12:	6002      	str	r2, [r0, #0]
  menu1_4->cmd=BACK;
  204c14:	2207      	movs	r2, #7
  menu2->text="Motor Speed";
  204c16:	f8df b17c 	ldr.w	fp, [pc, #380]	; 204d94 <main+0xb94>
  menu1_3->x_pos=10;
  204c1a:	61fb      	str	r3, [r7, #28]
  menu1_4->x_pos=10;
  204c1c:	61c3      	str	r3, [r0, #28]
  menu1_4->y_pos=170;
  204c1e:	f8c0 c020 	str.w	ip, [r0, #32]
  menu1_4->cmd=BACK;
  204c22:	7202      	strb	r2, [r0, #8]
  menu1_3->next=malloc(sizeof(node_t));;
  204c24:	6138      	str	r0, [r7, #16]
  menu1_3->menu_value=-1;
  204c26:	f8a7 8028 	strh.w	r8, [r7, #40]	; 0x28
  menu1_4->parent=menu1;
  204c2a:	f8c0 a014 	str.w	sl, [r0, #20]
  menu1_4->starttext=NULL;
  204c2e:	6045      	str	r5, [r0, #4]
  menu1_4->child=NULL;
  204c30:	6185      	str	r5, [r0, #24]
  menu1_4->menu_value=-1;
  204c32:	f8a0 8028 	strh.w	r8, [r0, #40]	; 0x28
  menu1_4->next=NULL;
  204c36:	e9c0 7503 	strd	r7, r5, [r0, #12]
  menu2->child=malloc(sizeof(node_t));
  204c3a:	202c      	movs	r0, #44	; 0x2c
  204c3c:	f000 faf0 	bl	205220 <malloc>
  menu2->parent=NULL;
  204c40:	6175      	str	r5, [r6, #20]
  menu2->child=malloc(sizeof(node_t));
  204c42:	4607      	mov	r7, r0
  menu2->starttext=NULL;
  204c44:	6075      	str	r5, [r6, #4]
  menu2->prev=menu1;
  204c46:	f8c6 a00c 	str.w	sl, [r6, #12]
  menu2->child=malloc(sizeof(node_t));
  204c4a:	61b0      	str	r0, [r6, #24]
  menu2->next=malloc(sizeof(node_t));
  204c4c:	202c      	movs	r0, #44	; 0x2c
  menu2->text="Motor Speed";
  204c4e:	f8c6 b000 	str.w	fp, [r6]
  menu2->next=malloc(sizeof(node_t));
  204c52:	f000 fae5 	bl	205220 <malloc>
  menu2->menu_value=-1;
  204c56:	f04f 32ff 	mov.w	r2, #4294967295
  menu2->x_pos=60;
  204c5a:	233c      	movs	r3, #60	; 0x3c
  menu2_1=menu2->child;
  204c5c:	494e      	ldr	r1, [pc, #312]	; (204d98 <main+0xb98>)
  menu2->menu_value=-1;
  204c5e:	8532      	strh	r2, [r6, #40]	; 0x28
  menu2->next=malloc(sizeof(node_t));
  204c60:	4680      	mov	r8, r0
  menu2_1->menu_value=set_speed;
  204c62:	4a4e      	ldr	r2, [pc, #312]	; (204d9c <main+0xb9c>)
  menu2->y_pos=110;
  204c64:	f04f 0c6e 	mov.w	ip, #110	; 0x6e
  menu2->x_pos=60;
  204c68:	61f3      	str	r3, [r6, #28]
  menu2_1->y_pos=70;
  204c6a:	230a      	movs	r3, #10
  menu2_1->menu_value=set_speed;
  204c6c:	8812      	ldrh	r2, [r2, #0]
  menu2->next=malloc(sizeof(node_t));
  204c6e:	6130      	str	r0, [r6, #16]
  menu2_1->y_pos=70;
  204c70:	2046      	movs	r0, #70	; 0x46
  menu2_1->menu_value=set_speed;
  204c72:	853a      	strh	r2, [r7, #40]	; 0x28
  menu2_1->cmd=SPEED;
  204c74:	2209      	movs	r2, #9
  menu2_1=menu2->child;
  204c76:	600f      	str	r7, [r1, #0]
  menu2_1->text="Set Speed";
  204c78:	4949      	ldr	r1, [pc, #292]	; (204da0 <main+0xba0>)
  menu2->y_pos=110;
  204c7a:	f8c6 c020 	str.w	ip, [r6, #32]
  menu2_1->starttext="Motor Speed";
  204c7e:	f8c7 b004 	str.w	fp, [r7, #4]
  menu2->cmd=0;
  204c82:	7235      	strb	r5, [r6, #8]
  menu2->bool_value=NULL;
  204c84:	6275      	str	r5, [r6, #36]	; 0x24
  menu2_1->child=NULL;
  204c86:	61bd      	str	r5, [r7, #24]
  menu2_1->prev=NULL;
  204c88:	60fd      	str	r5, [r7, #12]
  menu2_1->bool_value=NULL;
  204c8a:	627d      	str	r5, [r7, #36]	; 0x24
  menu2_1->cmd=SPEED;
  204c8c:	723a      	strb	r2, [r7, #8]
  menu2_1->text="Set Speed";
  204c8e:	6039      	str	r1, [r7, #0]
  menu2_1->parent=menu2;
  204c90:	e9c7 5604 	strd	r5, r6, [r7, #16]
  menu2_1->y_pos=70;
  204c94:	e9c7 3007 	strd	r3, r0, [r7, #28]
  menu3->child=malloc(sizeof(node_t));
  204c98:	202c      	movs	r0, #44	; 0x2c
  menu3_2=menu3_1->next;
  204c9a:	4f42      	ldr	r7, [pc, #264]	; (204da4 <main+0xba4>)
  menu3->child=malloc(sizeof(node_t));
  204c9c:	f000 fac0 	bl	205220 <malloc>
  menu3->x_pos=60;
  204ca0:	233c      	movs	r3, #60	; 0x3c
  menu3->menu_value=-1;
  204ca2:	f04f 32ff 	mov.w	r2, #4294967295
  menu3->y_pos=150;
  204ca6:	2196      	movs	r1, #150	; 0x96
  menu3->prev=menu2;
  204ca8:	f8c8 600c 	str.w	r6, [r8, #12]
  menu3->child=malloc(sizeof(node_t));
  204cac:	4683      	mov	fp, r0
  menu3->x_pos=60;
  204cae:	f8c8 301c 	str.w	r3, [r8, #28]
  menu3_1=menu3->child;
  204cb2:	4e3d      	ldr	r6, [pc, #244]	; (204da8 <main+0xba8>)
  menu3->text="PID";
  204cb4:	4b3d      	ldr	r3, [pc, #244]	; (204dac <main+0xbac>)
  menu3->parent=NULL;
  204cb6:	f8c8 5014 	str.w	r5, [r8, #20]
  menu3->starttext=NULL;
  204cba:	f8c8 5004 	str.w	r5, [r8, #4]
  menu3->next=NULL;
  204cbe:	f8c8 5010 	str.w	r5, [r8, #16]
  menu3->child=malloc(sizeof(node_t));
  204cc2:	f8c8 0018 	str.w	r0, [r8, #24]
  menu3->cmd=0;
  204cc6:	f888 5008 	strb.w	r5, [r8, #8]
  menu3->bool_value=NULL;
  204cca:	f8c8 5024 	str.w	r5, [r8, #36]	; 0x24
  menu3->menu_value=-1;
  204cce:	f8a8 2028 	strh.w	r2, [r8, #40]	; 0x28
  menu3->y_pos=150;
  204cd2:	f8c8 1020 	str.w	r1, [r8, #32]
  menu3->text="PID";
  204cd6:	f8c8 3000 	str.w	r3, [r8]
  menu3_1=menu3->child;
  204cda:	6030      	str	r0, [r6, #0]
  menu3_1->next=malloc(sizeof(node_t));
  204cdc:	202c      	movs	r0, #44	; 0x2c
  204cde:	f000 fa9f 	bl	205220 <malloc>
  204ce2:	4603      	mov	r3, r0
  204ce4:	f8cb 0010 	str.w	r0, [fp, #16]
  menu3_1->y_pos=70;
  204ce8:	2246      	movs	r2, #70	; 0x46
  menu3_1->menu_value=Reg1.P;
  204cea:	8820      	ldrh	r0, [r4, #0]
  menu3_1->x_pos=10;
  204cec:	210a      	movs	r1, #10
  menu3_1->y_pos=70;
  204cee:	f8cb 2020 	str.w	r2, [fp, #32]
  menu3_1->cmd=SPEED;
  204cf2:	2209      	movs	r2, #9
  menu3_1->menu_value=Reg1.P;
  204cf4:	f8ab 0028 	strh.w	r0, [fp, #40]	; 0x28
  menu3_1->starttext="Regulator coeff.";
  204cf8:	482d      	ldr	r0, [pc, #180]	; (204db0 <main+0xbb0>)
  menu3_1->parent=menu3;
  204cfa:	f8cb 8014 	str.w	r8, [fp, #20]
  menu3_1->starttext="Regulator coeff.";
  204cfe:	f8cb 0004 	str.w	r0, [fp, #4]
  menu3_1->text="P";
  204d02:	482c      	ldr	r0, [pc, #176]	; (204db4 <main+0xbb4>)
  menu3_1->child=NULL;
  204d04:	f8cb 5018 	str.w	r5, [fp, #24]
  menu3_1->prev=NULL;
  204d08:	f8cb 500c 	str.w	r5, [fp, #12]
  menu3_1->x_pos=10;
  204d0c:	f8cb 101c 	str.w	r1, [fp, #28]
  menu3_1->cmd=SPEED;
  204d10:	f88b 2008 	strb.w	r2, [fp, #8]
  menu3_1->bool_value=NULL;
  204d14:	f8cb 5024 	str.w	r5, [fp, #36]	; 0x24
  menu3_1->text="P";
  204d18:	f8cb 0000 	str.w	r0, [fp]
  menu3_2->next=malloc(sizeof(node_t));
  204d1c:	202c      	movs	r0, #44	; 0x2c
  menu3_2=menu3_1->next;
  204d1e:	603b      	str	r3, [r7, #0]
  204d20:	9303      	str	r3, [sp, #12]
  menu3_2->next=malloc(sizeof(node_t));
  204d22:	f000 fa7d 	bl	205220 <malloc>
  TFT_Fill_Screen(0,320,0,240,WHITE);
  204d26:	f64f 7eff 	movw	lr, #65535	; 0xffff
  menu3_2->prev=menu3_1;
  204d2a:	9b03      	ldr	r3, [sp, #12]
  menu3_2->cmd=SPEED;
  204d2c:	2209      	movs	r2, #9
  menu3_3->y_pos=150;
  204d2e:	2196      	movs	r1, #150	; 0x96
  TFT_Fill_Screen(0,320,0,240,WHITE);
  204d30:	f8cd e000 	str.w	lr, [sp]
  menu3_2->y_pos=110;
  204d34:	f04f 0c6e 	mov.w	ip, #110	; 0x6e
  menu3_2->cmd=SPEED;
  204d38:	721a      	strb	r2, [r3, #8]
  menu3_3->cmd=SPEED;
  204d3a:	7202      	strb	r2, [r0, #8]
  menu3_2->menu_value=Reg1.D;
  204d3c:	88a2      	ldrh	r2, [r4, #4]
  menu3_3->y_pos=150;
  204d3e:	6201      	str	r1, [r0, #32]
  menu3_2->x_pos=10;
  204d40:	210a      	movs	r1, #10
  menu3_2->menu_value=Reg1.D;
  204d42:	851a      	strh	r2, [r3, #40]	; 0x28
  menu3_3->menu_value=Reg1.I;
  204d44:	8862      	ldrh	r2, [r4, #2]
  menu3_2->y_pos=110;
  204d46:	f8c3 c020 	str.w	ip, [r3, #32]
  204d4a:	e035      	b.n	204db8 <main+0xbb8>
  204d4c:	00203411 	.word	0x00203411
  204d50:	40020c00 	.word	0x40020c00
  204d54:	000f4240 	.word	0x000f4240
  204d58:	20000820 	.word	0x20000820
  204d5c:	20000824 	.word	0x20000824
  204d60:	0001d4c0 	.word	0x0001d4c0
  204d64:	08005ae0 	.word	0x08005ae0
  204d68:	08005af0 	.word	0x08005af0
  204d6c:	08005ac0 	.word	0x08005ac0
  204d70:	20001154 	.word	0x20001154
  204d74:	08005afc 	.word	0x08005afc
  204d78:	08005b08 	.word	0x08005b08
  204d7c:	20001158 	.word	0x20001158
  204d80:	08005b18 	.word	0x08005b18
  204d84:	2000115c 	.word	0x2000115c
  204d88:	08005b24 	.word	0x08005b24
  204d8c:	20001160 	.word	0x20001160
  204d90:	08005b34 	.word	0x08005b34
  204d94:	08005b40 	.word	0x08005b40
  204d98:	20001164 	.word	0x20001164
  204d9c:	20020068 	.word	0x20020068
  204da0:	08005b4c 	.word	0x08005b4c
  204da4:	2000116c 	.word	0x2000116c
  204da8:	20001168 	.word	0x20001168
  204dac:	08005b58 	.word	0x08005b58
  204db0:	08005b5c 	.word	0x08005b5c
  204db4:	08005b70 	.word	0x08005b70
  menu3_3->menu_value=Reg1.I;
  204db8:	8502      	strh	r2, [r0, #40]	; 0x28
  menu3_2->text="D";
  204dba:	4ac6      	ldr	r2, [pc, #792]	; (2050d4 <main+0xed4>)
  menu3_2->prev=menu3_1;
  204dbc:	f8c3 b00c 	str.w	fp, [r3, #12]
  menu3_2->y_pos=110;
  204dc0:	46e3      	mov	fp, ip
  menu3_2->text="D";
  204dc2:	601a      	str	r2, [r3, #0]
  TFT_Fill_Screen(0,320,0,240,WHITE);
  204dc4:	462a      	mov	r2, r5
  menu3_2->child=NULL;
  204dc6:	619d      	str	r5, [r3, #24]
  menu3_2->x_pos=10;
  204dc8:	61d9      	str	r1, [r3, #28]
  menu3_2->bool_value=NULL;
  204dca:	625d      	str	r5, [r3, #36]	; 0x24
  menu3_3->parent=menu3;
  204dcc:	f8c0 8014 	str.w	r8, [r0, #20]
  menu3_3=menu3_2->next;
  204dd0:	f8df 8304 	ldr.w	r8, [pc, #772]	; 2050d8 <main+0xed8>
  menu3_3->bool_value=NULL;
  204dd4:	6245      	str	r5, [r0, #36]	; 0x24
  menu3_3=menu3_2->next;
  204dd6:	f8c8 0000 	str.w	r0, [r8]
  menu3_2->parent=menu1;
  204dda:	e9c3 0a04 	strd	r0, sl, [r3, #16]
  menu3_3->prev=menu3_2;
  204dde:	e9c0 3503 	strd	r3, r5, [r0, #12]
  menu3_3->text="I";
  204de2:	4bbe      	ldr	r3, [pc, #760]	; (2050dc <main+0xedc>)
  204de4:	6003      	str	r3, [r0, #0]
  current=menu1;
  204de6:	4bbe      	ldr	r3, [pc, #760]	; (2050e0 <main+0xee0>)
  menu3_3->x_pos=10;
  204de8:	e9c0 5106 	strd	r5, r1, [r0, #24]
  current=menu1;
  204dec:	f8c3 a000 	str.w	sl, [r3]
  TFT_Fill_Screen(0,320,0,240,WHITE);
  204df0:	f44f 71a0 	mov.w	r1, #320	; 0x140
  204df4:	23f0      	movs	r3, #240	; 0xf0
  204df6:	4628      	mov	r0, r5
  204df8:	f7fc fada 	bl	2013b0 <TFT_Fill_Screen>
  TFT_Draw_Horizontal_Line(0,201,320,BLACK);
  204dfc:	20c9      	movs	r0, #201	; 0xc9
  204dfe:	f7fc fe5f 	bl	201ac0 <TFT_Draw_Horizontal_Line.constprop.0>
  TFT_Draw_Horizontal_Line(0,202,320,BLACK);
  204e02:	20ca      	movs	r0, #202	; 0xca
  TFT_Draw_Triangle(20,220,40,210,40,230,BLACK);
  204e04:	f04f 0ae6 	mov.w	sl, #230	; 0xe6
  TFT_Draw_Horizontal_Line(0,202,320,BLACK);
  204e08:	f7fc fe5a 	bl	201ac0 <TFT_Draw_Horizontal_Line.constprop.0>
  TFT_Draw_Triangle(20,220,40,210,40,230,BLACK);
  204e0c:	2228      	movs	r2, #40	; 0x28
  204e0e:	23d2      	movs	r3, #210	; 0xd2
  204e10:	21dc      	movs	r1, #220	; 0xdc
  204e12:	2014      	movs	r0, #20
  204e14:	e9cd 2a00 	strd	r2, sl, [sp]
  204e18:	f7fc fe3a 	bl	201a90 <TFT_Draw_Triangle.constprop.0>
  TFT_Draw_String(42,220, BLACK, WHITE, "BACK", 1);
  204e1c:	462a      	mov	r2, r5
  204e1e:	4bb1      	ldr	r3, [pc, #708]	; (2050e4 <main+0xee4>)
  204e20:	21dc      	movs	r1, #220	; 0xdc
  204e22:	202a      	movs	r0, #42	; 0x2a
  204e24:	f8cd 9000 	str.w	r9, [sp]
  204e28:	f7fc fc82 	bl	201730 <TFT_Draw_String.constprop.0>
  TFT_Draw_Triangle(100,210,90,230,110,230,BLACK);
  204e2c:	4653      	mov	r3, sl
  204e2e:	f8cd b000 	str.w	fp, [sp]
  204e32:	225a      	movs	r2, #90	; 0x5a
  204e34:	f8cd a004 	str.w	sl, [sp, #4]
  204e38:	21d2      	movs	r1, #210	; 0xd2
  204e3a:	2064      	movs	r0, #100	; 0x64
  TFT_Draw_Triangle(230,210,230,230,250,220,BLACK);
  204e3c:	f04f 0bdc 	mov.w	fp, #220	; 0xdc
  TFT_Draw_Triangle(100,210,90,230,110,230,BLACK);
  204e40:	f7fc fe26 	bl	201a90 <TFT_Draw_Triangle.constprop.0>
  TFT_Draw_String(113,220, BLACK, WHITE, "PREV", 1);
  204e44:	462a      	mov	r2, r5
  204e46:	4ba8      	ldr	r3, [pc, #672]	; (2050e8 <main+0xee8>)
  204e48:	21dc      	movs	r1, #220	; 0xdc
  204e4a:	2071      	movs	r0, #113	; 0x71
  204e4c:	f8cd 9000 	str.w	r9, [sp]
  204e50:	f7fc fc6e 	bl	201730 <TFT_Draw_String.constprop.0>
  TFT_Draw_Triangle(160,210,180,210,170,230,BLACK);
  204e54:	f04f 0caa 	mov.w	ip, #170	; 0xaa
  204e58:	23d2      	movs	r3, #210	; 0xd2
  204e5a:	22b4      	movs	r2, #180	; 0xb4
  204e5c:	20a0      	movs	r0, #160	; 0xa0
  204e5e:	4619      	mov	r1, r3
  204e60:	e9cd ca00 	strd	ip, sl, [sp]
  204e64:	f7fc fe14 	bl	201a90 <TFT_Draw_Triangle.constprop.0>
  TFT_Draw_String(183,220, BLACK, WHITE, "NEXT", 1);
  204e68:	462a      	mov	r2, r5
  204e6a:	4ba0      	ldr	r3, [pc, #640]	; (2050ec <main+0xeec>)
  204e6c:	21dc      	movs	r1, #220	; 0xdc
  204e6e:	20b7      	movs	r0, #183	; 0xb7
  204e70:	f8cd 9000 	str.w	r9, [sp]
  204e74:	f7fc fc5c 	bl	201730 <TFT_Draw_String.constprop.0>
  TFT_Draw_Triangle(230,210,230,230,250,220,BLACK);
  204e78:	23fa      	movs	r3, #250	; 0xfa
  204e7a:	4652      	mov	r2, sl
  204e7c:	4650      	mov	r0, sl
  204e7e:	21d2      	movs	r1, #210	; 0xd2
  204e80:	e9cd 3b00 	strd	r3, fp, [sp]
  204e84:	4653      	mov	r3, sl
  204e86:	f04f 0a20 	mov.w	sl, #32
  204e8a:	f7fc fe01 	bl	201a90 <TFT_Draw_Triangle.constprop.0>
  TFT_Draw_String(253,220, BLACK, WHITE, "FARTHER", 1);
  204e8e:	4659      	mov	r1, fp
  204e90:	4b97      	ldr	r3, [pc, #604]	; (2050f0 <main+0xef0>)
  204e92:	462a      	mov	r2, r5
  204e94:	20fd      	movs	r0, #253	; 0xfd
  204e96:	f8cd 9000 	str.w	r9, [sp]
  204e9a:	f7fc fc49 	bl	201730 <TFT_Draw_String.constprop.0>
  Menu_Disp();
  204e9e:	f7fc ff9f 	bl	201de0 <Menu_Disp>
  Cursor();
  204ea2:	f7fc fc6d 	bl	201780 <Cursor>
  204ea6:	f38a 8811 	msr	BASEPRI, sl
  gptp->config = config;
  204eaa:	4992      	ldr	r1, [pc, #584]	; (2050f4 <main+0xef4>)
  204eac:	4b92      	ldr	r3, [pc, #584]	; (2050f8 <main+0xef8>)
  gpt_lld_start(gptp);
  204eae:	4608      	mov	r0, r1
  gptp->config = config;
  204eb0:	468b      	mov	fp, r1
  204eb2:	604b      	str	r3, [r1, #4]
  gpt_lld_start(gptp);
  204eb4:	f7fb fb54 	bl	200560 <gpt_lld_start>
  gptp->state = GPT_READY;
  204eb8:	f04f 0202 	mov.w	r2, #2
  204ebc:	f88b 2000 	strb.w	r2, [fp]
  204ec0:	f385 8811 	msr	BASEPRI, r5
  uint8_t arg = 5;
  204ec4:	f04f 0305 	mov.w	r3, #5
  palSetPadMode(UP_GPIO_Port, UP_Pin, PAL_MODE_INPUT_PULLDOWN);
  204ec8:	2240      	movs	r2, #64	; 0x40
  204eca:	f44f 6180 	mov.w	r1, #1024	; 0x400
  204ece:	488b      	ldr	r0, [pc, #556]	; (2050fc <main+0xefc>)
  uint8_t arg = 5;
  204ed0:	f88d 3010 	strb.w	r3, [sp, #16]
  palSetPadMode(UP_GPIO_Port, UP_Pin, PAL_MODE_INPUT_PULLDOWN);
  204ed4:	f7fb fa9c 	bl	200410 <_pal_lld_setgroupmode>
  204ed8:	f38a 8811 	msr	BASEPRI, sl
  palEnablePadEvent(UP_GPIO_Port, UP_Pin, PAL_EVENT_MODE_RISING_EDGE);
  204edc:	210a      	movs	r1, #10
  204ede:	464a      	mov	r2, r9
  204ee0:	f7fb fb06 	bl	2004f0 <_pal_lld_enablepadevent>
  204ee4:	f385 8811 	msr	BASEPRI, r5
  204ee8:	f38a 8811 	msr	BASEPRI, sl
  pep->arg = arg;
  204eec:	f8df b210 	ldr.w	fp, [pc, #528]	; 205100 <main+0xf00>
  204ef0:	ab04      	add	r3, sp, #16
  204ef2:	f8cb 3054 	str.w	r3, [fp, #84]	; 0x54
  pep->cb = cb;
  204ef6:	4b83      	ldr	r3, [pc, #524]	; (205104 <main+0xf04>)
  204ef8:	f8cb 3050 	str.w	r3, [fp, #80]	; 0x50
  204efc:	f385 8811 	msr	BASEPRI, r5
  palSetPadMode(DOWN_GPIO_Port, DOWN_Pin, PAL_MODE_INPUT_PULLDOWN);
  204f00:	2108      	movs	r1, #8
  204f02:	2240      	movs	r2, #64	; 0x40
  204f04:	487d      	ldr	r0, [pc, #500]	; (2050fc <main+0xefc>)
  204f06:	f7fb fa83 	bl	200410 <_pal_lld_setgroupmode>
  204f0a:	f38a 8811 	msr	BASEPRI, sl
  palEnablePadEvent(DOWN_GPIO_Port, DOWN_Pin, PAL_EVENT_MODE_RISING_EDGE);
  204f0e:	2103      	movs	r1, #3
  204f10:	464a      	mov	r2, r9
  204f12:	f7fb faed 	bl	2004f0 <_pal_lld_enablepadevent>
  204f16:	f385 8811 	msr	BASEPRI, r5
  204f1a:	f38a 8811 	msr	BASEPRI, sl
  pep->arg = arg;
  204f1e:	ab04      	add	r3, sp, #16
  204f20:	f8cb 301c 	str.w	r3, [fp, #28]
  pep->cb = cb;
  204f24:	4b78      	ldr	r3, [pc, #480]	; (205108 <main+0xf08>)
  204f26:	f8cb 3018 	str.w	r3, [fp, #24]
  204f2a:	f385 8811 	msr	BASEPRI, r5
  palSetPadMode(LEFT_GPIO_Port, LEFT_Pin, PAL_MODE_INPUT_PULLDOWN);
  204f2e:	2240      	movs	r2, #64	; 0x40
  204f30:	4649      	mov	r1, r9
  204f32:	4876      	ldr	r0, [pc, #472]	; (20510c <main+0xf0c>)
  204f34:	f7fb fa6c 	bl	200410 <_pal_lld_setgroupmode>
  204f38:	f38a 8811 	msr	BASEPRI, sl
  palEnablePadEvent(LEFT_GPIO_Port, LEFT_Pin, PAL_EVENT_MODE_RISING_EDGE);
  204f3c:	464a      	mov	r2, r9
  204f3e:	4629      	mov	r1, r5
  204f40:	f7fb fad6 	bl	2004f0 <_pal_lld_enablepadevent>
  204f44:	f385 8811 	msr	BASEPRI, r5
  204f48:	f38a 8811 	msr	BASEPRI, sl
  pep->arg = arg;
  204f4c:	ab04      	add	r3, sp, #16
  204f4e:	f8cb 3004 	str.w	r3, [fp, #4]
  pep->cb = cb;
  204f52:	4b6f      	ldr	r3, [pc, #444]	; (205110 <main+0xf10>)
  204f54:	f8cb 3000 	str.w	r3, [fp]
  204f58:	f385 8811 	msr	BASEPRI, r5
  palSetPadMode(RIGHT_GPIO_Port, RIGHT_Pin, PAL_MODE_INPUT_PULLDOWN);
  204f5c:	4867      	ldr	r0, [pc, #412]	; (2050fc <main+0xefc>)
  204f5e:	2240      	movs	r2, #64	; 0x40
  204f60:	4651      	mov	r1, sl
  204f62:	f7fb fa55 	bl	200410 <_pal_lld_setgroupmode>
  204f66:	f38a 8811 	msr	BASEPRI, sl
  palEnablePadEvent(RIGHT_GPIO_Port, RIGHT_Pin, PAL_EVENT_MODE_RISING_EDGE);
  204f6a:	2105      	movs	r1, #5
  204f6c:	464a      	mov	r2, r9
  204f6e:	f7fb fabf 	bl	2004f0 <_pal_lld_enablepadevent>
  204f72:	f385 8811 	msr	BASEPRI, r5
  204f76:	f38a 8811 	msr	BASEPRI, sl
  pep->arg = arg;
  204f7a:	ab04      	add	r3, sp, #16
  204f7c:	f8cb 302c 	str.w	r3, [fp, #44]	; 0x2c
  pep->cb = cb;
  204f80:	4b64      	ldr	r3, [pc, #400]	; (205114 <main+0xf14>)
  204f82:	f8cb 3028 	str.w	r3, [fp, #40]	; 0x28
  204f86:	f385 8811 	msr	BASEPRI, r5
  mbp->buffer = buf;
  204f8a:	4a63      	ldr	r2, [pc, #396]	; (205118 <main+0xf18>)
  204f8c:	4963      	ldr	r1, [pc, #396]	; (20511c <main+0xf1c>)
  204f8e:	4b64      	ldr	r3, [pc, #400]	; (205120 <main+0xf20>)
  204f90:	6011      	str	r1, [r2, #0]
  mbp->cnt    = (size_t)0;
  204f92:	6115      	str	r5, [r2, #16]
  mbp->reset  = false;
  204f94:	7515      	strb	r5, [r2, #20]
  mbp->cnt    = (size_t)0;
  204f96:	611d      	str	r5, [r3, #16]
  mbp->reset  = false;
  204f98:	751d      	strb	r5, [r3, #20]
  TFT_Init();
  Menu_Create();
  Menu_GPIO_Init();
  chMBObjectInit(&menu_mb, menu_mb_buffer, BUFFER_SIZE);
  chMBObjectInit(&cmd_mb, cmd_mb_buffer, BUFFER_SIZE);
  chThdCreateStatic(menuThread, sizeof(menuThread), NORMALPRIO-1, menu, NULL);
  204f9a:	4862      	ldr	r0, [pc, #392]	; (205124 <main+0xf24>)
  mbp->wrptr  = buf;
  204f9c:	e9c2 1102 	strd	r1, r1, [r2, #8]
  mbp->top    = &buf[n];
  204fa0:	f501 71c8 	add.w	r1, r1, #400	; 0x190
  204fa4:	6051      	str	r1, [r2, #4]
  mbp->buffer = buf;
  204fa6:	4960      	ldr	r1, [pc, #384]	; (205128 <main+0xf28>)
  204fa8:	6019      	str	r1, [r3, #0]
  mbp->wrptr  = buf;
  204faa:	e9c3 1102 	strd	r1, r1, [r3, #8]
  mbp->top    = &buf[n];
  204fae:	f501 71c8 	add.w	r1, r1, #400	; 0x190
  204fb2:	6059      	str	r1, [r3, #4]
  qp->next = qp;
  204fb4:	f102 0118 	add.w	r1, r2, #24
  qp->prev = qp;
  204fb8:	e9c2 1106 	strd	r1, r1, [r2, #24]
  qp->next = qp;
  204fbc:	eb02 010a 	add.w	r1, r2, sl
  qp->prev = qp;
  204fc0:	e9c2 1108 	strd	r1, r1, [r2, #32]
  qp->next = qp;
  204fc4:	f103 0218 	add.w	r2, r3, #24
  204fc8:	f44f 6199 	mov.w	r1, #1224	; 0x4c8
  qp->prev = qp;
  204fcc:	e9c3 2206 	strd	r2, r2, [r3, #24]
  qp->next = qp;
  204fd0:	eb03 020a 	add.w	r2, r3, sl
  qp->prev = qp;
  204fd4:	e9c3 2208 	strd	r2, r2, [r3, #32]
  204fd8:	4b54      	ldr	r3, [pc, #336]	; (20512c <main+0xf2c>)
  204fda:	227f      	movs	r2, #127	; 0x7f
  204fdc:	f7fc fec8 	bl	201d70 <chThdCreateStatic.constprop.0.isra.0>
  chThdCreateStatic(cmdThread, sizeof(cmdThread), NORMALPRIO-1, cmd, NULL);
  204fe0:	4b53      	ldr	r3, [pc, #332]	; (205130 <main+0xf30>)
  204fe2:	227f      	movs	r2, #127	; 0x7f
  204fe4:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
  204fe8:	4852      	ldr	r0, [pc, #328]	; (205134 <main+0xf34>)
  204fea:	f7fc fec1 	bl	201d70 <chThdCreateStatic.constprop.0.isra.0>
  chThdCreateStatic(speed_menuThread, sizeof(speed_menuThread), NORMALPRIO-2, speed_menu, NULL);
  204fee:	4b52      	ldr	r3, [pc, #328]	; (205138 <main+0xf38>)
  204ff0:	227e      	movs	r2, #126	; 0x7e
  204ff2:	f44f 7132 	mov.w	r1, #712	; 0x2c8
  204ff6:	4851      	ldr	r0, [pc, #324]	; (20513c <main+0xf3c>)
  204ff8:	f7fc feba 	bl	201d70 <chThdCreateStatic.constprop.0.isra.0>
  qp->next = qp;
  204ffc:	4b50      	ldr	r3, [pc, #320]	; (205140 <main+0xf40>)
  qp->prev = qp;
  204ffe:	e9c3 3300 	strd	r3, r3, [r3]
  205002:	609d      	str	r5, [r3, #8]
  205004:	f38a 8811 	msr	BASEPRI, sl
  205008:	494e      	ldr	r1, [pc, #312]	; (205144 <main+0xf44>)
  20500a:	684b      	ldr	r3, [r1, #4]
  20500c:	4608      	mov	r0, r1
  if (NULL != gptp->config->callback)
  20500e:	685a      	ldr	r2, [r3, #4]
  205010:	68cb      	ldr	r3, [r1, #12]
  gptp->state = GPT_CONTINUOUS;
  205012:	2103      	movs	r1, #3
  205014:	7001      	strb	r1, [r0, #0]
  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
  205016:	f241 3187 	movw	r1, #4999	; 0x1387
  20501a:	62d9      	str	r1, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
  20501c:	f8c3 9014 	str.w	r9, [r3, #20]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
  205020:	625d      	str	r5, [r3, #36]	; 0x24
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  205022:	611d      	str	r5, [r3, #16]
  if (NULL != gptp->config->callback)
  205024:	b11a      	cbz	r2, 20502e <main+0xe2e>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
  205026:	68da      	ldr	r2, [r3, #12]
  205028:	ea42 0209 	orr.w	r2, r2, r9
  20502c:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
  20502e:	2285      	movs	r2, #133	; 0x85
  205030:	601a      	str	r2, [r3, #0]
  205032:	2300      	movs	r3, #0
  205034:	f383 8811 	msr	BASEPRI, r3
  205038:	4d43      	ldr	r5, [pc, #268]	; (205148 <main+0xf48>)
          palToggleLine(LINE_LED2);
  20503a:	f8df a110 	ldr.w	sl, [pc, #272]	; 20514c <main+0xf4c>
  IN1_LO;
  20503e:	f8df b110 	ldr.w	fp, [pc, #272]	; 205150 <main+0xf50>
      sdReadTimeout(uart3,buff,11,chTimeMS2I(100));
  205042:	f8df 9110 	ldr.w	r9, [pc, #272]	; 205154 <main+0xf54>
  205046:	464b      	mov	r3, r9
  205048:	220b      	movs	r2, #11
  20504a:	493f      	ldr	r1, [pc, #252]	; (205148 <main+0xf48>)
  20504c:	4842      	ldr	r0, [pc, #264]	; (205158 <main+0xf58>)
  20504e:	f7fb ffb7 	bl	200fc0 <iqReadTimeout>
        if(start==1)
  205052:	782b      	ldrb	r3, [r5, #0]
  205054:	2b01      	cmp	r3, #1
  205056:	d014      	beq.n	205082 <main+0xe82>
  205058:	2320      	movs	r3, #32
  20505a:	f383 8811 	msr	BASEPRI, r3
  rdymsg = chMBFetchTimeoutS(mbp, msgp, timeout);
  20505e:	4a3f      	ldr	r2, [pc, #252]	; (20515c <main+0xf5c>)
  205060:	a904      	add	r1, sp, #16
  205062:	483f      	ldr	r0, [pc, #252]	; (205160 <main+0xf60>)
  205064:	f7fe f97c 	bl	203360 <chMBFetchTimeoutS>
  205068:	2300      	movs	r3, #0
  20506a:	f383 8811 	msr	BASEPRI, r3
      if (msg == MSG_OK)
  20506e:	2800      	cmp	r0, #0
  205070:	d1e9      	bne.n	205046 <main+0xe46>
        sdWrite(uart3, (uint8_t *)&my_msg,2);
  205072:	f04f 33ff 	mov.w	r3, #4294967295
  205076:	2202      	movs	r2, #2
  205078:	a904      	add	r1, sp, #16
  20507a:	483a      	ldr	r0, [pc, #232]	; (205164 <main+0xf64>)
  20507c:	f7fc f8c8 	bl	201210 <oqWriteTimeout>
  205080:	e7df      	b.n	205042 <main+0xe42>
          palToggleLine(LINE_LED2);
  205082:	f8da 2014 	ldr.w	r2, [sl, #20]
  205086:	f082 0280 	eor.w	r2, r2, #128	; 0x80
  20508a:	f8ca 2014 	str.w	r2, [sl, #20]
          if(((buff[1]<<8)+buff[2])==WRITECMD)
  20508e:	7869      	ldrb	r1, [r5, #1]
  205090:	78aa      	ldrb	r2, [r5, #2]
  205092:	eb02 2201 	add.w	r2, r2, r1, lsl #8
  205096:	2a04      	cmp	r2, #4
  205098:	d066      	beq.n	205168 <main+0xf68>
          if(((buff[1]<<8)+buff[2])==WRITEPID)
  20509a:	2a07      	cmp	r2, #7
  20509c:	d1dc      	bne.n	205058 <main+0xe58>
            menu3_1->menu_value=(buff[3]<<8)+buff[4];
  20509e:	78e8      	ldrb	r0, [r5, #3]
  2050a0:	792b      	ldrb	r3, [r5, #4]
            menu3_2->menu_value=(buff[5]<<8)+buff[6];
  2050a2:	796a      	ldrb	r2, [r5, #5]
            menu3_1->menu_value=(buff[3]<<8)+buff[4];
  2050a4:	eb03 2300 	add.w	r3, r3, r0, lsl #8
            menu3_2->menu_value=(buff[5]<<8)+buff[6];
  2050a8:	79a9      	ldrb	r1, [r5, #6]
            menu3_1->menu_value=(buff[3]<<8)+buff[4];
  2050aa:	6830      	ldr	r0, [r6, #0]
  2050ac:	b21b      	sxth	r3, r3
            menu3_2->menu_value=(buff[5]<<8)+buff[6];
  2050ae:	eb01 2102 	add.w	r1, r1, r2, lsl #8
  2050b2:	683a      	ldr	r2, [r7, #0]
            menu3_1->menu_value=(buff[3]<<8)+buff[4];
  2050b4:	8503      	strh	r3, [r0, #40]	; 0x28
            Reg1.P=menu3_1->menu_value;
  2050b6:	8023      	strh	r3, [r4, #0]
            menu3_2->menu_value=(buff[5]<<8)+buff[6];
  2050b8:	b209      	sxth	r1, r1
            menu3_3->menu_value=(buff[7]<<8)+buff[8];
  2050ba:	79e8      	ldrb	r0, [r5, #7]
  2050bc:	7a2b      	ldrb	r3, [r5, #8]
            menu3_2->menu_value=(buff[5]<<8)+buff[6];
  2050be:	8511      	strh	r1, [r2, #40]	; 0x28
            menu3_3->menu_value=(buff[7]<<8)+buff[8];
  2050c0:	eb03 2300 	add.w	r3, r3, r0, lsl #8
  2050c4:	f8d8 2000 	ldr.w	r2, [r8]
            Reg1.D= menu3_2->menu_value;
  2050c8:	80a1      	strh	r1, [r4, #4]
            menu3_3->menu_value=(buff[7]<<8)+buff[8];
  2050ca:	b21b      	sxth	r3, r3
  2050cc:	8513      	strh	r3, [r2, #40]	; 0x28
            Reg1.I=menu3_3->menu_value;
  2050ce:	8063      	strh	r3, [r4, #2]
  2050d0:	e7c2      	b.n	205058 <main+0xe58>
  2050d2:	bf00      	nop
  2050d4:	08005b74 	.word	0x08005b74
  2050d8:	20001170 	.word	0x20001170
  2050dc:	08005b78 	.word	0x08005b78
  2050e0:	20000ef0 	.word	0x20000ef0
  2050e4:	08005b7c 	.word	0x08005b7c
  2050e8:	08005b84 	.word	0x08005b84
  2050ec:	08005b8c 	.word	0x08005b8c
  2050f0:	08005b94 	.word	0x08005b94
  2050f4:	20000810 	.word	0x20000810
  2050f8:	20020010 	.word	0x20020010
  2050fc:	40021400 	.word	0x40021400
  205100:	200008e8 	.word	0x200008e8
  205104:	00200ac1 	.word	0x00200ac1
  205108:	00200b61 	.word	0x00200b61
  20510c:	40020800 	.word	0x40020800
  205110:	00200c01 	.word	0x00200c01
  205114:	00200ca1 	.word	0x00200ca1
  205118:	20001640 	.word	0x20001640
  20511c:	20001668 	.word	0x20001668
  205120:	20000d38 	.word	0x20000d38
  205124:	20001178 	.word	0x20001178
  205128:	20000d60 	.word	0x20000d60
  20512c:	00203581 	.word	0x00203581
  205130:	00203951 	.word	0x00203951
  205134:	20000b70 	.word	0x20000b70
  205138:	00204041 	.word	0x00204041
  20513c:	20001bb0 	.word	0x20001bb0
  205140:	200017f8 	.word	0x200017f8
  205144:	20000800 	.word	0x20000800
  205148:	2000096c 	.word	0x2000096c
  20514c:	40020400 	.word	0x40020400
  205150:	40021000 	.word	0x40021000
  205154:	000186a0 	.word	0x000186a0
  205158:	20000864 	.word	0x20000864
  20515c:	00030d40 	.word	0x00030d40
  205160:	20001e78 	.word	0x20001e78
  205164:	20000888 	.word	0x20000888
            palToggleLine(LINE_LED3);
  205168:	f8da 1014 	ldr.w	r1, [sl, #20]
            if(((buff[9]<<9)+buff[10])==GO)
  20516c:	7a68      	ldrb	r0, [r5, #9]
            palToggleLine(LINE_LED3);
  20516e:	f481 4180 	eor.w	r1, r1, #16384	; 0x4000
  205172:	f8ca 1014 	str.w	r1, [sl, #20]
            if(((buff[9]<<9)+buff[10])==GO)
  205176:	7aaa      	ldrb	r2, [r5, #10]
  205178:	eb02 2240 	add.w	r2, r2, r0, lsl #9
  20517c:	2a05      	cmp	r2, #5
  20517e:	d00f      	beq.n	2051a0 <main+0xfa0>
            if(((buff[9]<<9)+buff[10])==STOP)
  205180:	2a06      	cmp	r2, #6
  205182:	f47f af69 	bne.w	205058 <main+0xe58>
              Reg1.Summ_Error=0;
  205186:	2300      	movs	r3, #0
  205188:	f44f 7200 	mov.w	r2, #512	; 0x200
  20518c:	60a3      	str	r3, [r4, #8]
  20518e:	f8ab 201a 	strh.w	r2, [fp, #26]
  IN2_LO;
  205192:	4a1e      	ldr	r2, [pc, #120]	; (20520c <main+0x100c>)
  205194:	f44f 5100 	mov.w	r1, #8192	; 0x2000
  205198:	8351      	strh	r1, [r2, #26]
  flag_start=0;
  20519a:	4a1d      	ldr	r2, [pc, #116]	; (205210 <main+0x1010>)
  20519c:	7013      	strb	r3, [r2, #0]
}
  20519e:	e75b      	b.n	205058 <main+0xe58>
              Reg1.Summ_Error=0;
  2051a0:	2200      	movs	r2, #0
  2051a2:	60a2      	str	r2, [r4, #8]
  IN1_HI;
  2051a4:	f44f 7200 	mov.w	r2, #512	; 0x200
  2051a8:	f8ab 2018 	strh.w	r2, [fp, #24]
  IN2_LO;
  2051ac:	e7f1      	b.n	205192 <main+0xf92>
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
  2051ae:	6595      	str	r5, [r2, #88]	; 0x58
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
  2051b0:	65d5      	str	r5, [r2, #92]	; 0x5c
  2051b2:	f7ff bb24 	b.w	2047fe <main+0x5fe>
      rccEnableTIM1(true);
  2051b6:	4a17      	ldr	r2, [pc, #92]	; (205214 <main+0x1014>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
  2051b8:	f646 0568 	movw	r5, #26728	; 0x6868
      pwmp->clock = STM32_TIMCLK2;
  2051bc:	4c16      	ldr	r4, [pc, #88]	; (205218 <main+0x1018>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
  2051be:	69b0      	ldr	r0, [r6, #24]
      pwmp->clock = STM32_TIMCLK2;
  2051c0:	6174      	str	r4, [r6, #20]
      rccEnableTIM1(true);
  2051c2:	6c54      	ldr	r4, [r2, #68]	; 0x44
  2051c4:	f044 0401 	orr.w	r4, r4, #1
  2051c8:	6454      	str	r4, [r2, #68]	; 0x44
  2051ca:	6e54      	ldr	r4, [r2, #100]	; 0x64
  2051cc:	f044 0401 	orr.w	r4, r4, #1
  2051d0:	6654      	str	r4, [r2, #100]	; 0x64
  2051d2:	6e54      	ldr	r4, [r2, #100]	; 0x64
      rccResetTIM1();
  2051d4:	6a54      	ldr	r4, [r2, #36]	; 0x24
  2051d6:	f044 0401 	orr.w	r4, r4, #1
  2051da:	6254      	str	r4, [r2, #36]	; 0x24
  2051dc:	6a54      	ldr	r4, [r2, #36]	; 0x24
  2051de:	f024 0401 	bic.w	r4, r4, #1
  2051e2:	6254      	str	r4, [r2, #36]	; 0x24
  2051e4:	6a52      	ldr	r2, [r2, #36]	; 0x24
    pwmp->tim->CCMR3 = STM32_TIM_CCMR3_OC5M(6) | STM32_TIM_CCMR3_OC5PE |
  2051e6:	4a0d      	ldr	r2, [pc, #52]	; (20521c <main+0x101c>)
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
  2051e8:	6185      	str	r5, [r0, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
  2051ea:	61c5      	str	r5, [r0, #28]
    pwmp->tim->CCMR3 = STM32_TIM_CCMR3_OC5M(6) | STM32_TIM_CCMR3_OC5PE |
  2051ec:	6542      	str	r2, [r0, #84]	; 0x54
  2051ee:	f7ff bb08 	b.w	204802 <main+0x602>
      rccEnableUSART3(true);
  2051f2:	4b08      	ldr	r3, [pc, #32]	; (205214 <main+0x1014>)
  2051f4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
  2051f6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
  2051fa:	641a      	str	r2, [r3, #64]	; 0x40
  2051fc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
  2051fe:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
  205202:	661a      	str	r2, [r3, #96]	; 0x60
  205204:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  205206:	f7ff ba6b 	b.w	2046e0 <main+0x4e0>
  20520a:	bf00      	nop
  20520c:	40021400 	.word	0x40021400
  205210:	20000f95 	.word	0x20000f95
  205214:	40023800 	.word	0x40023800
  205218:	0cdfe600 	.word	0x0cdfe600
  20521c:	01016868 	.word	0x01016868

00205220 <malloc>:
  205220:	4b02      	ldr	r3, [pc, #8]	; (20522c <malloc+0xc>)
  205222:	4601      	mov	r1, r0
  205224:	6818      	ldr	r0, [r3, #0]
  205226:	f000 b863 	b.w	2052f0 <_malloc_r>
  20522a:	bf00      	nop
  20522c:	2002006c 	.word	0x2002006c

00205230 <memcpy>:
  205230:	440a      	add	r2, r1
  205232:	4291      	cmp	r1, r2
  205234:	f100 33ff 	add.w	r3, r0, #4294967295
  205238:	d100      	bne.n	20523c <memcpy+0xc>
  20523a:	4770      	bx	lr
  20523c:	b510      	push	{r4, lr}
  20523e:	f811 4b01 	ldrb.w	r4, [r1], #1
  205242:	f803 4f01 	strb.w	r4, [r3, #1]!
  205246:	4291      	cmp	r1, r2
  205248:	d1f9      	bne.n	20523e <memcpy+0xe>
  20524a:	bd10      	pop	{r4, pc}

0020524c <memset>:
  20524c:	4402      	add	r2, r0
  20524e:	4603      	mov	r3, r0
  205250:	4293      	cmp	r3, r2
  205252:	d100      	bne.n	205256 <memset+0xa>
  205254:	4770      	bx	lr
  205256:	f803 1b01 	strb.w	r1, [r3], #1
  20525a:	e7f9      	b.n	205250 <memset+0x4>

0020525c <_free_r>:
  20525c:	b538      	push	{r3, r4, r5, lr}
  20525e:	4605      	mov	r5, r0
  205260:	2900      	cmp	r1, #0
  205262:	d041      	beq.n	2052e8 <_free_r+0x8c>
  205264:	f851 3c04 	ldr.w	r3, [r1, #-4]
  205268:	1f0c      	subs	r4, r1, #4
  20526a:	2b00      	cmp	r3, #0
  20526c:	bfb8      	it	lt
  20526e:	18e4      	addlt	r4, r4, r3
  205270:	f000 f8c8 	bl	205404 <__malloc_lock>
  205274:	4a1d      	ldr	r2, [pc, #116]	; (2052ec <_free_r+0x90>)
  205276:	6813      	ldr	r3, [r2, #0]
  205278:	b933      	cbnz	r3, 205288 <_free_r+0x2c>
  20527a:	6063      	str	r3, [r4, #4]
  20527c:	6014      	str	r4, [r2, #0]
  20527e:	4628      	mov	r0, r5
  205280:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  205284:	f000 b8c4 	b.w	205410 <__malloc_unlock>
  205288:	42a3      	cmp	r3, r4
  20528a:	d908      	bls.n	20529e <_free_r+0x42>
  20528c:	6820      	ldr	r0, [r4, #0]
  20528e:	1821      	adds	r1, r4, r0
  205290:	428b      	cmp	r3, r1
  205292:	bf01      	itttt	eq
  205294:	6819      	ldreq	r1, [r3, #0]
  205296:	685b      	ldreq	r3, [r3, #4]
  205298:	1809      	addeq	r1, r1, r0
  20529a:	6021      	streq	r1, [r4, #0]
  20529c:	e7ed      	b.n	20527a <_free_r+0x1e>
  20529e:	461a      	mov	r2, r3
  2052a0:	685b      	ldr	r3, [r3, #4]
  2052a2:	b10b      	cbz	r3, 2052a8 <_free_r+0x4c>
  2052a4:	42a3      	cmp	r3, r4
  2052a6:	d9fa      	bls.n	20529e <_free_r+0x42>
  2052a8:	6811      	ldr	r1, [r2, #0]
  2052aa:	1850      	adds	r0, r2, r1
  2052ac:	42a0      	cmp	r0, r4
  2052ae:	d10b      	bne.n	2052c8 <_free_r+0x6c>
  2052b0:	6820      	ldr	r0, [r4, #0]
  2052b2:	4401      	add	r1, r0
  2052b4:	1850      	adds	r0, r2, r1
  2052b6:	4283      	cmp	r3, r0
  2052b8:	6011      	str	r1, [r2, #0]
  2052ba:	d1e0      	bne.n	20527e <_free_r+0x22>
  2052bc:	6818      	ldr	r0, [r3, #0]
  2052be:	685b      	ldr	r3, [r3, #4]
  2052c0:	6053      	str	r3, [r2, #4]
  2052c2:	4401      	add	r1, r0
  2052c4:	6011      	str	r1, [r2, #0]
  2052c6:	e7da      	b.n	20527e <_free_r+0x22>
  2052c8:	d902      	bls.n	2052d0 <_free_r+0x74>
  2052ca:	230c      	movs	r3, #12
  2052cc:	602b      	str	r3, [r5, #0]
  2052ce:	e7d6      	b.n	20527e <_free_r+0x22>
  2052d0:	6820      	ldr	r0, [r4, #0]
  2052d2:	1821      	adds	r1, r4, r0
  2052d4:	428b      	cmp	r3, r1
  2052d6:	bf04      	itt	eq
  2052d8:	6819      	ldreq	r1, [r3, #0]
  2052da:	685b      	ldreq	r3, [r3, #4]
  2052dc:	6063      	str	r3, [r4, #4]
  2052de:	bf04      	itt	eq
  2052e0:	1809      	addeq	r1, r1, r0
  2052e2:	6021      	streq	r1, [r4, #0]
  2052e4:	6054      	str	r4, [r2, #4]
  2052e6:	e7ca      	b.n	20527e <_free_r+0x22>
  2052e8:	bd38      	pop	{r3, r4, r5, pc}
  2052ea:	bf00      	nop
  2052ec:	20002034 	.word	0x20002034

002052f0 <_malloc_r>:
  2052f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  2052f2:	1ccd      	adds	r5, r1, #3
  2052f4:	f025 0503 	bic.w	r5, r5, #3
  2052f8:	3508      	adds	r5, #8
  2052fa:	2d0c      	cmp	r5, #12
  2052fc:	bf38      	it	cc
  2052fe:	250c      	movcc	r5, #12
  205300:	2d00      	cmp	r5, #0
  205302:	4606      	mov	r6, r0
  205304:	db01      	blt.n	20530a <_malloc_r+0x1a>
  205306:	42a9      	cmp	r1, r5
  205308:	d903      	bls.n	205312 <_malloc_r+0x22>
  20530a:	230c      	movs	r3, #12
  20530c:	6033      	str	r3, [r6, #0]
  20530e:	2000      	movs	r0, #0
  205310:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  205312:	f000 f877 	bl	205404 <__malloc_lock>
  205316:	4921      	ldr	r1, [pc, #132]	; (20539c <_malloc_r+0xac>)
  205318:	680a      	ldr	r2, [r1, #0]
  20531a:	4614      	mov	r4, r2
  20531c:	b99c      	cbnz	r4, 205346 <_malloc_r+0x56>
  20531e:	4f20      	ldr	r7, [pc, #128]	; (2053a0 <_malloc_r+0xb0>)
  205320:	683b      	ldr	r3, [r7, #0]
  205322:	b923      	cbnz	r3, 20532e <_malloc_r+0x3e>
  205324:	4621      	mov	r1, r4
  205326:	4630      	mov	r0, r6
  205328:	f000 f83c 	bl	2053a4 <_sbrk_r>
  20532c:	6038      	str	r0, [r7, #0]
  20532e:	4629      	mov	r1, r5
  205330:	4630      	mov	r0, r6
  205332:	f000 f837 	bl	2053a4 <_sbrk_r>
  205336:	1c43      	adds	r3, r0, #1
  205338:	d123      	bne.n	205382 <_malloc_r+0x92>
  20533a:	230c      	movs	r3, #12
  20533c:	6033      	str	r3, [r6, #0]
  20533e:	4630      	mov	r0, r6
  205340:	f000 f866 	bl	205410 <__malloc_unlock>
  205344:	e7e3      	b.n	20530e <_malloc_r+0x1e>
  205346:	6823      	ldr	r3, [r4, #0]
  205348:	1b5b      	subs	r3, r3, r5
  20534a:	d417      	bmi.n	20537c <_malloc_r+0x8c>
  20534c:	2b0b      	cmp	r3, #11
  20534e:	d903      	bls.n	205358 <_malloc_r+0x68>
  205350:	6023      	str	r3, [r4, #0]
  205352:	441c      	add	r4, r3
  205354:	6025      	str	r5, [r4, #0]
  205356:	e004      	b.n	205362 <_malloc_r+0x72>
  205358:	6863      	ldr	r3, [r4, #4]
  20535a:	42a2      	cmp	r2, r4
  20535c:	bf0c      	ite	eq
  20535e:	600b      	streq	r3, [r1, #0]
  205360:	6053      	strne	r3, [r2, #4]
  205362:	4630      	mov	r0, r6
  205364:	f000 f854 	bl	205410 <__malloc_unlock>
  205368:	f104 000b 	add.w	r0, r4, #11
  20536c:	1d23      	adds	r3, r4, #4
  20536e:	f020 0007 	bic.w	r0, r0, #7
  205372:	1ac2      	subs	r2, r0, r3
  205374:	d0cc      	beq.n	205310 <_malloc_r+0x20>
  205376:	1a1b      	subs	r3, r3, r0
  205378:	50a3      	str	r3, [r4, r2]
  20537a:	e7c9      	b.n	205310 <_malloc_r+0x20>
  20537c:	4622      	mov	r2, r4
  20537e:	6864      	ldr	r4, [r4, #4]
  205380:	e7cc      	b.n	20531c <_malloc_r+0x2c>
  205382:	1cc4      	adds	r4, r0, #3
  205384:	f024 0403 	bic.w	r4, r4, #3
  205388:	42a0      	cmp	r0, r4
  20538a:	d0e3      	beq.n	205354 <_malloc_r+0x64>
  20538c:	1a21      	subs	r1, r4, r0
  20538e:	4630      	mov	r0, r6
  205390:	f000 f808 	bl	2053a4 <_sbrk_r>
  205394:	3001      	adds	r0, #1
  205396:	d1dd      	bne.n	205354 <_malloc_r+0x64>
  205398:	e7cf      	b.n	20533a <_malloc_r+0x4a>
  20539a:	bf00      	nop
  20539c:	20002034 	.word	0x20002034
  2053a0:	20002038 	.word	0x20002038

002053a4 <_sbrk_r>:
  2053a4:	b538      	push	{r3, r4, r5, lr}
  2053a6:	4d06      	ldr	r5, [pc, #24]	; (2053c0 <_sbrk_r+0x1c>)
  2053a8:	2300      	movs	r3, #0
  2053aa:	4604      	mov	r4, r0
  2053ac:	4608      	mov	r0, r1
  2053ae:	602b      	str	r3, [r5, #0]
  2053b0:	f000 fb6e 	bl	205a90 <_sbrk>
  2053b4:	1c43      	adds	r3, r0, #1
  2053b6:	d102      	bne.n	2053be <_sbrk_r+0x1a>
  2053b8:	682b      	ldr	r3, [r5, #0]
  2053ba:	b103      	cbz	r3, 2053be <_sbrk_r+0x1a>
  2053bc:	6023      	str	r3, [r4, #0]
  2053be:	bd38      	pop	{r3, r4, r5, pc}
  2053c0:	2000203c 	.word	0x2000203c

002053c4 <siprintf>:
  2053c4:	b40e      	push	{r1, r2, r3}
  2053c6:	b500      	push	{lr}
  2053c8:	b09c      	sub	sp, #112	; 0x70
  2053ca:	ab1d      	add	r3, sp, #116	; 0x74
  2053cc:	9002      	str	r0, [sp, #8]
  2053ce:	9006      	str	r0, [sp, #24]
  2053d0:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
  2053d4:	4809      	ldr	r0, [pc, #36]	; (2053fc <siprintf+0x38>)
  2053d6:	9107      	str	r1, [sp, #28]
  2053d8:	9104      	str	r1, [sp, #16]
  2053da:	4909      	ldr	r1, [pc, #36]	; (205400 <siprintf+0x3c>)
  2053dc:	f853 2b04 	ldr.w	r2, [r3], #4
  2053e0:	9105      	str	r1, [sp, #20]
  2053e2:	6800      	ldr	r0, [r0, #0]
  2053e4:	9301      	str	r3, [sp, #4]
  2053e6:	a902      	add	r1, sp, #8
  2053e8:	f000 f874 	bl	2054d4 <_svfiprintf_r>
  2053ec:	9b02      	ldr	r3, [sp, #8]
  2053ee:	2200      	movs	r2, #0
  2053f0:	701a      	strb	r2, [r3, #0]
  2053f2:	b01c      	add	sp, #112	; 0x70
  2053f4:	f85d eb04 	ldr.w	lr, [sp], #4
  2053f8:	b003      	add	sp, #12
  2053fa:	4770      	bx	lr
  2053fc:	2002006c 	.word	0x2002006c
  205400:	ffff0208 	.word	0xffff0208

00205404 <__malloc_lock>:
  205404:	4801      	ldr	r0, [pc, #4]	; (20540c <__malloc_lock+0x8>)
  205406:	f000 baf9 	b.w	2059fc <__retarget_lock_acquire_recursive>
  20540a:	bf00      	nop
  20540c:	20002040 	.word	0x20002040

00205410 <__malloc_unlock>:
  205410:	4801      	ldr	r0, [pc, #4]	; (205418 <__malloc_unlock+0x8>)
  205412:	f000 baf4 	b.w	2059fe <__retarget_lock_release_recursive>
  205416:	bf00      	nop
  205418:	20002040 	.word	0x20002040

0020541c <__ssputs_r>:
  20541c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  205420:	688e      	ldr	r6, [r1, #8]
  205422:	429e      	cmp	r6, r3
  205424:	4682      	mov	sl, r0
  205426:	460c      	mov	r4, r1
  205428:	4690      	mov	r8, r2
  20542a:	461f      	mov	r7, r3
  20542c:	d838      	bhi.n	2054a0 <__ssputs_r+0x84>
  20542e:	898a      	ldrh	r2, [r1, #12]
  205430:	f412 6f90 	tst.w	r2, #1152	; 0x480
  205434:	d032      	beq.n	20549c <__ssputs_r+0x80>
  205436:	6825      	ldr	r5, [r4, #0]
  205438:	6909      	ldr	r1, [r1, #16]
  20543a:	eba5 0901 	sub.w	r9, r5, r1
  20543e:	6965      	ldr	r5, [r4, #20]
  205440:	eb05 0545 	add.w	r5, r5, r5, lsl #1
  205444:	eb05 75d5 	add.w	r5, r5, r5, lsr #31
  205448:	3301      	adds	r3, #1
  20544a:	444b      	add	r3, r9
  20544c:	106d      	asrs	r5, r5, #1
  20544e:	429d      	cmp	r5, r3
  205450:	bf38      	it	cc
  205452:	461d      	movcc	r5, r3
  205454:	0553      	lsls	r3, r2, #21
  205456:	d531      	bpl.n	2054bc <__ssputs_r+0xa0>
  205458:	4629      	mov	r1, r5
  20545a:	f7ff ff49 	bl	2052f0 <_malloc_r>
  20545e:	4606      	mov	r6, r0
  205460:	b950      	cbnz	r0, 205478 <__ssputs_r+0x5c>
  205462:	230c      	movs	r3, #12
  205464:	f8ca 3000 	str.w	r3, [sl]
  205468:	89a3      	ldrh	r3, [r4, #12]
  20546a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  20546e:	81a3      	strh	r3, [r4, #12]
  205470:	f04f 30ff 	mov.w	r0, #4294967295
  205474:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  205478:	6921      	ldr	r1, [r4, #16]
  20547a:	464a      	mov	r2, r9
  20547c:	f7ff fed8 	bl	205230 <memcpy>
  205480:	89a3      	ldrh	r3, [r4, #12]
  205482:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
  205486:	f043 0380 	orr.w	r3, r3, #128	; 0x80
  20548a:	81a3      	strh	r3, [r4, #12]
  20548c:	6126      	str	r6, [r4, #16]
  20548e:	6165      	str	r5, [r4, #20]
  205490:	444e      	add	r6, r9
  205492:	eba5 0509 	sub.w	r5, r5, r9
  205496:	6026      	str	r6, [r4, #0]
  205498:	60a5      	str	r5, [r4, #8]
  20549a:	463e      	mov	r6, r7
  20549c:	42be      	cmp	r6, r7
  20549e:	d900      	bls.n	2054a2 <__ssputs_r+0x86>
  2054a0:	463e      	mov	r6, r7
  2054a2:	6820      	ldr	r0, [r4, #0]
  2054a4:	4632      	mov	r2, r6
  2054a6:	4641      	mov	r1, r8
  2054a8:	f000 faaa 	bl	205a00 <memmove>
  2054ac:	68a3      	ldr	r3, [r4, #8]
  2054ae:	1b9b      	subs	r3, r3, r6
  2054b0:	60a3      	str	r3, [r4, #8]
  2054b2:	6823      	ldr	r3, [r4, #0]
  2054b4:	4433      	add	r3, r6
  2054b6:	6023      	str	r3, [r4, #0]
  2054b8:	2000      	movs	r0, #0
  2054ba:	e7db      	b.n	205474 <__ssputs_r+0x58>
  2054bc:	462a      	mov	r2, r5
  2054be:	f000 fab9 	bl	205a34 <_realloc_r>
  2054c2:	4606      	mov	r6, r0
  2054c4:	2800      	cmp	r0, #0
  2054c6:	d1e1      	bne.n	20548c <__ssputs_r+0x70>
  2054c8:	6921      	ldr	r1, [r4, #16]
  2054ca:	4650      	mov	r0, sl
  2054cc:	f7ff fec6 	bl	20525c <_free_r>
  2054d0:	e7c7      	b.n	205462 <__ssputs_r+0x46>
	...

002054d4 <_svfiprintf_r>:
  2054d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2054d8:	4698      	mov	r8, r3
  2054da:	898b      	ldrh	r3, [r1, #12]
  2054dc:	061b      	lsls	r3, r3, #24
  2054de:	b09d      	sub	sp, #116	; 0x74
  2054e0:	4607      	mov	r7, r0
  2054e2:	460d      	mov	r5, r1
  2054e4:	4614      	mov	r4, r2
  2054e6:	d50e      	bpl.n	205506 <_svfiprintf_r+0x32>
  2054e8:	690b      	ldr	r3, [r1, #16]
  2054ea:	b963      	cbnz	r3, 205506 <_svfiprintf_r+0x32>
  2054ec:	2140      	movs	r1, #64	; 0x40
  2054ee:	f7ff feff 	bl	2052f0 <_malloc_r>
  2054f2:	6028      	str	r0, [r5, #0]
  2054f4:	6128      	str	r0, [r5, #16]
  2054f6:	b920      	cbnz	r0, 205502 <_svfiprintf_r+0x2e>
  2054f8:	230c      	movs	r3, #12
  2054fa:	603b      	str	r3, [r7, #0]
  2054fc:	f04f 30ff 	mov.w	r0, #4294967295
  205500:	e0d1      	b.n	2056a6 <_svfiprintf_r+0x1d2>
  205502:	2340      	movs	r3, #64	; 0x40
  205504:	616b      	str	r3, [r5, #20]
  205506:	2300      	movs	r3, #0
  205508:	9309      	str	r3, [sp, #36]	; 0x24
  20550a:	2320      	movs	r3, #32
  20550c:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
  205510:	f8cd 800c 	str.w	r8, [sp, #12]
  205514:	2330      	movs	r3, #48	; 0x30
  205516:	f8df 81a8 	ldr.w	r8, [pc, #424]	; 2056c0 <_svfiprintf_r+0x1ec>
  20551a:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
  20551e:	f04f 0901 	mov.w	r9, #1
  205522:	4623      	mov	r3, r4
  205524:	469a      	mov	sl, r3
  205526:	f813 2b01 	ldrb.w	r2, [r3], #1
  20552a:	b10a      	cbz	r2, 205530 <_svfiprintf_r+0x5c>
  20552c:	2a25      	cmp	r2, #37	; 0x25
  20552e:	d1f9      	bne.n	205524 <_svfiprintf_r+0x50>
  205530:	ebba 0b04 	subs.w	fp, sl, r4
  205534:	d00b      	beq.n	20554e <_svfiprintf_r+0x7a>
  205536:	465b      	mov	r3, fp
  205538:	4622      	mov	r2, r4
  20553a:	4629      	mov	r1, r5
  20553c:	4638      	mov	r0, r7
  20553e:	f7ff ff6d 	bl	20541c <__ssputs_r>
  205542:	3001      	adds	r0, #1
  205544:	f000 80aa 	beq.w	20569c <_svfiprintf_r+0x1c8>
  205548:	9a09      	ldr	r2, [sp, #36]	; 0x24
  20554a:	445a      	add	r2, fp
  20554c:	9209      	str	r2, [sp, #36]	; 0x24
  20554e:	f89a 3000 	ldrb.w	r3, [sl]
  205552:	2b00      	cmp	r3, #0
  205554:	f000 80a2 	beq.w	20569c <_svfiprintf_r+0x1c8>
  205558:	2300      	movs	r3, #0
  20555a:	f04f 32ff 	mov.w	r2, #4294967295
  20555e:	e9cd 2305 	strd	r2, r3, [sp, #20]
  205562:	f10a 0a01 	add.w	sl, sl, #1
  205566:	9304      	str	r3, [sp, #16]
  205568:	9307      	str	r3, [sp, #28]
  20556a:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
  20556e:	931a      	str	r3, [sp, #104]	; 0x68
  205570:	4654      	mov	r4, sl
  205572:	2205      	movs	r2, #5
  205574:	f814 1b01 	ldrb.w	r1, [r4], #1
  205578:	4851      	ldr	r0, [pc, #324]	; (2056c0 <_svfiprintf_r+0x1ec>)
  20557a:	f7fa fec9 	bl	200310 <memchr>
  20557e:	9a04      	ldr	r2, [sp, #16]
  205580:	b9d8      	cbnz	r0, 2055ba <_svfiprintf_r+0xe6>
  205582:	06d0      	lsls	r0, r2, #27
  205584:	bf44      	itt	mi
  205586:	2320      	movmi	r3, #32
  205588:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
  20558c:	0711      	lsls	r1, r2, #28
  20558e:	bf44      	itt	mi
  205590:	232b      	movmi	r3, #43	; 0x2b
  205592:	f88d 3053 	strbmi.w	r3, [sp, #83]	; 0x53
  205596:	f89a 3000 	ldrb.w	r3, [sl]
  20559a:	2b2a      	cmp	r3, #42	; 0x2a
  20559c:	d015      	beq.n	2055ca <_svfiprintf_r+0xf6>
  20559e:	9a07      	ldr	r2, [sp, #28]
  2055a0:	4654      	mov	r4, sl
  2055a2:	2000      	movs	r0, #0
  2055a4:	f04f 0c0a 	mov.w	ip, #10
  2055a8:	4621      	mov	r1, r4
  2055aa:	f811 3b01 	ldrb.w	r3, [r1], #1
  2055ae:	3b30      	subs	r3, #48	; 0x30
  2055b0:	2b09      	cmp	r3, #9
  2055b2:	d94e      	bls.n	205652 <_svfiprintf_r+0x17e>
  2055b4:	b1b0      	cbz	r0, 2055e4 <_svfiprintf_r+0x110>
  2055b6:	9207      	str	r2, [sp, #28]
  2055b8:	e014      	b.n	2055e4 <_svfiprintf_r+0x110>
  2055ba:	eba0 0308 	sub.w	r3, r0, r8
  2055be:	fa09 f303 	lsl.w	r3, r9, r3
  2055c2:	4313      	orrs	r3, r2
  2055c4:	9304      	str	r3, [sp, #16]
  2055c6:	46a2      	mov	sl, r4
  2055c8:	e7d2      	b.n	205570 <_svfiprintf_r+0x9c>
  2055ca:	9b03      	ldr	r3, [sp, #12]
  2055cc:	1d19      	adds	r1, r3, #4
  2055ce:	681b      	ldr	r3, [r3, #0]
  2055d0:	9103      	str	r1, [sp, #12]
  2055d2:	2b00      	cmp	r3, #0
  2055d4:	bfbb      	ittet	lt
  2055d6:	425b      	neglt	r3, r3
  2055d8:	f042 0202 	orrlt.w	r2, r2, #2
  2055dc:	9307      	strge	r3, [sp, #28]
  2055de:	9307      	strlt	r3, [sp, #28]
  2055e0:	bfb8      	it	lt
  2055e2:	9204      	strlt	r2, [sp, #16]
  2055e4:	7823      	ldrb	r3, [r4, #0]
  2055e6:	2b2e      	cmp	r3, #46	; 0x2e
  2055e8:	d10c      	bne.n	205604 <_svfiprintf_r+0x130>
  2055ea:	7863      	ldrb	r3, [r4, #1]
  2055ec:	2b2a      	cmp	r3, #42	; 0x2a
  2055ee:	d135      	bne.n	20565c <_svfiprintf_r+0x188>
  2055f0:	9b03      	ldr	r3, [sp, #12]
  2055f2:	1d1a      	adds	r2, r3, #4
  2055f4:	681b      	ldr	r3, [r3, #0]
  2055f6:	9203      	str	r2, [sp, #12]
  2055f8:	2b00      	cmp	r3, #0
  2055fa:	bfb8      	it	lt
  2055fc:	f04f 33ff 	movlt.w	r3, #4294967295
  205600:	3402      	adds	r4, #2
  205602:	9305      	str	r3, [sp, #20]
  205604:	f8df a0bc 	ldr.w	sl, [pc, #188]	; 2056c4 <_svfiprintf_r+0x1f0>
  205608:	7821      	ldrb	r1, [r4, #0]
  20560a:	2203      	movs	r2, #3
  20560c:	4650      	mov	r0, sl
  20560e:	f7fa fe7f 	bl	200310 <memchr>
  205612:	b140      	cbz	r0, 205626 <_svfiprintf_r+0x152>
  205614:	2340      	movs	r3, #64	; 0x40
  205616:	eba0 000a 	sub.w	r0, r0, sl
  20561a:	fa03 f000 	lsl.w	r0, r3, r0
  20561e:	9b04      	ldr	r3, [sp, #16]
  205620:	4303      	orrs	r3, r0
  205622:	3401      	adds	r4, #1
  205624:	9304      	str	r3, [sp, #16]
  205626:	f814 1b01 	ldrb.w	r1, [r4], #1
  20562a:	4827      	ldr	r0, [pc, #156]	; (2056c8 <_svfiprintf_r+0x1f4>)
  20562c:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
  205630:	2206      	movs	r2, #6
  205632:	f7fa fe6d 	bl	200310 <memchr>
  205636:	2800      	cmp	r0, #0
  205638:	d038      	beq.n	2056ac <_svfiprintf_r+0x1d8>
  20563a:	4b24      	ldr	r3, [pc, #144]	; (2056cc <_svfiprintf_r+0x1f8>)
  20563c:	bb1b      	cbnz	r3, 205686 <_svfiprintf_r+0x1b2>
  20563e:	9b03      	ldr	r3, [sp, #12]
  205640:	3307      	adds	r3, #7
  205642:	f023 0307 	bic.w	r3, r3, #7
  205646:	3308      	adds	r3, #8
  205648:	9303      	str	r3, [sp, #12]
  20564a:	9b09      	ldr	r3, [sp, #36]	; 0x24
  20564c:	4433      	add	r3, r6
  20564e:	9309      	str	r3, [sp, #36]	; 0x24
  205650:	e767      	b.n	205522 <_svfiprintf_r+0x4e>
  205652:	fb0c 3202 	mla	r2, ip, r2, r3
  205656:	460c      	mov	r4, r1
  205658:	2001      	movs	r0, #1
  20565a:	e7a5      	b.n	2055a8 <_svfiprintf_r+0xd4>
  20565c:	2300      	movs	r3, #0
  20565e:	3401      	adds	r4, #1
  205660:	9305      	str	r3, [sp, #20]
  205662:	4619      	mov	r1, r3
  205664:	f04f 0c0a 	mov.w	ip, #10
  205668:	4620      	mov	r0, r4
  20566a:	f810 2b01 	ldrb.w	r2, [r0], #1
  20566e:	3a30      	subs	r2, #48	; 0x30
  205670:	2a09      	cmp	r2, #9
  205672:	d903      	bls.n	20567c <_svfiprintf_r+0x1a8>
  205674:	2b00      	cmp	r3, #0
  205676:	d0c5      	beq.n	205604 <_svfiprintf_r+0x130>
  205678:	9105      	str	r1, [sp, #20]
  20567a:	e7c3      	b.n	205604 <_svfiprintf_r+0x130>
  20567c:	fb0c 2101 	mla	r1, ip, r1, r2
  205680:	4604      	mov	r4, r0
  205682:	2301      	movs	r3, #1
  205684:	e7f0      	b.n	205668 <_svfiprintf_r+0x194>
  205686:	ab03      	add	r3, sp, #12
  205688:	9300      	str	r3, [sp, #0]
  20568a:	462a      	mov	r2, r5
  20568c:	4b10      	ldr	r3, [pc, #64]	; (2056d0 <_svfiprintf_r+0x1fc>)
  20568e:	a904      	add	r1, sp, #16
  205690:	4638      	mov	r0, r7
  205692:	f3af 8000 	nop.w
  205696:	1c42      	adds	r2, r0, #1
  205698:	4606      	mov	r6, r0
  20569a:	d1d6      	bne.n	20564a <_svfiprintf_r+0x176>
  20569c:	89ab      	ldrh	r3, [r5, #12]
  20569e:	065b      	lsls	r3, r3, #25
  2056a0:	f53f af2c 	bmi.w	2054fc <_svfiprintf_r+0x28>
  2056a4:	9809      	ldr	r0, [sp, #36]	; 0x24
  2056a6:	b01d      	add	sp, #116	; 0x74
  2056a8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  2056ac:	ab03      	add	r3, sp, #12
  2056ae:	9300      	str	r3, [sp, #0]
  2056b0:	462a      	mov	r2, r5
  2056b2:	4b07      	ldr	r3, [pc, #28]	; (2056d0 <_svfiprintf_r+0x1fc>)
  2056b4:	a904      	add	r1, sp, #16
  2056b6:	4638      	mov	r0, r7
  2056b8:	f000 f87a 	bl	2057b0 <_printf_i>
  2056bc:	e7eb      	b.n	205696 <_svfiprintf_r+0x1c2>
  2056be:	bf00      	nop
  2056c0:	0800601c 	.word	0x0800601c
  2056c4:	08006022 	.word	0x08006022
  2056c8:	08006026 	.word	0x08006026
  2056cc:	00000000 	.word	0x00000000
  2056d0:	0020541d 	.word	0x0020541d

002056d4 <_printf_common>:
  2056d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  2056d8:	4616      	mov	r6, r2
  2056da:	4699      	mov	r9, r3
  2056dc:	688a      	ldr	r2, [r1, #8]
  2056de:	690b      	ldr	r3, [r1, #16]
  2056e0:	f8dd 8020 	ldr.w	r8, [sp, #32]
  2056e4:	4293      	cmp	r3, r2
  2056e6:	bfb8      	it	lt
  2056e8:	4613      	movlt	r3, r2
  2056ea:	6033      	str	r3, [r6, #0]
  2056ec:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
  2056f0:	4607      	mov	r7, r0
  2056f2:	460c      	mov	r4, r1
  2056f4:	b10a      	cbz	r2, 2056fa <_printf_common+0x26>
  2056f6:	3301      	adds	r3, #1
  2056f8:	6033      	str	r3, [r6, #0]
  2056fa:	6823      	ldr	r3, [r4, #0]
  2056fc:	0699      	lsls	r1, r3, #26
  2056fe:	bf42      	ittt	mi
  205700:	6833      	ldrmi	r3, [r6, #0]
  205702:	3302      	addmi	r3, #2
  205704:	6033      	strmi	r3, [r6, #0]
  205706:	6825      	ldr	r5, [r4, #0]
  205708:	f015 0506 	ands.w	r5, r5, #6
  20570c:	d106      	bne.n	20571c <_printf_common+0x48>
  20570e:	f104 0a19 	add.w	sl, r4, #25
  205712:	68e3      	ldr	r3, [r4, #12]
  205714:	6832      	ldr	r2, [r6, #0]
  205716:	1a9b      	subs	r3, r3, r2
  205718:	42ab      	cmp	r3, r5
  20571a:	dc26      	bgt.n	20576a <_printf_common+0x96>
  20571c:	f894 2043 	ldrb.w	r2, [r4, #67]	; 0x43
  205720:	1e13      	subs	r3, r2, #0
  205722:	6822      	ldr	r2, [r4, #0]
  205724:	bf18      	it	ne
  205726:	2301      	movne	r3, #1
  205728:	0692      	lsls	r2, r2, #26
  20572a:	d42b      	bmi.n	205784 <_printf_common+0xb0>
  20572c:	f104 0243 	add.w	r2, r4, #67	; 0x43
  205730:	4649      	mov	r1, r9
  205732:	4638      	mov	r0, r7
  205734:	47c0      	blx	r8
  205736:	3001      	adds	r0, #1
  205738:	d01e      	beq.n	205778 <_printf_common+0xa4>
  20573a:	6823      	ldr	r3, [r4, #0]
  20573c:	68e5      	ldr	r5, [r4, #12]
  20573e:	6832      	ldr	r2, [r6, #0]
  205740:	f003 0306 	and.w	r3, r3, #6
  205744:	2b04      	cmp	r3, #4
  205746:	bf08      	it	eq
  205748:	1aad      	subeq	r5, r5, r2
  20574a:	68a3      	ldr	r3, [r4, #8]
  20574c:	6922      	ldr	r2, [r4, #16]
  20574e:	bf0c      	ite	eq
  205750:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
  205754:	2500      	movne	r5, #0
  205756:	4293      	cmp	r3, r2
  205758:	bfc4      	itt	gt
  20575a:	1a9b      	subgt	r3, r3, r2
  20575c:	18ed      	addgt	r5, r5, r3
  20575e:	2600      	movs	r6, #0
  205760:	341a      	adds	r4, #26
  205762:	42b5      	cmp	r5, r6
  205764:	d11a      	bne.n	20579c <_printf_common+0xc8>
  205766:	2000      	movs	r0, #0
  205768:	e008      	b.n	20577c <_printf_common+0xa8>
  20576a:	2301      	movs	r3, #1
  20576c:	4652      	mov	r2, sl
  20576e:	4649      	mov	r1, r9
  205770:	4638      	mov	r0, r7
  205772:	47c0      	blx	r8
  205774:	3001      	adds	r0, #1
  205776:	d103      	bne.n	205780 <_printf_common+0xac>
  205778:	f04f 30ff 	mov.w	r0, #4294967295
  20577c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  205780:	3501      	adds	r5, #1
  205782:	e7c6      	b.n	205712 <_printf_common+0x3e>
  205784:	18e1      	adds	r1, r4, r3
  205786:	1c5a      	adds	r2, r3, #1
  205788:	2030      	movs	r0, #48	; 0x30
  20578a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
  20578e:	4422      	add	r2, r4
  205790:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
  205794:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
  205798:	3302      	adds	r3, #2
  20579a:	e7c7      	b.n	20572c <_printf_common+0x58>
  20579c:	2301      	movs	r3, #1
  20579e:	4622      	mov	r2, r4
  2057a0:	4649      	mov	r1, r9
  2057a2:	4638      	mov	r0, r7
  2057a4:	47c0      	blx	r8
  2057a6:	3001      	adds	r0, #1
  2057a8:	d0e6      	beq.n	205778 <_printf_common+0xa4>
  2057aa:	3601      	adds	r6, #1
  2057ac:	e7d9      	b.n	205762 <_printf_common+0x8e>
	...

002057b0 <_printf_i>:
  2057b0:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
  2057b4:	7e0f      	ldrb	r7, [r1, #24]
  2057b6:	9d0c      	ldr	r5, [sp, #48]	; 0x30
  2057b8:	2f78      	cmp	r7, #120	; 0x78
  2057ba:	4691      	mov	r9, r2
  2057bc:	4680      	mov	r8, r0
  2057be:	460c      	mov	r4, r1
  2057c0:	469a      	mov	sl, r3
  2057c2:	f101 0243 	add.w	r2, r1, #67	; 0x43
  2057c6:	d807      	bhi.n	2057d8 <_printf_i+0x28>
  2057c8:	2f62      	cmp	r7, #98	; 0x62
  2057ca:	d80a      	bhi.n	2057e2 <_printf_i+0x32>
  2057cc:	2f00      	cmp	r7, #0
  2057ce:	f000 80d8 	beq.w	205982 <_printf_i+0x1d2>
  2057d2:	2f58      	cmp	r7, #88	; 0x58
  2057d4:	f000 80a3 	beq.w	20591e <_printf_i+0x16e>
  2057d8:	f104 0542 	add.w	r5, r4, #66	; 0x42
  2057dc:	f884 7042 	strb.w	r7, [r4, #66]	; 0x42
  2057e0:	e03a      	b.n	205858 <_printf_i+0xa8>
  2057e2:	f1a7 0363 	sub.w	r3, r7, #99	; 0x63
  2057e6:	2b15      	cmp	r3, #21
  2057e8:	d8f6      	bhi.n	2057d8 <_printf_i+0x28>
  2057ea:	a101      	add	r1, pc, #4	; (adr r1, 2057f0 <_printf_i+0x40>)
  2057ec:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
  2057f0:	00205849 	.word	0x00205849
  2057f4:	0020585d 	.word	0x0020585d
  2057f8:	002057d9 	.word	0x002057d9
  2057fc:	002057d9 	.word	0x002057d9
  205800:	002057d9 	.word	0x002057d9
  205804:	002057d9 	.word	0x002057d9
  205808:	0020585d 	.word	0x0020585d
  20580c:	002057d9 	.word	0x002057d9
  205810:	002057d9 	.word	0x002057d9
  205814:	002057d9 	.word	0x002057d9
  205818:	002057d9 	.word	0x002057d9
  20581c:	00205969 	.word	0x00205969
  205820:	0020588d 	.word	0x0020588d
  205824:	0020594b 	.word	0x0020594b
  205828:	002057d9 	.word	0x002057d9
  20582c:	002057d9 	.word	0x002057d9
  205830:	0020598b 	.word	0x0020598b
  205834:	002057d9 	.word	0x002057d9
  205838:	0020588d 	.word	0x0020588d
  20583c:	002057d9 	.word	0x002057d9
  205840:	002057d9 	.word	0x002057d9
  205844:	00205953 	.word	0x00205953
  205848:	682b      	ldr	r3, [r5, #0]
  20584a:	1d1a      	adds	r2, r3, #4
  20584c:	681b      	ldr	r3, [r3, #0]
  20584e:	602a      	str	r2, [r5, #0]
  205850:	f104 0542 	add.w	r5, r4, #66	; 0x42
  205854:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
  205858:	2301      	movs	r3, #1
  20585a:	e0a3      	b.n	2059a4 <_printf_i+0x1f4>
  20585c:	6820      	ldr	r0, [r4, #0]
  20585e:	6829      	ldr	r1, [r5, #0]
  205860:	0606      	lsls	r6, r0, #24
  205862:	f101 0304 	add.w	r3, r1, #4
  205866:	d50a      	bpl.n	20587e <_printf_i+0xce>
  205868:	680e      	ldr	r6, [r1, #0]
  20586a:	602b      	str	r3, [r5, #0]
  20586c:	2e00      	cmp	r6, #0
  20586e:	da03      	bge.n	205878 <_printf_i+0xc8>
  205870:	232d      	movs	r3, #45	; 0x2d
  205872:	4276      	negs	r6, r6
  205874:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  205878:	485e      	ldr	r0, [pc, #376]	; (2059f4 <_printf_i+0x244>)
  20587a:	230a      	movs	r3, #10
  20587c:	e019      	b.n	2058b2 <_printf_i+0x102>
  20587e:	680e      	ldr	r6, [r1, #0]
  205880:	602b      	str	r3, [r5, #0]
  205882:	f010 0f40 	tst.w	r0, #64	; 0x40
  205886:	bf18      	it	ne
  205888:	b236      	sxthne	r6, r6
  20588a:	e7ef      	b.n	20586c <_printf_i+0xbc>
  20588c:	682b      	ldr	r3, [r5, #0]
  20588e:	6820      	ldr	r0, [r4, #0]
  205890:	1d19      	adds	r1, r3, #4
  205892:	6029      	str	r1, [r5, #0]
  205894:	0601      	lsls	r1, r0, #24
  205896:	d501      	bpl.n	20589c <_printf_i+0xec>
  205898:	681e      	ldr	r6, [r3, #0]
  20589a:	e002      	b.n	2058a2 <_printf_i+0xf2>
  20589c:	0646      	lsls	r6, r0, #25
  20589e:	d5fb      	bpl.n	205898 <_printf_i+0xe8>
  2058a0:	881e      	ldrh	r6, [r3, #0]
  2058a2:	4854      	ldr	r0, [pc, #336]	; (2059f4 <_printf_i+0x244>)
  2058a4:	2f6f      	cmp	r7, #111	; 0x6f
  2058a6:	bf0c      	ite	eq
  2058a8:	2308      	moveq	r3, #8
  2058aa:	230a      	movne	r3, #10
  2058ac:	2100      	movs	r1, #0
  2058ae:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
  2058b2:	6865      	ldr	r5, [r4, #4]
  2058b4:	60a5      	str	r5, [r4, #8]
  2058b6:	2d00      	cmp	r5, #0
  2058b8:	bfa2      	ittt	ge
  2058ba:	6821      	ldrge	r1, [r4, #0]
  2058bc:	f021 0104 	bicge.w	r1, r1, #4
  2058c0:	6021      	strge	r1, [r4, #0]
  2058c2:	b90e      	cbnz	r6, 2058c8 <_printf_i+0x118>
  2058c4:	2d00      	cmp	r5, #0
  2058c6:	d04d      	beq.n	205964 <_printf_i+0x1b4>
  2058c8:	4615      	mov	r5, r2
  2058ca:	fbb6 f1f3 	udiv	r1, r6, r3
  2058ce:	fb03 6711 	mls	r7, r3, r1, r6
  2058d2:	5dc7      	ldrb	r7, [r0, r7]
  2058d4:	f805 7d01 	strb.w	r7, [r5, #-1]!
  2058d8:	4637      	mov	r7, r6
  2058da:	42bb      	cmp	r3, r7
  2058dc:	460e      	mov	r6, r1
  2058de:	d9f4      	bls.n	2058ca <_printf_i+0x11a>
  2058e0:	2b08      	cmp	r3, #8
  2058e2:	d10b      	bne.n	2058fc <_printf_i+0x14c>
  2058e4:	6823      	ldr	r3, [r4, #0]
  2058e6:	07de      	lsls	r6, r3, #31
  2058e8:	d508      	bpl.n	2058fc <_printf_i+0x14c>
  2058ea:	6923      	ldr	r3, [r4, #16]
  2058ec:	6861      	ldr	r1, [r4, #4]
  2058ee:	4299      	cmp	r1, r3
  2058f0:	bfde      	ittt	le
  2058f2:	2330      	movle	r3, #48	; 0x30
  2058f4:	f805 3c01 	strble.w	r3, [r5, #-1]
  2058f8:	f105 35ff 	addle.w	r5, r5, #4294967295
  2058fc:	1b52      	subs	r2, r2, r5
  2058fe:	6122      	str	r2, [r4, #16]
  205900:	f8cd a000 	str.w	sl, [sp]
  205904:	464b      	mov	r3, r9
  205906:	aa03      	add	r2, sp, #12
  205908:	4621      	mov	r1, r4
  20590a:	4640      	mov	r0, r8
  20590c:	f7ff fee2 	bl	2056d4 <_printf_common>
  205910:	3001      	adds	r0, #1
  205912:	d14c      	bne.n	2059ae <_printf_i+0x1fe>
  205914:	f04f 30ff 	mov.w	r0, #4294967295
  205918:	b004      	add	sp, #16
  20591a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  20591e:	4835      	ldr	r0, [pc, #212]	; (2059f4 <_printf_i+0x244>)
  205920:	f881 7045 	strb.w	r7, [r1, #69]	; 0x45
  205924:	6829      	ldr	r1, [r5, #0]
  205926:	6823      	ldr	r3, [r4, #0]
  205928:	f851 6b04 	ldr.w	r6, [r1], #4
  20592c:	6029      	str	r1, [r5, #0]
  20592e:	061d      	lsls	r5, r3, #24
  205930:	d514      	bpl.n	20595c <_printf_i+0x1ac>
  205932:	07df      	lsls	r7, r3, #31
  205934:	bf44      	itt	mi
  205936:	f043 0320 	orrmi.w	r3, r3, #32
  20593a:	6023      	strmi	r3, [r4, #0]
  20593c:	b91e      	cbnz	r6, 205946 <_printf_i+0x196>
  20593e:	6823      	ldr	r3, [r4, #0]
  205940:	f023 0320 	bic.w	r3, r3, #32
  205944:	6023      	str	r3, [r4, #0]
  205946:	2310      	movs	r3, #16
  205948:	e7b0      	b.n	2058ac <_printf_i+0xfc>
  20594a:	6823      	ldr	r3, [r4, #0]
  20594c:	f043 0320 	orr.w	r3, r3, #32
  205950:	6023      	str	r3, [r4, #0]
  205952:	2378      	movs	r3, #120	; 0x78
  205954:	4828      	ldr	r0, [pc, #160]	; (2059f8 <_printf_i+0x248>)
  205956:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
  20595a:	e7e3      	b.n	205924 <_printf_i+0x174>
  20595c:	0659      	lsls	r1, r3, #25
  20595e:	bf48      	it	mi
  205960:	b2b6      	uxthmi	r6, r6
  205962:	e7e6      	b.n	205932 <_printf_i+0x182>
  205964:	4615      	mov	r5, r2
  205966:	e7bb      	b.n	2058e0 <_printf_i+0x130>
  205968:	682b      	ldr	r3, [r5, #0]
  20596a:	6826      	ldr	r6, [r4, #0]
  20596c:	6961      	ldr	r1, [r4, #20]
  20596e:	1d18      	adds	r0, r3, #4
  205970:	6028      	str	r0, [r5, #0]
  205972:	0635      	lsls	r5, r6, #24
  205974:	681b      	ldr	r3, [r3, #0]
  205976:	d501      	bpl.n	20597c <_printf_i+0x1cc>
  205978:	6019      	str	r1, [r3, #0]
  20597a:	e002      	b.n	205982 <_printf_i+0x1d2>
  20597c:	0670      	lsls	r0, r6, #25
  20597e:	d5fb      	bpl.n	205978 <_printf_i+0x1c8>
  205980:	8019      	strh	r1, [r3, #0]
  205982:	2300      	movs	r3, #0
  205984:	6123      	str	r3, [r4, #16]
  205986:	4615      	mov	r5, r2
  205988:	e7ba      	b.n	205900 <_printf_i+0x150>
  20598a:	682b      	ldr	r3, [r5, #0]
  20598c:	1d1a      	adds	r2, r3, #4
  20598e:	602a      	str	r2, [r5, #0]
  205990:	681d      	ldr	r5, [r3, #0]
  205992:	6862      	ldr	r2, [r4, #4]
  205994:	2100      	movs	r1, #0
  205996:	4628      	mov	r0, r5
  205998:	f7fa fcba 	bl	200310 <memchr>
  20599c:	b108      	cbz	r0, 2059a2 <_printf_i+0x1f2>
  20599e:	1b40      	subs	r0, r0, r5
  2059a0:	6060      	str	r0, [r4, #4]
  2059a2:	6863      	ldr	r3, [r4, #4]
  2059a4:	6123      	str	r3, [r4, #16]
  2059a6:	2300      	movs	r3, #0
  2059a8:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
  2059ac:	e7a8      	b.n	205900 <_printf_i+0x150>
  2059ae:	6923      	ldr	r3, [r4, #16]
  2059b0:	462a      	mov	r2, r5
  2059b2:	4649      	mov	r1, r9
  2059b4:	4640      	mov	r0, r8
  2059b6:	47d0      	blx	sl
  2059b8:	3001      	adds	r0, #1
  2059ba:	d0ab      	beq.n	205914 <_printf_i+0x164>
  2059bc:	6823      	ldr	r3, [r4, #0]
  2059be:	079b      	lsls	r3, r3, #30
  2059c0:	d413      	bmi.n	2059ea <_printf_i+0x23a>
  2059c2:	68e0      	ldr	r0, [r4, #12]
  2059c4:	9b03      	ldr	r3, [sp, #12]
  2059c6:	4298      	cmp	r0, r3
  2059c8:	bfb8      	it	lt
  2059ca:	4618      	movlt	r0, r3
  2059cc:	e7a4      	b.n	205918 <_printf_i+0x168>
  2059ce:	2301      	movs	r3, #1
  2059d0:	4632      	mov	r2, r6
  2059d2:	4649      	mov	r1, r9
  2059d4:	4640      	mov	r0, r8
  2059d6:	47d0      	blx	sl
  2059d8:	3001      	adds	r0, #1
  2059da:	d09b      	beq.n	205914 <_printf_i+0x164>
  2059dc:	3501      	adds	r5, #1
  2059de:	68e3      	ldr	r3, [r4, #12]
  2059e0:	9903      	ldr	r1, [sp, #12]
  2059e2:	1a5b      	subs	r3, r3, r1
  2059e4:	42ab      	cmp	r3, r5
  2059e6:	dcf2      	bgt.n	2059ce <_printf_i+0x21e>
  2059e8:	e7eb      	b.n	2059c2 <_printf_i+0x212>
  2059ea:	2500      	movs	r5, #0
  2059ec:	f104 0619 	add.w	r6, r4, #25
  2059f0:	e7f5      	b.n	2059de <_printf_i+0x22e>
  2059f2:	bf00      	nop
  2059f4:	0800602d 	.word	0x0800602d
  2059f8:	0800603e 	.word	0x0800603e

002059fc <__retarget_lock_acquire_recursive>:
  2059fc:	4770      	bx	lr

002059fe <__retarget_lock_release_recursive>:
  2059fe:	4770      	bx	lr

00205a00 <memmove>:
  205a00:	4288      	cmp	r0, r1
  205a02:	b510      	push	{r4, lr}
  205a04:	eb01 0402 	add.w	r4, r1, r2
  205a08:	d902      	bls.n	205a10 <memmove+0x10>
  205a0a:	4284      	cmp	r4, r0
  205a0c:	4623      	mov	r3, r4
  205a0e:	d807      	bhi.n	205a20 <memmove+0x20>
  205a10:	1e43      	subs	r3, r0, #1
  205a12:	42a1      	cmp	r1, r4
  205a14:	d008      	beq.n	205a28 <memmove+0x28>
  205a16:	f811 2b01 	ldrb.w	r2, [r1], #1
  205a1a:	f803 2f01 	strb.w	r2, [r3, #1]!
  205a1e:	e7f8      	b.n	205a12 <memmove+0x12>
  205a20:	4402      	add	r2, r0
  205a22:	4601      	mov	r1, r0
  205a24:	428a      	cmp	r2, r1
  205a26:	d100      	bne.n	205a2a <memmove+0x2a>
  205a28:	bd10      	pop	{r4, pc}
  205a2a:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
  205a2e:	f802 4d01 	strb.w	r4, [r2, #-1]!
  205a32:	e7f7      	b.n	205a24 <memmove+0x24>

00205a34 <_realloc_r>:
  205a34:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  205a36:	4607      	mov	r7, r0
  205a38:	4614      	mov	r4, r2
  205a3a:	460e      	mov	r6, r1
  205a3c:	b921      	cbnz	r1, 205a48 <_realloc_r+0x14>
  205a3e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  205a42:	4611      	mov	r1, r2
  205a44:	f7ff bc54 	b.w	2052f0 <_malloc_r>
  205a48:	b922      	cbnz	r2, 205a54 <_realloc_r+0x20>
  205a4a:	f7ff fc07 	bl	20525c <_free_r>
  205a4e:	4625      	mov	r5, r4
  205a50:	4628      	mov	r0, r5
  205a52:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  205a54:	f000 f814 	bl	205a80 <_malloc_usable_size_r>
  205a58:	42a0      	cmp	r0, r4
  205a5a:	d20f      	bcs.n	205a7c <_realloc_r+0x48>
  205a5c:	4621      	mov	r1, r4
  205a5e:	4638      	mov	r0, r7
  205a60:	f7ff fc46 	bl	2052f0 <_malloc_r>
  205a64:	4605      	mov	r5, r0
  205a66:	2800      	cmp	r0, #0
  205a68:	d0f2      	beq.n	205a50 <_realloc_r+0x1c>
  205a6a:	4631      	mov	r1, r6
  205a6c:	4622      	mov	r2, r4
  205a6e:	f7ff fbdf 	bl	205230 <memcpy>
  205a72:	4631      	mov	r1, r6
  205a74:	4638      	mov	r0, r7
  205a76:	f7ff fbf1 	bl	20525c <_free_r>
  205a7a:	e7e9      	b.n	205a50 <_realloc_r+0x1c>
  205a7c:	4635      	mov	r5, r6
  205a7e:	e7e7      	b.n	205a50 <_realloc_r+0x1c>

00205a80 <_malloc_usable_size_r>:
  205a80:	f851 3c04 	ldr.w	r3, [r1, #-4]
  205a84:	1f18      	subs	r0, r3, #4
  205a86:	2b00      	cmp	r3, #0
  205a88:	bfbc      	itt	lt
  205a8a:	580b      	ldrlt	r3, [r1, r0]
  205a8c:	18c0      	addlt	r0, r0, r3
  205a8e:	4770      	bx	lr

00205a90 <_sbrk>:
  205a90:	4a04      	ldr	r2, [pc, #16]	; (205aa4 <_sbrk+0x14>)
  205a92:	4905      	ldr	r1, [pc, #20]	; (205aa8 <_sbrk+0x18>)
  205a94:	6813      	ldr	r3, [r2, #0]
  205a96:	2b00      	cmp	r3, #0
  205a98:	bf08      	it	eq
  205a9a:	460b      	moveq	r3, r1
  205a9c:	4418      	add	r0, r3
  205a9e:	6010      	str	r0, [r2, #0]
  205aa0:	4618      	mov	r0, r3
  205aa2:	4770      	bx	lr
  205aa4:	20002044 	.word	0x20002044
  205aa8:	20002048 	.word	0x20002048
